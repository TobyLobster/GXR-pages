; Graphics Extension ROM (GXR) (Acornsoft, 1985)
; Reassembly by Toby Nelson, 2023
;
; Table of Contents
; -----------------
;         Chapter 1: Introduction
;         Chapter 2: Constants
;         Chapter 3: Memory locations
; ($8000) Chapter 4: ROM header and service entry routines           (359 bytes)
;               How the OS and ROM communicate
; ($8167) Chapter 5: Parsing star commands                           (322 bytes)
;               Identify if the star command is one we can handle
; ($82a9) Chapter 6: Parsing OSBYTE (*FX) commands                   (160 bytes)
;               Check for the new *FX 163,242,0-66 commands
; ($8349) Chapter 7: Parsing *HELP Commands                         (1456 bytes)
;               Includes the *HELP text itself
; ($88f9) Chapter 8: Intercepting unknown VDU commands                (92 bytes)
;               Using the Extended VDU vectors
; ($8955) Chapter 9: Trampoline code for OSWRCH                       (72 bytes)
;               Intercepting OSWRCH and calling into the ROM
; ($899d) Chapter 10: Star commands affecting memory                 (237 bytes)
;               *GXR; *NOGXR; *FLOOD; *NOFLOOD; *SSPACE; *SNEW
; ($8a8a) Chapter 11: Shared PLOT subroutines and tables             (298 bytes)
;               Common code and data used while plotting
; ($8bb4) Chapter 12: VDU commands                                   (463 bytes)
;               Implementation of the new VDU commands
; ($8d83) Chapter 13: Sprite editor block memory copy                 (79 bytes)
;               For moving sprite memory around
; ($8dd2) Chapter 14: Point and Rectangle                            (137 bytes)
;               Single pixel and filled rectangle
; ($8e5b) Chapter 15: Parallelogram and Triangle                     (489 bytes)
;               Filled primitives
; ($9044) Chapter 16: Circle                                        (2094 bytes)
;               Outline; Filled; Arc; Sector; Segment
; ($9872) Chapter 17: Lines                                         (1147 bytes)
;               Includes dash pattern
; ($9ced) Chapter 18: Flood fill and horizontal fill                 (655 bytes)
;               Fills on screen starting from a single point
; ($9f7c) Chapter 19: Rectangle copy and move                        (732 bytes)
;               Moves a rectangluar area of the screen around
; ($a258) Chapter 20: Sprite plotting                                (438 bytes)
;               Plot at and pixel position, clipped to the graphics window
; ($a40e) Chapter 21: Sprite commands                               (1018 bytes)
;               *SGET; *SSAVE; *SLOAD; *SMERGE; *SCHOOSE; *SRENUMBER
; ($a808) Chapter 22: Sprite Editor                                 (4578 bytes)
;               Full screen sprite editor
; ($b9ea) Chapter 23: Ellipse                                        (998 bytes)
;               Outline; Filled
; ($bdd0) Chapter 24: Maths routines                                 (503 bytes)
;               Multiply; Divide; Square Root; Abs(a-b); Negate
; ($bfdb) Chapter 25: Credits                                         (37 bytes)
;               The first names or nicknames of those involved

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 1: Introduction
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; The Graphics Extension ROM
;
;   The Graphics Extension ROM (or 'GXR') provides new graphics primitives, sprite plotting and
; editing, fill patterns, dashed line patterns, and flood fill. It can also copy or move a
; rectangle of pixels on screen.
;
; The new graphics primitives are: filled rectangles, filled parallelograms, filled circles,
; circle outlines, arcs of a circle, sectors of a circle, segments of a circle, filled
; ellipses, and ellipse outlines.
;
; Sprite support includes a sprite editor to create sprites for any graphics MODE. A sprite
; can also be created by capturing a rectangle of pixels from the screen. Sprite plotting has
; the ability to draw a sprite at any pixel position on screen, clipped to the current graphics
; window.
;
; ***************************************************************************************

; ***************************************************************************************
;
; ROM Memory
;
; see pie.png
;
; ***************************************************************************************

; ***************************************************************************************
;
; History
;
;   The GXR was a project undertaken by Acornsoft's Languages department under Paul Fellows (who had
; previously written Sphinx Adventure, S-Pascal and others as a student at Cambridge). Having
; released Lisp, Forth, BCPL, ISO-Pascal (as 2 ROMs), Comal, Logo (2 ROMs), and Prolog, they were
; running out of interesting languages to implement, so they started releasing utilities, and they
; needed a new project.
;
; The BBC Micro's User Guide had used the phrase 'Reserved for the Graphics Extension ROM' and in
; finding that this only existed as far as some vague ideas for features, this inspired Paul Fellows
; to create such a ROM. Acorn (mostly David Seal) came up with a specification for the features, and
; Acornsoft (mostly Richard Manby) implemented it.
;
; Having implemented the ROM for the BBC Micro, the Master was getting close to release so it was
; decided to absorb the new graphics routines into 8K of the Master's 128K Mega-ROM, and hold off on
; the release of the BBC Micro GXR until the Master 128 was released.
;
; The GXR was officially launched at the Acorn User Show in 1985, for a price of £29.95 (equivalent
; to around £90 in 2023). The package came with the 16K ROM itself, a user manual, a reference card,
; a function key strip (for the included sprite editor), and a cassette tape with example programs,
; a fill pattern editor and a drawing program.
;
; A version for the B+ was also created with the same feature set. This supported the Shadow RAM
; architecture of the B+, meaning any reading or writing to the screen could not be done directly
; but had to be done by calling into OS routines.
;
; According to Paul Fellows, the GXR was a 'real hot seller' since it allowed BBC Micro users to get
; the same graphics features as the Master.
;
; Not all of the GXR features were added to the Master OS. In particular the sprite routines and
; editor are removed, and put onto a separate 'Spriter' Sideways RAM image supplied on the Master
; Welcome disc. The 16K Spriter sideways RAM image uses 9K for code leaving the remaining 7K
; available for storing sprites. Another cut was that the dot-dash line pattern feature is limited to
; exactly 8 pixels in length on the Master instead of any desired length between 1 and 64 pixels in
; the GXR.
;
; In 2020 the GXR was modified to work on the Electron by SteveF on the Stardot forum (aka
; ZornsLemma on GitHub).
;     see https://stardot.org.uk/forums/viewtopic.php?p=295211#p295211 and
;     see https://github.com/ZornsLemma/GXR
;
; To bring the history up to date, one place where GXR is still used today is the 'BBC Micro Bot'.
; This is a Twitter and Mastodon account created by Dominic Pajak that automatically replies to BBC
; BASIC code tweeted or posted to it with a video of it running. In the background it is executing
; the code in a BBC Micro emulator with the GXR enabled, capturing the output into a video and
; posting it. See https://www.bbcmicrobot.com
;
; Video
;   Much of the preceding history is derived from an excellent talk by Paul Fellows about his time
; at Acorn and beyond, see https://youtu.be/GLIcJrph2Zw . GXR related content starts at 22 minutes
; in with a brief memory map refresher.
;
; Advert
;     see https://www.4corn.co.uk/archive/docs/AMPAPP/150/APP063%20-%20The%20Graphics%20Extension%20ROM-opt.pdf
;
; ***************************************************************************************

; ***************************************************************************************
;
; Reviews
;
;   All reviews are generally positive in tone.
;
; Mark Webb, A&B Computing Aug 1985
;     see https://archive.org/details/AB_Computing_1985-08_OCR/page/n29/mode/2up
; Michael Banthorpe, Acorn User Dec 1985
;     see https://archive.org/details/AcornUser041-Dec85/page/n183/mode/2up
; Mark Sealey, Beebug Dec 1985
;     see https://www.computinghistory.org.uk/downloads/14565
;     (claimed "will also work on the Electron" which was untrue until 2020, see above)
; Jon Revis, Home Computing Weekly 8 Oct 1985
;     see https://archive.org/details/home-computing-weekly-133/page/n29/mode/2up
; Roger Cullis, Practical Computing Magazine Dec 1985
;     see http://chrisacorns.computinghistory.org.uk/docs/Mags/PC/PC_Dec85_BBCB+128.pdf
;
; ***************************************************************************************

; ***************************************************************************************
;
; Use in other packages
;
;   Take up of the GXR routines in other commercial software packages for the BBC Micro was limited.
; Since the GXR was not supplied as standard with the machine, the potential market would have been
; too small.
;
; Watford Electronics' 'ConQuest' graphics package and 'Wapping Editor' used the GXR routines for
; graphics primitives when available. Also the DDX CAD program from Ibbotsons Design Software, I
; think.
;
; No commercial games used it to my knowledge.
;
; ***************************************************************************************

; ***************************************************************************************
;
; Incompatibilities
;
;   The GXR was written in a compatible way, but some other badly behaved ROMs didn't claim the
; OSWRCH vector properly or misused *FX 163, requiring them to be in a lower priority ROM socket
; than the GXR. In particular:
;
;   * Computer Concepts Wordwise Plus
;   * Computer Concepts Graphics ROM
;   * Computer Concepts Printmaster
;   * Raven-20 (Shadow RAM board)
;
; and several other ROMs too, see https://archive.org/details/AcornUser039-Oct85/page/n115/mode/2up
;
; ***************************************************************************************

; ***************************************************************************************
;
; Alternatives
;
;   The most common alternative is the Computer Concepts Graphics ROM from 1983. It suffers from
; a non-standard less idiomatic interface and is a little buggier than the GXR in my (admittedly
; limited) experience. It uses *commands with the option of using the integer single letter BASIC
; variables to pass values. So e.g. "*ELLIPSE X%,Y%,..." rather than using additional PLOT types
; and VDU calls as the GXR does. Stargraph from Slogger also takes the "*ELLIPSE X%,Y%,..."
; approach.
;
; The New Advanced User Guide (see NAUG p295) when describing how to write a ROM takes an
; uncharacteristic dig at this:
;
;   "For example let us take a graphics extension ROM. This would be a service ROM because it
;   has to be initialised by using the unknown *command service call (or possibly by the boot
;   program call). However, the actual extension to the graphics commands would be performed
;   by intercepting the VDU extension vector. This would be directed at the ROM code using an
;   extended vector (see section 17.4.3). It would be foolish to call routines by the unknown
;   *command mechanism which then returned values to BASIC by poking into BASIC's single letter
;   integer variable storage space. This is because when a Tube is active the graphics routines
;   would corrupt the Tube routines in the language workspace. It is also foolish not to take
;   advantage of the elegant expansion capabilities which are provided."
;
;   * Computer Concepts Graphics ROM (1983)
;       see https://stardot.org.uk/forums/viewtopic.php?f=42&t=18614&p=258599
;       see https://stardot.org.uk/forums/viewtopic.php?t=18614
;   * Addcomm (Vine Micros, 1984), extending BBC BASIC
;       see https://archive.org/details/AB_Computing_1984-12_OCR/page/n87/mode/2up
;       see https://archive.org/details/AB_Computing_1985-12_OCR/page/n81/mode/2up
;       see https://archive.org/details/AcornUser027-Oct84/page/n157/mode/2up
;   * Stargraph (Slogger, 1985), (also compatible with the Electron)
;       see https://stardot.org.uk/forums/viewtopic.php?p=293889#p293889
;       see https://archive.org/details/AcornUser042-Jan86/page/n9/mode/2up
;       see https://stardot.org.uk/forums/download/file.php?id=39216&mode=view
;       see http://www.bygonebytes.co.uk/Slogger/Slogger%20Catalogue.pdf (page 16)
;
; ***************************************************************************************

; ***************************************************************************************
;
; Assembly Instructions
;
; This is for the acme assembler. Choose the machine to assemble the GXR for by defining the
; MACHINE constant via the acme command line, one of:
;
;   acme -DMACHINE=1000 -o gxr120.rom  gxr120_acme.a        ; for BBC B
;   acme -DMACHINE=1001 -o gxr200.rom  gxr120_acme.a        ; for BBC B+
;   acme -DMACHINE=1002 -o gxr100a.rom gxr120_acme.a        ; for Electron
;
; ***************************************************************************************

; ***************************************************************************************
;
; Implementation Notes
;
; * The VDU vector (OSWRCH) is redirected to detect VDU 22 (MODE) and VDU 25 (PLOT). On a MODE
;   change, the current fill patterns and dot-dash line pattern are reset to defaults.
;   (See .resetFillPatternsAndDotDashPattern) PLOT implements both the new graphics primitives
;   with new plot types, and reimplements the existing PLOT types to implement the new fill
;   patterns and dot-dash line patterns. (See .vdu22Or25EntryPoint).
;
; * The OS's Extended VDU Vectors system is used to support new VDU calls. The new VDU calls
;   are used to set options e.g. to set the dot-dash pattern or the fill pattern
;   (see .extendedVectorVDURoutine). The Extended VDU Vectors allow a specific ROM to be called
;   to process new VDU calls.
;
; * New star commands and new FX calls are handled by ROM service calls (which is the standard
;   practice).
;
; * Memory use:
;
;   Several zero page addresses are used to store temporary variables that are not preserved
;   between calls to the ROM:
;
;   The zero page addresses from $A8-AF are available for temporary storage of commonly used
;   variables.
;
;   The zero page locations that follow apply to the BBC B and B+, because some zero page
;   locations are different on the Electron version (see Chapter 3).
;
;   The locations $F8,$F9 are used to temporarily store the private workspace address
;   (these two locations are not used by OS 1.20 / 2.00).
;
;   The locations $DA-$DF are used as temporary variables (.vduTempStoreDA-DF). They are
;   only used by the OS for temporary VDU related storage.
;
;   A range of the VDU variables in page 3 ($0328 to $0345, see .vduWorkspaceA) are also
;   used as temporary storage during graphics operations.
;
;   Part of the soft character definitions normally stored at $0c00-$0c66 is copied into
;   private ROM workspace while a PLOT command is happening, then copied back at the end
;   of the PLOT operation.
;   This leaves $0c00 to $0c66 available for easy access (as fixed addresses) during PLOT
;   calculations.
;
;   The GXR claims private workspace on reset. It uses one page of private workspace for
;   general use, two more pages for use during flood fill (if enabled) and a variable
;   number of pages for sprites (*SSPACE n).
;
; * Calls directly into the OS:
;
;   As well as calling the OS via regular entry points, the GXR calls *directly* into OS code for
;   various functionality. e.g. plotting a horizontal row of pixels.
;
;   A different GXR ROM is therefore required for each version of the OS.
;   See the 'OS routines and tables' section below for a list of the OS routines used.
;
;   The BBC B and Electron versions read / write directly to screen memory for plotting lines,
;   flood fill, rectangle copy, plotting sprites, and creating a sprite from screen (*SGET n).
;   This is not possible in the B+ where shadow RAM can be used, so the ROM calls relevant
;   routines in the B+ ROM instead.
;
; * Sprites:
;
;   Sprites are stored (in memory and on disk) with a six byte header:
;
;       0: width - 1  (in *bytes*)
;       1: height - 1 (in pixels)
;       2: } size in bytes of the sprite data (without this six byte header)
;       3: }
;       4: MODE in which the sprite was defined
;       5: sprite number
;
;   ... the sprite bytes follow (the bytes are stored *right to left*, top to bottom)
;
;   It follows that sprites can be 1-255 bytes wide and 1-255 pixels high, limited only by
;   the memory available. No sprite mask facility is provided.
;
; ***************************************************************************************

; ***************************************************************************************
;
; Performance
;
;   There is a performance overhead to using the GXR for features that the BBC B OS could do on its
; own. General OSWRCH use is slowed down by around 2%. Triangle drawing is 33% slower, line drawing
; is 34% slower, point plotting is 83% slower, and MOVE commands are 100% slower. Bear in mind that
; the GXR adds the dot-dash pattern feature to line drawing and pattern fill to triangle drawing, so
; sometimes at least we do get something in return for this performance cost.
;
; See https://twitter.com/bbcmicrobot/status/1555265674812989441
;
; Some of the overhead (particularly for MOVE) is down to the caching and uncaching of 103 bytes of
; soft character definitions during each PLOT, which is unnecessary for a simple operation like
; MOVE. (See .vdu22Or25EntryPoint)
;
; Performance overall could be improved, e.g. by using zero page memory during expensive routines
; like multiply and sqrt. Available zero page memory is a limited resource that can be better used.
; Faster maths routines are also possible in general.
;
; To gain more ROM space, the sprite editor could be moved out of the ROM into a separate executable
; or ROM which would reclaim lots of useful space for new features or performance improvements. The
; HELP text is large and uncompressed, so there could be more ROM space to be saved there also
; (remove or compress it). Throughout the code I have noted a few micro-optimisations (see anything
; marked as "[NOTE: ...]") that would save memory.
;
; ***************************************************************************************

; ***************************************************************************************
;
; Bugs
;
;   1. Plotting this single large segment takes nearly 7 minutes to finish:
;
;         10 REM Requires GXR for BBC B or B+. Takes 6 mins 47 seconds!
;         20 MODE 0
;         30 MOVE 32768,512
;         40 MOVE 32767,32768
;         50 PLOT&AD,35000,-32767
;
;      Almost all the time is spent working out the end point's position on the circle.
;      The circle's radius is defined by the distance of the start point to the centre of the
;      circle. So far so good. But the end point can be any distance from the centre. So the code
;      for a segment plot needs to find the point along the end line that is at the radius of
;      the circle.
;
;      The code (see .segmentInitialisation and the .calculateEndPointOnCircle loop in particular)
;      moves one pixel at a time along the end line starting from the centre until the distance
;      from the centre is at least that of the circle's radius. So for a large radius circle
;      this is a lot of iterations, where expensive multiplications are used to calculate the radius
;      (squared) on each iteration.
;
;   2. In a similar case, but taken to extreme, the following code *never* finishes:
;
;         10 REM Requires GXR. Never finishes!
;         20 MODE 0
;         30 MOVE -32767,32767
;         40 MOVE 32767,-32767
;         50 PLOT&AD,-32767,-32767
;
;      Here the delta X is 65534 and delta Y is 65534. Radius squared is therefore
;
;         65534^2 + 65534^2 = 8589410312
;
;      which doesn't fit in the four byte value available in the code. Even if it did fit, the
;      radius is 92679, which wouldn't fit in the two byte radius variable in the code.
;
;   3. There's a bug in the 24 bit x 24 bit multiply routine that produces incorrect
;      results if an input has the top bit set. This may affect very large ellipses.
;
;   4. There are cases where flood fill doesn't work. If the pattern we are filling with
;      contains the background colour, the routine may finish early, or (as here) not even
;      fill anything:
;
;      See https://stardot.org.uk/forums/viewtopic.php?p=341717#p341717 :
;
;         10 S=200
;         20 MODE 1
;         30 VDU 29,640;512;
;         40 VDU 23,12,1,1,1,1,0,0,0,0
;         50 MOVE -S,0
;         60 DRAW 0,S
;         70 DRAW S,0
;         80 DRAW 0,-S
;         90 DRAW -S,0
;        100 GCOL 16,0
;        110 PLOT 133,0,0
;
;   5. GXR reports error number $85 for both "Can't open file" and "Not enough room" errors.
;      "Can't open file" should have error code $84.
;
; ***************************************************************************************

; ***************************************************************************************
;
; Possible future developments
;
;   * Compare with pre-release version 0.37
;   * Compare with Master code
;   * Track down the "dealer demonstration disc" as referenced in Mark Webb's review in A&B
;     Computing Aug 1985
;       (see https://archive.org/details/AB_Computing_1985-08_OCR/page/n29/mode/2up )
;       * it references an animated fountain
;       * shows and references Garfield "as seen in the demos"
;       * "apparently Acornsoft is swimming in discs with examples on"
;
;     Mark Sealey's review in Beebug Dec 1985 shows:
;       (see https://www.computinghistory.org.uk/downloads/14565 )
;       * an animated fountain screenshot
;       * clown screenshot (this is available on the Master Welcome Disc)
;       * GXR logo / box screenshot (also shown in Practical Computing Magazine Dec 1985)
;
; ***************************************************************************************

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 2: Constants
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Hardware
;
; The Electron version is courtesy of SteveF on the Stardot forum (aka ZornsLemma on GitHub).
;     see https://stardot.org.uk/forums/viewtopic.php?p=295211#p295211 and
;     see https://github.com/ZornsLemma/GXR
;
; ***************************************************************************************

!macro unknown_machine {
    !error "Unknown machine"
}

; Use these numbers on the acme command line with -D to define the MACHINE to assemble for.
BBC_B       = 1000
BBC_B_PLUS  = 1001
ELECTRON    = 1002

; Set version strings based on the machine we are assembling for.
!if MACHINE = BBC_B {
    .version     = "1.20"
    .fullVersion = "1.20"
} else if MACHINE = BBC_B_PLUS {
    .version     = "2.00"
    .fullVersion = "2.00"
} else if MACHINE = ELECTRON {
    .version     = "1.00"
    .fullVersion = "1.00a"
} else {
    +unknown_machine
}

; ***************************************************************************************
;
; Characters
;
; ***************************************************************************************
.charLF                                     = $0A       ;
.charCR                                     = $0D       ;
.charDefineTextColour                       = $11       ;
.charHomeCursor                             = $1E       ;
.charMoveCursor                             = $1F       ;

; ***************************************************************************************
;
; Offsets into the private workspace
;
; The GXR ROM uses the first page of its private workspace to store variables. These constants are
; offsets from the start of the ROM's private workspace.
;
; The first 72 bytes ($00-$47) contain the code for intercepting OSWRCH, checking for VDU 22 and
; VDU 25 and switching in the ROM and calling into it. The next 81 bytes ($48-$98) are for the
; variables listed below. The remaining 103 bytes ($99-$ff) are used to cache the 'soft character
; definitions' (from $0c00-$0c66) temporarily while a PLOT routine is executing. The soft character
; definitions are reinstated either at the end of the PLOT routine, or on a reset when the ROM
; re-initialises itself (checks for flag .workspaceOffsetHasCachedSoftCharacterDefinitions).
;
; ***************************************************************************************

.workspaceOffsetTotalPagesWithoutSprites    = $48       ; 1 or 3 pages, depending if *FLOOD is enabled
.workspaceOffsetOptions                     = $49       ; bit 7 = flood fill enabled, bit 6 = flood pending, bit 0=pen up/down in sprite editor
.workspaceOffsetSpritePages                 = $4a       ; number of pages reserved for sprites
.workspaceOffsetNumberOfSprites             = $4b       ;
.workspaceOffsetCurrentSpriteAddressLow     = $4c       ;
.workspaceOffsetCurrentSpriteAddressHigh    = $4d       ;
.workspaceOffsetSpriteStartPage             = $4e       ; the first page of the sprite data.
.workspaceOffsetSpriteEndPage               = $4f       ; the page after the sprite data.
.workspaceOffsetChosenSpriteAddressLow      = $50       ;
.workspaceOffsetChosenSpriteAddressHigh     = $51       ;
.workspaceOffsetChosenSpriteIndex           = $52       ;

; OSFILE parameter block (used when loading and saving sprite data)
.workspaceOffsetParamBlock                  = $53       ;
.workspaceOffsetFilenameLow                 = $53       ;
.workspaceOffsetFilenameHigh                = $54       ;
.workspaceOffsetLoadAddressLow              = $55       ;
.workspaceOffsetLoadAddressMid1             = $56       ;
.workspaceOffsetLoadAddressMid2             = $57       ;
.workspaceOffsetLoadAddressHigh             = $58       ;
.workspaceOffsetExecAddressLow              = $59       ;
.workspaceOffsetExecAddressMid1             = $5a       ;
.workspaceOffsetExecAddressMid2             = $5b       ;
.workspaceOffsetExecAddressHigh             = $5c       ;
.workspaceOffsetStartAddressLow             = $5d       ;
.workspaceOffsetStartAddressMid1            = $5e       ;
.workspaceOffsetStartAddressMid2            = $5f       ;
.workspaceOffsetStartAddressHigh            = $60       ;
.workspaceOffsetEndAddressLow               = $61       ;
.workspaceOffsetEndAddressMid1              = $62       ;
.workspaceOffsetEndAddressMid2              = $63       ;
.workspaceOffsetEndAddressHigh              = $64       ;
.workspaceOffsetEndOfSpritesAddressLow      = $65       ;
.workspaceOffsetEndOfSpritesAddressHigh     = $66       ;

.workspaceOffsetOldVDUVectorVLow            = $67       ; }
.workspaceOffsetOldVDUVectorVHigh           = $68       ; } old VDU Vector

.workspaceOffsetOldExtendedVDUVLow          = $69       ; }
.workspaceOffsetOldExtendedVDUVHigh         = $6a       ; } old extended vector
.workspaceOffsetOldExtendedVDUVROM          = $6b       ; } (see .swapWorkspaceWithVDUVectors)

.workspaceOffsetCurrentPatterns             = $6c       ; [32 bytes]

; The four patterns are stored at $6c to $8b (four patterns of 8 bytes each = 32 bytes)
;
; pattern 1         = workspace[$6c to $73]
; pattern 2         = workspace[$74 to $7b]
; pattern 3         = workspace[$7c to $83]
; pattern 4         = workspace[$84 to $8b]

.workspaceOffsetDotDashPattern              = $8c       ; dot-dash pattern [8 bytes]

.workspaceOffsetDotDashRepeatLength         = $94       ; pattern length in bits

; Dot-dash pattern state
.workspaceOffsetDotDashBitsRemaining        = $95       ; current remaining bits of pattern
.workspaceOffsetDotDashBit                  = $96       ; current bit within current byte
.workspaceOffsetDotDashPatternByte          = $97       ; current byte

.workspaceOffsetHasCachedSoftCharacterDefinitions = $98 ; set to $80 if soft character
                                                        ; definitions have been cached into
                                                        ; workspace, otherwise $00.
.workspaceOffsetSoftFontCache               = $99       ; copy of some soft character
                                                        ; definitions while PLOTting
                                                        ; [$67 bytes, i.e. to end of page]

; ***************************************************************************************
;
; Sprites are stored (in memory and on disk) with a six byte header
;
;   0: width - 1
;   1: height - 1
;   2: } size in bytes of the sprite data (without the six byte header)
;   3: }
;   4: MODE in which the sprite was defined
;   5: sprite number
;
; ***************************************************************************************

.spriteHeaderOffsetWidth                    = 0
.spriteHeaderOffsetHeight                   = 1
.spriteHeaderOffsetSizeInBytesLow           = 2
.spriteHeaderOffsetSizeInBytesHigh          = 3
.spriteHeaderOffsetModeNumber               = 4
.spriteHeaderOffsetSpriteNumber             = 5

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 3: Memory locations
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Zero page memory locations ($A8-$AF)
;
; These locations are available for ROMs to use while they are running, but are not preserved
; between calls.
;
; ***************************************************************************************
.tempNumberToPrintLow                       = $a8       ; }
.tempNumberToPrintHigh                      = $a9       ; } used when printing numbers
.tempNumberPrintedFlag                      = $aa       ; }

.gcolModeMask0                              = $a8       ;
.gcolModeMask1                              = $a9       ;
.gcolModeMask2                              = $aa       ;
.gcolModeMask3                              = $ab       ;

.currentSpriteDefinitionLow                 = $ac       ;
.currentSpriteDefinitionHigh                = $ad       ;
.seditCurrentSpriteByteLow                  = $ae       ;
.seditCurrentSpriteByteHigh                 = $af       ;

; ***************************************************************************************
;
; OS zero page memory locations
;
; These locations are owned by the OS. The GXR reads or writes them. Page 3 ($0300-$03ff) is
; where the VDU variables live: i.e. OS variables related to the graphics system.
; Locations $0328-$0349 (.vduWorkspaceA upwards) are used temporarily by the different
; graphics primitive routines.
;
; ***************************************************************************************
.vduCurrentPlotByteMask                     = $d1

    ; The Electron has a different arrangement of zero page VDU variables
    ; compared to the BBC machines:
    ;
    ;                                              BBC B/B+        Electron
    ; .vduCurrentPlotByteMask                        $d1             $d1
    ; .vduGraphicsColourByteOR                       $d4             $de
    ; .vduGraphicsColourByteEOR                      $d5             $df
    ; .vduScreenAddressOfGraphicsCursorCellLow       $d6             $d4
    ; .vduScreenAddressOfGraphicsCursorCellHigh      $d7             $d5
    ; .vduTempStoreDA                                $da             $d8
    ; .vduTempStoreDB                                $db             $d9
    ; .vduTempStoreDC                                $dc             $da
    ; .vduTempStoreDD                                $dd             $db
    ; .vduTempStoreDE                                $de             $dc
    ; .vduTempStoreDF                                $df             $dd
    ;
    ; Unfortunately Electron temporary locations $D8 and $D9 are used to hold
    ; .vduWriteCursorScreenAddress{Low,High} on the BBC B/B+. This means that although the ROM
    ; contains code to check if it's installed on an incompatible machine, in practice an
    ; Electron GXR ROM installed on a BBC B/B+ will cause glitches as it scribbles over $D8
    ; and $D9 and the OS writes to random addresses when it thinks it's writing to the
    ; screen. In practice this isn't a huge problem, and it seems best not to risk accidentally
    ; breaking things by trying to tweak the temporary use to avoid accessing $D8 or $D9 until
    ; after we've successfully checked we *are* running on an Electron.
!if (MACHINE = BBC_B) | (MACHINE = BBC_B_PLUS) {
    .vduGraphicsColourByteOR                    = $d4
    .vduGraphicsColourByteEOR                   = $d5
    .vduScreenAddressOfGraphicsCursorCellLow    = $d6       ; } address of the top of the cell
    .vduScreenAddressOfGraphicsCursorCellHigh   = $d7       ; } on screen containing the graphics
                                                            ; } cursor position
    .vduTempStoreDA                             = $da       ; } store for temporary values,
    .vduTempStoreDB                             = $db       ; } used in multiple VDU related
    .vduTempStoreDC                             = $dc       ; } functions.
    .vduTempStoreDD                             = $dd
    .vduTempStoreDE                             = $de
    .vduTempStoreDF                             = $df
} else if (MACHINE = ELECTRON) {
    .vduGraphicsColourByteOR                    = $de
    .vduGraphicsColourByteEOR                   = $df
    .vduScreenAddressOfGraphicsCursorCellLow    = $d4       ; } address of the top of the cell
    .vduScreenAddressOfGraphicsCursorCellHigh   = $d5       ; } on screen containing the graphics
                                                            ; } cursor position

    .vduTempStoreDA                             = $d8       ; } store for temporary values,
    .vduTempStoreDB                             = $d9       ; } used in multiple VDU related
    .vduTempStoreDC                             = $da       ; } functions.
    .vduTempStoreDD                             = $db
    .vduTempStoreDE                             = $dc
    .vduTempStoreDF                             = $dd
} else {
    +unknown_machine
}

.osbyteA                                    = $ef       ; }
.oswordA                                    = $ef       ; } stores register values when

.osbyteX                                    = $f0       ; } calling .OSBYTE and OSWORD
.oswordX                                    = $f0       ; }

.osbyteY                                    = $f1       ; } stores register values when
.oswordY                                    = $f1       ; } calling .OSBYTE and OSWORD

.stringInputBufferAddressLow                = $f2       ; } Start address of input string
.stringInputBufferAddressHigh               = $f3       ; }

.currentlySelectedROM                       = $f4       ; current paged ROM selected

.privateWorkspaceLow                        = $f8       ; (OS does not use this location)
.privateWorkspaceHigh                       = $f9       ; (OS does not use this location)

.escapeFlag                                 = $ff       ; the ESCAPE flag
                                                        ; this is set when an ESCAPE character
                                                        ; (normally .charESCAPE) is entered
                                                        ; into an input buffer.
                                                        ; it should be acknowledged using
                                                        ; .OSBYTE 126. This tells the second
                                                        ; processor of the event and clears
                                                        ; the flag.

.page1Start                                 = $0100     ; page 1 is used for reporting errors

.vectorWRCHVLow                             = $020e     ; OSWRCH vector
.vectorWRCHVHigh                            = $020f     ; OSWRCH vector

.vectorVDUVLow                              = $0226     ; unrecognised PLOT / VDU 23 commands
.vectorVDUVHigh                             = $0227     ; unrecognised PLOT / VDU 23 commands

.lastResetType                              = $028d     ; what type of reset was last done?
                                                        ;        0    Soft reset (BREAK)
                                                        ;        1    Power on
                                                        ;        2    Hard reset (CTRL-BREAK)

; ***************************************************************************************
;
; Page Three
;
; ***************************************************************************************
.vduVariablesStart                          = $0300     ;

.vduGraphicsWindowPixelsLeftLow             = $0300     ; }
.vduGraphicsWindowPixelsLeftHigh            = $0301     ; }
.vduGraphicsWindowPixelsBottomLow           = $0302     ; }
.vduGraphicsWindowPixelsBottomHigh          = $0303     ; }
.vduGraphicsWindowPixelsRightLow            = $0304     ; } graphics window in pixels
.vduGraphicsWindowPixelsRightHigh           = $0305     ; }
.vduGraphicsWindowPixelsTopLow              = $0306     ; }
.vduGraphicsWindowPixelsTopHigh             = $0307     ; }

.vduOldGraphicsCursorPixelsXLow             = $0314     ; }
.vduOldGraphicsCursorPixelsXHigh            = $0315     ; } old graphics cursor in pixels
.vduOldGraphicsCursorPixelsYLow             = $0316     ; }
.vduOldGraphicsCursorPixelsYHigh            = $0317     ; }

.vduGraphicsCursorVerticalOffsetInCell      = $031A     ; offset within a character cell of
                                                        ; the current graphics cursor Y
                                                        ; coordinate

.vdu23NParameter                            = .vduQueueEndByte - 7  ; VDU 23,N
.vdu23SChooseOrSGetSpriteNumberParameter    = .vduQueueEndByte - 6  ; VDU 23,27,N

.vdu25ParameterPlotType                     = .vduQueueEndByte - 4
.vdu25ParameterXLow                         = .vduQueueEndByte - 3
.vdu25ParameterXHigh                        = .vduQueueEndByte - 2
.vdu25ParameterYLow                         = .vduQueueEndByte - 1
.vdu25ParameterYHigh                        = .vduQueueEndByte

.vduQueueEndByte                            = $0323     ; } nine bytes for vdu queue (end)

.vduGraphicsCursorPixelsXLow                = $0324     ; current graphics cursor position in
.vduGraphicsCursorPixelsXHigh               = $0325     ; pixels
.vduGraphicsCursorPixelsYLow                = $0326     ;
.vduGraphicsCursorPixelsYHigh               = $0327     ;

; ***************************************************************************************
; VDU variables used by the GXR ROM for general workspace use when plotting or sprite editing.
; We give more helpful names to these workspace variables for specific routines.
.vduWorkspaceA                              = $0328     ;
.vduWorkspaceB                              = $0329     ;
.vduWorkspaceC                              = $032A     ;
.vduWorkspaceD                              = $032B     ;
.vduWorkspaceE                              = $032C     ;
.vduWorkspaceF                              = $032D     ;
.vduWorkspaceG                              = $032E     ;
.vduWorkspaceH                              = $032F     ;
.vduWorkspaceI                              = $0330     ;
.vduWorkspaceJ                              = $0331     ;
.vduWorkspaceK                              = $0332     ;
.vduWorkspaceL                              = $0333     ;
.vduWorkspaceM                              = $0334     ;
.vduWorkspaceN                              = $0335     ;
.vduWorkspaceO                              = $0336     ;
.vduWorkspaceP                              = $0337     ;
.vduWorkspaceQ                              = $0338     ;
.vduWorkspaceR                              = $0339     ;
.vduWorkspaceS                              = $033A     ;
.vduWorkspaceT                              = $033B     ;
.vduWorkspaceU                              = $033C     ;
.vduWorkspaceV                              = $033D     ;
.vduWorkspaceW                              = $033E     ;
.vduWorkspaceX                              = $033F     ;
.vduWorkspaceY                              = $0340     ;
.vduWorkspaceZ                              = $0341     ;
.vduWorkspaceAA                             = $0342     ;
.vduWorkspaceBB                             = $0343     ;
.vduWorkspaceCC                             = $0344     ;
.vduWorkspaceDD                             = $0345     ;

; ***** Line drawing/tracking variables *****
.line1StartPointX                           = $0328     ; initial and current point X [2 bytes]
.line1StartPointY                           = $032a     ; initial and current point Y [2 bytes]
.line1AbsDeltaX                             = $032c     ; abs(deltaX)                 [2 bytes]
.line1AbsDeltaY                             = $032e     ; abs(deltaY)                 [2 bytes]
.line1ErrorTerm                             = $0330     ; Bresenham error term        [2 bytes]
.line1Signs                                 = $0332     ; signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

.line2StartPointX                           = $0334     ; initial and current point X [2 bytes]
.line2StartPointY                           = $0336     ; initial and current point Y [2 bytes]
.line2AbsDeltaX                             = $0338     ; abs(deltaX)                 [2 bytes]
.line2AbsDeltaY                             = $033a     ; abs(deltaY)                 [2 bytes]
.line2ErrorTerm                             = $033c     ; Bresenham error term        [2 bytes]
.line2Signs                                 = $033e     ; signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

.line3StartPointX                           = $033f     ; initial and current point X [2 bytes]
.line3StartPointY                           = $0341     ; initial and current point Y [2 bytes]
.line3AbsDeltaX                             = $0343     ; abs(deltaX)                 [2 bytes]
.line3AbsDeltaY                             = $0345     ; abs(deltaY)                 [2 bytes]
.line3ErrorTerm                             = $0347     ; Bresenham error term        [2 bytes]
.line3Signs                                 = $0349     ; signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

; ***** Triangle drawing variables *****
.triangleRowLeftPointX                      = $032c     ; }
.triangleRowLeftPointY                      = $032e     ; } the current row has a leftmost
.triangleRowRightPointX                     = $0330     ; } and rightmost pixel to fill
.triangleRowRightPointY                     = $0332     ; }

; ***** Circle drawing variables *****
.circlePointLeftXLow                        = $032c     ; }
.circlePointLeftXHigh                       = $032d     ; }
.circlePointLeftYLow                        = $032e     ; }
.circlePointLeftYHigh                       = $032f     ; } the current row has a leftmost
.circlePointRightXLow                       = $0330     ; } and a rightmost point to fill
.circlePointRightXHigh                      = $0331     ; }
.circlePointRightYLow                       = $0332     ; }
.circlePointRightYHigh                      = $0333     ; }

; ***** Move/copy rectangle variables *****
.rectSourceLeft                             = $0328     ; left   edge of src rect [2 bytes]
.rectSourceBottom                           = $032a     ; bottom edge of src rect [2 bytes]
.rectSourceRight                            = $032c     ; right  edge of src rect [2 bytes]
.rectSourceTop                              = $032e     ; top    edge of src rect [2 bytes]

.rectDestinationLeft                        = $0334     ; left   edge of dest rect [2 bytes]
.rectDestinationBottom                      = $0336     ; bottom edge of dest rect [2 bytes]
.rectDestinationRight                       = $0338     ; right  edge of dest rect [2 bytes]
.rectDestinationTop                         = $033a     ; top    edge of dest rect [2 bytes]

.rectCopyShiftToNextByte                    = $0342     ;
.rectCopyNumberOfTimesToShiftByte           = $0343     ; number of times to shift right each byte when copying/moving
.rectCopyByteWidth                          = $0344     ; width in bytes of area to copy / move
.rectCopyPlotType                           = $0345     ;
.rectCopyByteMask                           = $0346     ; byte mask for writing the initial/final byte of a row
.rectCopyShiftingLeftFlag                   = $0347     ; top bit set means we are shifting pixels left within each byte

; ***** Sprite editing variables *****
.seditCurrentVisibleX                       = $033C     ; X offset within the visible area
                                                        ; of the current cursor
.seditCurrentVisibleY                       = $033D     ; Y offset within visible area of
                                                        ; the current cursor
.seditCurrentVisibleByteMask                = $033E     ; a bitmask for the current pixel
                                                        ; within the current sprite byte
.seditCurrentX                              = $033F     ; left pixel coordinate of large sprite
.seditCurrentSpriteVisibleWidth             = $0340     ; width of visible area of sprite (in sprite pixels)
.seditCurrentY                              = $0341     ; bottom pixel coordinate of large sprite
.seditCurrentSpriteVisibleHeight            = $0342     ; height of visible area of sprite (in sprite pixels)
.seditScreenXOffsetWithinCurrentByte        = $0343     ; Screen X offset within the current
                                                        ; sprite byte scaled up to screen
                                                        ; coordinates for the large sprite.
                                                        ; (in increments of '.seditXCoordinateIncrement')

.plotPointXLow                              = $0344     ; }
.plotPointXHigh                             = $0345     ; } screen coordinates when PLOTting
.plotPointYLow                              = $0346     ; } (e.g. in the sprite editor)
.plotPointYHigh                             = $0347     ; }

.seditBackgroundColour                      = $0348     ;

; ***** Ellipse variables *****
.ellipse256AspectRatioLow                   = $0328     ;
.ellipse256AspectRatioMid                   = $0329     ; 256 * (height / centre row width)
.ellipse256AspectRatioHigh                  = $032a     ;

.ellipse256ShearLow                         = $032b     ;
.ellipse256ShearMid                         = $032c     ; 256 * abs(top X - centre X)
.ellipse256ShearHigh                        = $032d     ;

.ellipseHalfHeightCounterLow                = $032e     ; half the height of the ellipse
.ellipseHalfHeightCounterHigh               = $032f     ;

.ellipseHalfHeightSquaredLow                = $0330     ;
.ellipseHalfHeightSquaredMid1               = $0331     ; (half the height) squared
.ellipseHalfHeightSquaredMid2               = $0332     ;
.ellipseHalfHeightSquaredHigh               = $0333     ;

.ellipsePointCLow                           = $0334     ;
.ellipsePointCHigh                          = $0335     ;
.ellipsePointDLow                           = $0336     ;
.ellipsePointDHigh                          = $0337     ;

.ellipseLeftPointLow                        = $0338     ;
.ellipseLeftPointHigh                       = $0339     ;

.ellipseRightPointLow                       = $033a     ;
.ellipseRightPointHigh                      = $033b     ;

.ellipsePointALow                           = $033c     ;
.ellipsePointAHigh                          = $033d     ;
.ellipsePointBLow                           = $033e     ;
.ellipsePointBHigh                          = $033f     ;

.ellipsePointELow                           = $0340     ;
.ellipsePointEHigh                          = $0341     ;

.ellipseCurrentOffsetXLow                   = $0342     ;
.ellipseCurrentOffsetXHigh                  = $0343     ;

.ellipsePointFLow                           = $0344     ;
.ellipsePointFHigh                          = $0345     ;


; ***************************************************************************************
;
; Regular OS variables
;
; ***************************************************************************************
.vduBytesPerCharacterRowLow                 = $0352     ;
.vduBytesPerCharacterRowHigh                = $0353     ;
.vduScreenSizeHighByte                      = $0354     ;
.vduCurrentScreenMODE                       = $0355     ;

.vduForegroundGraphicsColour                = $0359     ; } byte the given colour
.vduBackgroundGraphicsColour                = $035A     ; }
.vduForegroundGCOLMode                      = $035B     ; GCOL foreground mode
                                                        ; (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)
.vduBackgroundGCOLMode                      = $035C     ; GCOL background mode
                                                        ; (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)
.vduJumpVectorLow                           = $035D     ;
.vduJumpVectorHigh                          = $035E     ;

.vduNumberOfLogicalColoursMinusOne          = $0360     ;
.vduPixelsPerByteMinusOne                   = $0361     ;

.vduColourMaskLeft                          = $0362     ; colour mask left.  Bits for the
                                                        ; setting the leftmost pixel of a
                                                        ; byte to white:
                                                        ; MODE 0,3,4,6,7    = $80
                                                        ; MODE 1,5          = $88
                                                        ; MODE 2            = $AA
.vduColourMaskRight                         = $0363     ; colour mask right. Bits for the
                                                        ; setting the rightmost pixel of a
                                                        ; byte to white:
                                                        ; MODE 0,3,4,6,7    = $01
                                                        ; MODE 1,5          = $11
                                                        ; MODE 2            = $55


; ***************************************************************************************
;
; GXR workspace at $0c00-$0c66
;
; Page C normally holds soft character definitions for chars 224-255 but for the duration of
; a PLOT command the range $0c00-$0c66 is cached in private workspace. Thus we can use the
; start of page C as workspace, detailed below.
;
; ***************************************************************************************
.softCharacterDefinitions                   = $0c00     ;
.fillPattern                                = $0c00     ; current fill pattern [8 bytes]
.currentDotDashPattern                      = $0c08     ; current dot-dash pattern [8 bytes]

.currentDotDashPatternBitLength             = $0c10

; Temporary current dot-dash line state [3 bytes]
.currentDotDashPatternNumBitsRemaining      = $0c11
.currentDotDashPatternBitMask               = $0c12
.currentDotDashPatternByte                  = $0c13

.gxrScratchspace1                           = $0c14
.gxrScratchspace2                           = $0c15
.gxrScratchspace3                           = $0c16

; $0c17 onwards holds temporary variables that are not remembered between calls to the ROM.
; They are used for multiple purposes, so have different names with the same addresses.
.gxrCurrentPattern                          = $0c17     ; current fill pattern [8 bytes]
.rectCopyRowCache                           = $0c17     ; the current row data stored during
                                                        ; a rectangle copy ($0c17-$0c66)
                                                        ; [80 bytes]

; General purpose temporary variables e.g. Used when sorting vertices for triangle or parallelogram
.gxrTemp1                                   = $0c17
.gxrTemp2                                   = $0c18
.gxrTemp3                                   = $0c19
.gxrTemp4                                   = $0c1a
.gxrTemp5                                   = $0c1b
.gxrTemp6                                   = $0c1c
.gxrTemp7                                   = $0c1d

; ***** For multiply *****
.multiplicand0                              = $0c17
.multiplicand1                              = $0c18
.multiplicand2                              = $0c19

.multiplier0                                = $0c1a
.multiplier1                                = $0c1b
.multiplier2                                = $0c1c

.product0                                   = $0c1a
.product1                                   = $0c1b
.product2                                   = $0c1c
.product3                                   = $0c1d
.product4                                   = $0c1e
.product5                                   = $0c1f

; ***** For square root *****
.sqrtResult0                                = $0c17
.sqrtResult1                                = $0c18
.sqrtResult2                                = $0c19

.sqrtNumber0                                = $0c1a     ; }
.sqrtNumber1                                = $0c1b     ; }
.sqrtNumber2                                = $0c1c     ; } 48 bit number to sqrt
.sqrtNumber3                                = $0c1d     ; }
.sqrtNumber4                                = $0c1e     ; }
.sqrtNumber5                                = $0c1f     ; }

.sqrtRemainder0                             = $0c20
.sqrtRemainder1                             = $0c21
.sqrtRemainder2                             = $0c22
.sqrtRemainder3                             = $0c23

.sqrtTemp0                                  = $0c24
.sqrtTemp1                                  = $0c25
.sqrtTemp2                                  = $0c26
.sqrtTemp3                                  = $0c27

; $0c28-$0c2b [4 bytes] are not used

; ***** For division *****
.dividend0                                  = $0c2c
.dividend1                                  = $0c2d
.dividend2                                  = $0c2e

.divisor0                                   = $0c2f
.divisor1                                   = $0c30
.divisor2                                   = $0c31

.quotient0                                  = $0c32     ; 24 bit quotient for divide
.quotient1                                  = $0c33     ; 24 bit quotient for divide
.quotient2                                  = $0c34     ; 24 bit quotient for divide

.divideTemp0                                = $0c35     ; temporary value during divide
.divideTemp1                                = $0c36     ;
.divideTemp2                                = $0c37     ;

; ***** For circle drawing *****
.circleTrackingLeftmostChordPoint           = $0c2c     ; index of the leftmost chord
                                                        ; point, or zero if we are not
                                                        ; tracking the chord
.circleTrackingSecondLineInQuadrant         = $0c2d     ; index of the second line in the
                                                        ; quadrant, or zero if we are not
                                                        ; tracking
.circleRadialLine                           = $0c2e     ; another temporary line index
.circleTrackingRightmostChordPoint          = $0c2f     ; index of the rightmost chord
                                                        ; point, or zero if we are not
                                                        ; tracking the chord

.circlePointXLow                            = $0c30     ;
.circlePointXHigh                           = $0c31     ;

.circlePointYLow                            = $0c32     ;
.circlePointYHigh                           = $0c33     ;
.circleFillRowFlag                          = $0c34     ; set if we are on a new row to be plotted, clear if just updating position this time around the loop
.circlePixelShapeCurrentOffset              = $0c35     ; tracks offset within current pixel shape when drawing circle (for double width / height)


.circlePixelShapeForCurrentMODE             = $0c36     ; pixel shape:
                                                        ;   bit 0 set = double width (MODE 2,5)
                                                        ;   bit 1 set = half width   (MODE 0)

.circleSlopeTestLow                         = $0c37     ;
.circleSlopeTestMid1                        = $0c38     ;
.circleSlopeTestMid2                        = $0c39     ;
.circleSlopeTestHigh                        = $0c3a     ;

.circleRadiusSquaredLow                     = $0c37     ;
.circleRadiusSquaredMid1                    = $0c38     ;
.circleRadiusSquaredMid2                    = $0c39     ;
.circleRadiusSquaredHigh                    = $0c3a     ;

.circleDiameterCountdownLow                 = $0c3d     ; } counts down from (diameter-1) in steps of two
.circleDiameterCountdownHigh                = $0c3e     ; }

.circleDecisionLow                          = $0c3f     ; } decision variable used in circle algorithm
.circleDecisionHigh                         = $0c40     ; }

.circleCountOddNumbersLow                   = $0c41     ; } counts up from one in steps of two
.circleCountOddNumbersHigh                  = $0c42     ; }

.circleChordLine                            = $0c43     ; offset of chord line variables from .vduVariablesStart

.circleLine2Quadrant                        = $0c48
.circleLine3Quadrant                        = $0c49
.circleChordDestinationPoint                = $0c4a     ; end point of chord line
.circleQuadrants                            = $0c4b     ; [4 bytes] See .circleDoLineAndQuadrantInitialisation
.circleSecondaryLine                        = $0c4f     ; if one line is in the quadrant, this is the other line that may not be in the quadrant
.circleCurrentQuadrant                      = $0c50     ; current quadrant
.circleQuadrantDataShifter                  = $0c51     ; how many times to shift the quadrant data when starting to track the chord
.circleFlag                                 = $0c52

; ***** For ellipse drawing *****
.ellipseSignFlag                            = $0c38     ; sign for shear

.ellipseAccumulatedShearLow                 = $0c39     ; adds the shear value each row.
.ellipseAccumulatedShearMid                 = $0c3a     ;
.ellipseAccumulatedShearHigh                = $0c3b     ;

.ellipseCountOddNumbersLow                  = $0c3c     ; counts the odd numbers from 1
.ellipseCountOddNumbersMid1                 = $0c3d     ;
.ellipseCountOddNumbersMid2                 = $0c3e     ;
.ellipseCountOddNumbersHigh                 = $0c3f     ;

.ellipseCountSquaresLow                     = $0c40     ; counts up in square numbers by
.ellipseCountSquaresMid1                    = $0c41     ; adding next the odd number in
.ellipseCountSquaresMid2                    = $0c42     ; sequence from 1.
.ellipseCountSquaresHigh                    = $0c43     ;

.ellipseCountHeightLow                      = $0c44     ; loop counter
.ellipseCountHeightHigh                     = $0c45     ;

.ellipseTempA                               = $0c44     ; }
.ellipseTempB                               = $0c45     ; } temporary variables while drawing
.ellipseTempY                               = $0c46     ; } ellipse
.ellipseTempX                               = $0c47     ; }

; ***************************************************************************************
;
; Extended Vector Table
;
; To redirect the VDU vector to this GXR ROM we use the extended vector table (See NAUG p312)
;
; ***************************************************************************************
.extendedVDUVLow                            = $0dd8     ; }
.extendedVDUVHigh                           = $0dd9     ; } Extended vector table
.extendedVDUVROM                            = $0dda     ; }

; This memory is a table indexed by ROM number. Each ROM gets one byte to store information.
; We usually store the page number of the private workspace. During a reset, it stores 1
; to indicate the GXR is becoming active, or 0 for inactive.
.romWorkspaceBytes                          = $0df0     ; ROM workspace bytes

; ***************************************************************************************
;
; OS routines and tables
;
; This ROM calls directly into the OS to perform functions, and also reads OS ROM based
; tables. Each machine has a different set of addresses.
;
; ***************************************************************************************
!if (MACHINE = BBC_B) {
    .sixteenColourMODEMaskTable                         = $c407
    .gcolPlotOptionsTable                               = $c41c
    .twoColourMODEParameterTable                        = $c424
    .vdu22EntryPoint                                    = $c8eb
    .vdu25EntryPoint                                    = $c98c

    ; OS routine to swap two bytes in VDU variables (e.g. one 16 bit coordinate)
    ; On Entry:
    ;       X is the offset to the first variable
    ;       Y is the offset to the second variable
    .exchangeTwoVDUBytes                                = $cdde

    ; OS routine to plot a single point
    ; Given the current screen address details, renders the pixel by writing to the screen
    ; address, applying the colour masks and plot type.
    ; On Entry:
    ;       Y is the vertical offset within the current cell
    .plotPointWithinBoundsAtY                           = $d0f3

    ; OS routine to check that the graphics point given by offset X is within the graphics window
    ; On Entry:
    ;   X: offset to the point to check ('gpoint')
    ; On Exit:
    ;   .vduTempStoreDA is zero if the gpoint is within the graphics window, or the four low bits
    ;                indicate which regions failed:
    ;
    ;       %0000   success (gpoint is within window)
    ;       %0001   gpoint X is left of  the left   edge of the graphics window
    ;       %0010   gpoint X is right of the right  edge of the graphics window
    ;       %0100   gpoint Y is below    the bottom edge of the graphics window
    ;       %1000   gpoint Y is above    the top    edge of the graphics window
    .checkPointXIsWithinGraphicsWindow                  = $d10f

    ; OS routine to check coordinate of a point is in the window bounds (horizontal or vertical)
    ; On Entry:
    ;       X is the offset to the coordinate to check minus two bytes
    ;       Y is the offset to the second variable to check (0 for horizontal or 2 for vertical)
    ; On Exit:
    ;       .vduTempStoreDA is the error code (0 = no error, 1 = first check failed, 2 = second check
    ;       failed)
    ;       Zero flag set if no error
    .checkPointIsWithinWindowHorizontalOrVertical       = $d128

    ; OS routine to convert external relative coordinates to pixels
    ; Convert pair of external coordinates to pixels (horizontal and vertical)
    ; On Entry:
    ;       X is the offset in vdu variables to the coordinate to convert
    .plotConvertExternalRelativeCoordinatesToPixels     = $d14d

    ; Move graphics cursor up a cell
    .moveGraphicsCursorAddressUpOneCharacterCell        = $d3d3

    ; OS routine to update the mask value, and move graphics cursor address on to next cell to the right
    ; On Entry:
    ;       Carry always SET
    .moveGraphicsCursorAddressTotheRightAndUpdateMask   = $d3ed

    ; OS routine to move the graphics cursor address on to next cell to the right
    ; On Entry:
    ;       Carry always SET
    .moveGraphicsCursorAddressTotheRight                = $d3f2

    ; OS routine to update the mask value, and move graphics cursor address on to previous cell to the left
    ; On Entry:
    ;       Carry always SET
    .moveGraphicsCursorAddressTotheLeftAndUpdateMask    = $d3fd

    ; OS routine to copy eight bytes (four coordinates) of VDU variables
    ; On Entry:
    ;       X = source (offset from .vduVariablesStart)
    ;       Y = destination (offset from .vduVariablesStart)
    .copyEightBytesWithinVDUVariables                   = $d47c

    ; OS routine to copy two bytes (one coordinate) of VDU variables
    ; On Entry:
    ;       X = source (offset from .vduVariablesStart)
    ;       Y = destination (offset from .vduVariablesStart)
    .copyTwoBytesWithinVDUVariables                     = $d482

    ; OS routine to copy four bytes of VDU variables
    ; On Entry:
    ;       X = source (offset from .vduVariablesStart)
    ;       Y = destination (offset from .vduVariablesStart)
    .copyFourBytesWithinVDUVariables                    = $d48a

    ; OS routine to fill a single horizontal row of pixels
    ; Used as part of clearing the graphics window or filling a triangle.
    ; On Entry:
    ;       X = offset into VDU variables for one extreme graphics pixel X coordinate
    ;       Y = offset into VDU variables for the other extreme graphics pixel X coordinate
    .fillRow                                            = $d6a6

    ; OS routine to set screen address
    ; On Entry:
    ;       X is the vdu variables offset to the graphics point to check
    ; On Exit:
    ;       .vduScreenAddressOfGraphicsCursorCellLow/High is the screen address
    ;       Y is the vertical offset within the character cell (0-7)
    ;       Preserves X
    .setScreenAddress                                   = $d864
} else if (MACHINE = BBC_B_PLUS) {
    .sixteenColourMODEMaskTable                         = $c3fe
    .gcolPlotOptionsTable                               = $c413
    .twoColourMODEParameterTable                        = $c41b
    .vdu25EntryPoint                                    = $c939
    .vdu22EntryPoint                                    = $caee
    .exchangeTwoVDUBytes                                = $cda6
    .plotPointWithinBoundsAtY                           = $d0bf
    .checkPointXIsWithinGraphicsWindow                  = $ca79
    .checkPointIsWithinWindowHorizontalOrVertical       = $d0d9
    .plotConvertExternalRelativeCoordinatesToPixels     = $d0fe
    .moveGraphicsCursorAddressUpOneCharacterCell        = $d34b
    .moveGraphicsCursorAddressTotheRightAndUpdateMask   = $d365
    .moveGraphicsCursorAddressTotheRight                = $d36a
    .moveGraphicsCursorAddressTotheLeftAndUpdateMask    = $d375
    .copyEightBytesWithinVDUVariables                   = $d3f4
    .copyTwoBytesWithinVDUVariables                     = $d3fb
    .copyFourBytesWithinVDUVariables                    = $d403
    .fillRow                                            = $d62e
    .setScreenAddress                                   = $d7ed

    ; For the B+ we need to execute LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y
    ;                           and STA (.vduScreenAddressOfGraphicsCursorCellLow),Y
    ; from within the OS address space in order to access main or shadow RAM as appropriate.
    ; There isn't a bare LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y:RTS we can use, so
    ; we do the best we can, which requires a bit of fiddling around in the GXR code compared
    ; to the model B case.
    .plotFast                                           = $d0cd ; write byte to screen
    .plotByte                                           = $d0d0 ; write byte to screen with GCOL mode
    .checkPixelIsBackgroundColourFast                   = $d427 ; read byte from screen

    ; For reference, here is the relevant code from the B+ OS ROM:
    ;
    ;       .plotFast
    ; d0cd      STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; put it back again
    ; d0cf      RTS                                                 ;
    ;
    ;       .plotByte
    ; d0d0      LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    ; d0d2      ORA .vduGraphicsColourByteOR                        ;
    ; d0d4      EOR .vduGraphicsColourByteEOR                       ;
    ; d0d6      STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    ; d0d8      RTS                                                 ;
    ; ...
    ;       .checkPixelIsBackgroundColourFast
    ; d427      LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; get byte from current graphics
    ; d429      EOR .vduBackgroundGraphicsColour                    ; cell, compare with current
    ; d42c      STA .vduTempStoreDA                                 ; background colour and store it
    ; d42e      RTS                                                 ;

} else if (MACHINE = ELECTRON) {
    .sixteenColourMODEMaskTable                         = $c3c2
    .gcolPlotOptionsTable                               = $c3d7
    .twoColourMODEParameterTable                        = $c3df
    .vdu25EntryPoint                                    = $c986
    .vdu22EntryPoint                                    = $c8ec
    .exchangeTwoVDUBytes                                = $cd1a
    .plotPointWithinBoundsAtY                           = $d004
    .checkPointXIsWithinGraphicsWindow                  = $d020
    .checkPointIsWithinWindowHorizontalOrVertical       = $d039
    .plotConvertExternalRelativeCoordinatesToPixels     = $d05e
    .moveGraphicsCursorAddressUpOneCharacterCell        = $d2ea
    .moveGraphicsCursorAddressTotheRightAndUpdateMask   = $d304
    .moveGraphicsCursorAddressTotheRight                = $d309
    .moveGraphicsCursorAddressTotheLeftAndUpdateMask    = $d314
    .copyEightBytesWithinVDUVariables                   = $d393
    .copyTwoBytesWithinVDUVariables                     = $d399
    .copyFourBytesWithinVDUVariables                    = $d3a1
    .fillRow                                            = $d5bc
    .setScreenAddress                                   = $d77a
    .selectRom                                          = $e3a0
} else {
    +unknown_machine
}

; ***************************************************************************************
.romSelectRegister                          = $fe30

; ***************************************************************************************
.extendedVectorTableVDUV                    = $ff39

; ***************************************************************************************
;
; Regular OS entry points
;
; ***************************************************************************************
.OSFIND                                     = $ffce
.OSBGET                                     = $ffd7
.OSARGS                                     = $ffda
.OSFILE                                     = $ffdd
.OSRDCH                                     = $ffe0
.OSNEWL                                     = $ffe7
.OSWRCH                                     = $ffee
.OSBYTE                                     = $fff4

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 4: ROM header and service entry routines
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; ROM header
;
; Every Sideways ROM requires a header (including a copyright string) in order to be identified
; as a ROM. The 'ROM type' byte indicates the type of ROM: we are a service ROM (not a language
; ROM) with a service entry point and it is written in 6502.
;
; ***************************************************************************************
* = $8000
    !text "RCM"                                         ; normally a language entry point,
                                                        ; ('JMP address') but this is not a
                                                        ; language ROM so these bytes are
                                                        ; unused. 'RCM' is probably the
                                                        ; initials of Richard Manby who wrote
                                                        ; most of this code.

    JMP .serviceEntryRoutine                            ; service entry point

    !byte $82                                           ; ROM type byte:
                                                        ;   $82 means it's not a language ROM,
                                                        ;   has a service entry point,
                                                        ;   and is 6502 code (not BASIC)

    !byte .copyrightString - 1 - $8000                  ; offset to copyright string (-1)

    !byte $01                                           ; binary version number

.titleString
    !text "Graphics Extension ROM ",.fullVersion,.charLF,.charCR
    !byte 0                                             ; terminator

    ; (no version string)

.copyrightString
    !text "(C)1985 Acornsoft"                           ; copyright string
    !byte 0                                             ; terminator

; ***************************************************************************************
;
; ROM service entry routine
;
; ROMs with a service entry point (as indicated by the ROM type byte in the ROM header) receive
; calls from the OS. The service call type is passed in the accumulator. If the ROM handles the
; call, it returns with A=0. If the service call is not handled, the accumulator must be returned
; unchanged.
;
; The GXR handles four of the service calls, as shown below.
;
; ***************************************************************************************
.serviceEntryRoutine
    ; Check for service call to claim private workspace
    CMP #2                                              ; relative private workspace claim?
    BEQ .serviceRelativePrivateWorkspaceClaim           ; branch if so

    ; Check for service call indicating an unknown OSBYTE (*FX) call
    CMP #7                                              ; unrecognised OSBYTE call?
    BNE +                                               ; if (not OSBYTE) then branch
    JMP .handleOSBYTECall                               ;
+
    ; Check for service call indicating *HELP
    CMP #9                                              ; *HELP command?
    BNE +                                               ; if (not *HELP) then branch
    JMP .handleStarHelp                                 ;
+
    ; Check for service call indicating an unrecognised *command
    CMP #4                                              ; unrecognised star command?
    BNE +                                               ; if (not star command) then branch
    JMP .handleUnrecognisedStarCommand                  ;
+
    RTS                                                 ; exit with A preserved, so call is
                                                        ; passed on to the next ROM

; ***************************************************************************************
;
; Called on a hard reset
;
; Reset the ROM workspace byte to zero (this marks the ROM as inactive, no memory claimed yet), and
; check the ROM number. If odd, then we initialise the ROM, otherwise we remain inactive and pass on
; the service call to the next ROM. See the next section for more of an explanation.
;
; On Entry:
;   X is the ROM number
;
; ***************************************************************************************
.lastResetWasHardReset
    LDA #0                                              ; store zero into ROM workspace byte
    STA .romWorkspaceBytes,X                            ; (high byte of private workspace)
    TXA                                                 ;
!if MACHINE = BBC_B {
    AND #1
} else if MACHINE = BBC_B_PLUS {
    AND #2
} else if MACHINE = ELECTRON {
    ; NOTE: What's the best rule for deciding default on/off for an Electron?
    ; I suspect a 1980s cartridge release for use with the Plus 1 would have
    ; done AND #2 so one cartridge would enable it by default and the other
    ; wouldn't.
    AND #1
} else {
    +unknown_machine
}
    BNE .claimWorkspace                                 ; if (ROM number is odd) then branch
.passOnToNextROM
    LDA #2                                              ; set A to 'relative private workspace
    RTS                                                 ; claim' for the next ROM to check

; ***************************************************************************************
;
; Claim private workspace memory
;
; On a reset, the ROM receives a service call to claim the private workspace memory it needs.
;
; Private workspace is memory required by the GXR (a) to store the current state of the system,
; (b) for a flood fill buffer and (c) to store sprites.
;
; There is one case where the GXR is not enabled. On a power on or hard reset (CTRL-Break) if
; the GXR is in an even numbered ROM socket it does not claim any memory and is inactive until
; the *GXR command is given. The inactive GXR state is a useful default as it doesn't consume
; memory (doesn't raise PAGE), which generally gives better compatibility with games and other
; software.
;
; The ROM workspace byte:
;
; Each ROM can store a single byte of state at .romWorkspaceBytes,X (where X is the ROM number)
;
; * An inactive GXR has the byte set to zero.
; * If the GXR is becoming active, then it is one.
; * If the GXR is becoming inactive, then it is zero.
; * If the GXR is already active, then it stores the page number of its private workspace.
;
; An active GXR ROM can be made inactive using *NOGXR.
;
; Since this memory allocation only happens on a reset, the user is prompted to 'Press BREAK'
; after using any of the *commands that change the required memory use.
;
; ***************************************************************************************
.serviceRelativePrivateWorkspaceClaim
    ; Remember parameters
    STA .vduWorkspaceA                                  ; store service call number (A=2)
    STY .vduWorkspaceC                                  ; store Y=first available page

    JSR .getPrivateWorkspaceAddress                     ;

    LDA .privateWorkspaceHigh                           ;
    BEQ +                                               ; if (no workspace set) then branch

    ; Check if soft character definitions have already been cached
    LDY #.workspaceOffsetHasCachedSoftCharacterDefinitions ;
    LDA (.privateWorkspaceLow),Y                        ;
    BPL +                                               ; if (not cached already) then branch
    ; Restore the character definitions if they were already cached in the workspace area
    JSR .copyWorkspaceCacheBackIntoCharacterDefinitons  ;
+

    ; Store the first available page as our workspace address
    LDY .vduWorkspaceC                                  ; private workspace page
    STY .privateWorkspaceHigh                           ;

    LDA .lastResetType                                  ; what type of reset was last done?
    AND #3                                              ;    0    Soft reset (BREAK)
                                                        ;    1    Power on
                                                        ;    2    Hard reset (CTRL-BREAK)
                                                        ; [NOTE: Arguably should use OSBYTE $FD]

    BNE .lastResetWasHardReset                          ; if (not a soft reset) then branch

    ; Soft reset
    LDA .romWorkspaceBytes,X                            ; (high byte of private workspace)
    BEQ .passOnToNextROM                                ; if (GXR not active) then branch
                                                        ; (pass on to next ROM)

.claimWorkspace
    TYA                                                 ; A = Y = first available page
    CMP .romWorkspaceBytes,X                            ; have we already got this space?
    BEQ .alreadyClaimed                                 ; if (already claimed) then branch

    ; not already claimed, so claim it
    STA .romWorkspaceBytes,X                            ; store amount of claimed space

    ; No sprite chosen by default
    LDA #0                                              ;
    LDY #.workspaceOffsetChosenSpriteIndex              ;
    STA (.privateWorkspaceLow),Y                        ; workspace[chosen sprite index] = 0

    ; Zero sprites initially
    LDY #.workspaceOffsetNumberOfSprites                ;
    STA (.privateWorkspaceLow),Y                        ; workspace[number of sprites] = 0

    ; Zero sprite pages
    DEY                                                 ; Y=#.workspaceOffsetSpritePages
    STA (.privateWorkspaceLow),Y                        ; workspace[sprite pages] = 0

    ; Flood fill enabled by default
    DEY                                                 ; Y=#.workspaceOffsetOptions
    LDA #$80                                            ;
    STA (.privateWorkspaceLow),Y                        ; workspace[options] = $80 (flood enabled)

    ; Record three pages used
    DEY                                                 ; Y=#.workspaceOffsetTotalPagesWithoutSprites
    LDA #3                                              ;
    STA (.privateWorkspaceLow),Y                        ; workspace[#pages without sprites] = 3

.alreadyClaimed
    ; Store sprite address
    LDY #.workspaceOffsetChosenSpriteAddressLow         ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vduTempStoreDC                                 ; }
    INY                                                 ; } tempStoreDC/DD = sprite address
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vduTempStoreDD                                 ; }

    ; Check for an existing chosen sprite
    INY                                                 ; Y=#.workspaceOffsetChosenSpriteIndex
    LDA (.privateWorkspaceLow),Y                        ;
    BEQ +                                               ; if (no chosen sprite) then branch

    ; Set currently chosen sprite to zero
    TAX                                                 ; X = chosen sprite
    LDA #0                                              ; }
    STA (.privateWorkspaceLow),Y                        ; } workspace[currently chosen sprite] = 0
    JSR .addSpriteLoop                                  ; ensure the sprite is back in sprite memory properly

+
    ; Check if flood fill is pending, due to be activated
    LDY #.workspaceOffsetOptions                        ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    AND #$C0                                            ; } Check top two bits of options.
    CMP #$40                                            ; } check top bit is clear (previously non flood mode) and bit 6 is set (flood mode is pending)
    BNE .notActivatingFlood                             ; } if (we are not activating flood) then branch

    ; Activate flood mode
    ASL                                                 ; A=$80 (shifts bit 6 to bit 7) making flood enabled
    STA (.privateWorkspaceLow),Y                        ; store in options
    INY                                                 ; Y=#.workspaceOffsetSpritePages
    LDA (.privateWorkspaceLow),Y                        ;
    BEQ .notActivatingFlood                             ; if (no sprite pages) then branch

    ; Copy all the sprite data 2 pages further in memory to make room for the two pages of flood fill data
    STA .vduTempStoreDF                                 ; tempStoreDF = number of sprite pages
    LDA #0                                              ; }
    STA .vduTempStoreDA                                 ; } set low bytes to zero
    STA .vduTempStoreDC                                 ; }
    STA .vduTempStoreDE                                 ; }

    CLC                                                 ;
    LDY #.workspaceOffsetSpriteStartPage                ; }
    LDA (.privateWorkspaceLow),Y                        ; } tempStoreDD = sprite start page
    STA .vduTempStoreDD                                 ; }
    ADC #2                                              ;
    STA .vduTempStoreDB                                 ; tempStoreDB = sprite data plus two pages
    JSR .blockCopyMemoryDecrementing                    ; copy tempStoreDE/DF bytes from tempStoreDC/DD to tempStoreDA/DB

.notActivatingFlood
    ; Calculate how many pages we use (1 or 3) until the sprite data
    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ; A = workspace[options]
    ASL                                                 ; carry = flood enabled
    LDA #$80                                            ; A = $80
    ROL                                                 ; A = carry, carry = 1
    ROL                                                 ; A = 2*carry + 1 = number of pages required (1 or 3), carry = 0
    ADC .privateWorkspaceHigh                           ; add current workspace page

    ; Store sprite start page
    LDY #.workspaceOffsetSpriteStartPage                ;
    STA (.privateWorkspaceLow),Y                        ; set workspace[sprite page] =  page after workspace

    JSR .resetCurrentSpriteAddress                      ;

    ; Copy the code at .gxrOSWRCH into our workspace so we can intercept OSWRCH calls.
    LDY #.notCompatible - .gxrOSWRCH - 1                ;
-
    LDA .gxrOSWRCH,Y                                    ;
    STA (.privateWorkspaceLow),Y                        ;
    DEY                                                 ;
    BPL -                                               ;

    ; Patch in the appropriate addresses / values into the code
    LDY #.jmpOldWRCHPatch - .gxrOSWRCH                  ; }
    LDA .vectorWRCHVLow                                 ; }
    PHA                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; } workspace[patch] = vectorWRCHVLow/High
    INY                                                 ; }
    LDA .vectorWRCHVHigh                                ; }
    STA (.privateWorkspaceLow),Y                        ; }

    LDY #.jsrOldWRCHPatch + 1 - .gxrOSWRCH              ; }
    STA (.privateWorkspaceLow),Y                        ; } workspace[patch + 1] = vectorWRCHVLow/High
    DEY                                                 ; }
    PLA                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }

    LDY #.ldaOurWRCHHighPatch - .gxrOSWRCH              ;
    LDA .vduWorkspaceC                                  ; insert high byte of our code into
    STA (.privateWorkspaceLow),Y                        ; .gxrOSWRCH to write into jump vector

    LDY #.ldaOurRomBankPatch - .gxrOSWRCH               ;
    LDA .currentlySelectedROM                           ; insert currently selected ROM into
    STA (.privateWorkspaceLow),Y                        ; .gxrOSWRCH code at label '.ldaOurRomBankPatch'

    JSR .swapWorkspaceWithVDUVectors                    ; swap in our VDUV routine

    ; Handle the extended VDU vector
    LDA #<.extendedVectorTableVDUV                      ; }
    STA .vectorVDUVLow                                  ; }
    LDA #>.extendedVectorTableVDUV                      ; } Extended vector E_VDUV at $FF39
    STA .vectorVDUVHigh                                 ; }

    LDA #<.extendedVectorVDURoutine                     ; }
    STA .extendedVDUVLow                                ; }
    LDA #>.extendedVectorVDURoutine                     ; }
    STA .extendedVDUVHigh                               ; } Point at our extended vector routine
    LDA .currentlySelectedROM                           ; } and ROM number
    STA .extendedVDUVROM                                ; }

    ; Reset patterns
    JSR .resetPatternFillsToDefaults                    ;

    ; Reset dot-dash pattern
    LDA #0                                              ;
    JSR .setDotPatternAndRepeat                         ;

    ; Set the OSWRCH vector to point to our gxrOSWRCH (at the start of our private workspace)
    CLC                                                 ;
    LDA #0                                              ;
    STA .vectorWRCHVLow                                 ;
    LDA .vduWorkspaceC                                  ;
    STA .vectorWRCHVHigh                                ;

    ; Calculate sprite end page = sprite start page initially
    LDY #.workspaceOffsetTotalPagesWithoutSprites       ;
    ADC (.privateWorkspaceLow),Y                        ; add total pages without sprites
    LDY #.workspaceOffsetSpriteEndPage                  ;
    STA (.privateWorkspaceLow),Y                        ; store as end page

    ; Leave with Y=end page (i.e. next unused page), X=ROM number, A=2 (the service call number)
    TAY                                                 ;
    LDX .currentlySelectedROM                           ;
    LDA .vduWorkspaceA                                  ; A=2
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 5: Parsing star commands
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Handle a star command that the OS doesn't know
;
; ***************************************************************************************
.handleUnrecognisedStarCommand
    PHA                                                 ; }
    TYA                                                 ; } remember A,Y
    PHA                                                 ; }

    JSR .getPrivateWorkspaceAddress                     ;

    ; Loop to check user star command against each star command in our table
    LDX #0                                              ;
    STX .vduTempStoreDC                                 ; command index = 0
    STY .vduTempStoreDA                                 ; index into user input string = 0

.tryNextCommand
    LDY .vduTempStoreDA                                 ; Y = start of user input string
    JSR .checkForCommandMatch                           ;

    BEQ .starCommandFound                               ; if (command found) then branch

    ; Skip forward to end of command
-
    INX                                                 ;
    LDA .commandNameTable,X                             ;
    BNE -                                               ;

    INC .vduTempStoreDC                                 ; increment command index
    INX                                                 ; skip past terminator
    LDA .commandNameTable,X                             ;
    BNE .tryNextCommand                                 ; if (not at end of table) then branch

.exitRestoringAXYLocal
    JMP .exitRestoringAXY                               ;

.skipSpacesLoop
    INY                                                 ; }
.starCommandFound
    LDA (.stringInputBufferAddressLow),Y                ; }
    CMP #' '                                            ; } skip past spaces
    BEQ .skipSpacesLoop                                 ; }

    ASL .vduTempStoreDC                                 ; double the command index to get a table offset
    BEQ .skipGXRActiveCheck                             ; if (star GXR) then branch

    LDX .currentlySelectedROM                           ; }
    LDA .romWorkspaceBytes,X                            ; }
    BEQ .exitRestoringAXYLocal                          ; } if (GXR is not active) then branch (exit)

.skipGXRActiveCheck
    LDX .vduTempStoreDC                                                     ;
    CPX #.endOfCommandsNotRequiringSpriteSpace - .starCommandAddressTable   ; first set of commands don't require sprite space allocated
    BCC .getCommandAddressFromTableAndCallIt                                ; if (no sprite space needed) then branch

    ; Check we have sprite memory
    STY .vduTempStoreDD                                 ; store Y
    JSR .getPrivateWorkspaceAddress                     ; make sure we have the workspace address

    LDY #.workspaceOffsetSpritePages                    ; }
    LDA (.privateWorkspaceLow),Y                        ; } check for no sprite memory
    BEQ .noSpriteMemoryError                            ; } if (no sprite memory allocated) then branch

    ; Check we are in a graphics MODE
    LDY .vduTempStoreDD                                                 ; recall Y
    CPX #.endOfCommandsRequiringSpriteSpace - .starCommandAddressTable  ; third set of commands need to be in a graphics MODE
    BCC .getCommandAddressFromTableAndCallIt                            ; if (in second set of commands) then branch

    LDA .vduPixelsPerByteMinusOne                       ; }
    BEQ .notAGraphicsMODEError                          ; } if (not in a graphics MODE) then branch

.getCommandAddressFromTableAndCallIt
    LDX .vduTempStoreDC                                 ;
    LDA .starCommandAddressTable,X                      ; }
    STA .vduTempStoreDA                                 ; }
    LDA .starCommandAddressTable + 1,X                  ; } get routine's address from
    STA .vduTempStoreDB                                 ; } the table

    CLC                                                 ; }
    TYA                                                 ; }
    ADC .stringInputBufferAddressLow                    ; }
    TAX                                                 ; } XY = pointer to (remainder of)
    LDY .stringInputBufferAddressHigh                   ; } user input string
    BCC +                                               ; }
    INY                                                 ; }
+
    JSR .jumpToRoutine                                  ; call *command routine

    LDX .currentlySelectedROM                           ; }
    PLA                                                 ; }
    TAY                                                 ; } restore registers
    PLA                                                 ; }
    LDA #0                                              ; zero indicates the service call has been handled.
    RTS                                                 ;

; ***************************************************************************************
;
; Jump to routine to implement the specific star command
;
; ***************************************************************************************
.jumpToRoutine
    JMP (.vduTempStoreDA)                               ; jump to address in DA/DB to handle star command

; ***************************************************************************************
.noSpriteMemoryError
    JSR .generateError                                  ; does not return
    !byte $80                                           ; error number
    !text "No sprite memory",0                          ; error message

; ***************************************************************************************
.notAGraphicsMODEError
    JSR .generateError                                  ; does not return
    !byte $81                                           ; error number
    !text "Not a graphics mode",0                       ; error message

; ***************************************************************************************
.commandNameTable
    !text "gxr"      , 0                                ; enable GXR
    !text "flood"    , 0                                ; allocate memory for flood fill
    !text "noflood"  , 0                                ; deallocate memory for flood fill
    !text "nogxr"    , 0                                ; disable GXR
    !text "sspace"   , 0                                ; allocate space for sprites

    !text "schoose"  , 0                                ; requires allocated sprite space
    !text "sdelete"  , 0                                ; requires allocated sprite space
    !text "sload"    , 0                                ; requires allocated sprite space
    !text "smerge"   , 0                                ; requires allocated sprite space
    !text "snew"     , 0                                ; requires allocated sprite space
    !text "srenumber", 0                                ; requires allocated sprite space
    !text "ssave"    , 0                                ; requires allocated sprite space

    !text "sedit"    , 0                                ; call when in a graphics MODE
    !text "sget"     , 0                                ; call when in a graphics MODE
    !byte 0                                             ; terminator

; ***************************************************************************************
;
; *HELP names
;
; ***************************************************************************************
.graphicsNameTable
    !text "graphics" , 0                                ;
.spritesNameTable
    !text "sprites"  , 0                                ;

; ***************************************************************************************
.starCommandAddressTable
    !word .starGXR                                      ; enable GXR
    !word .starFlood                                    ; allocate memory for flood fill
    !word .starNoFlood                                  ; deallocate memory for flood fill
    !word .starNoGXR                                    ; disable GXR
    !word .starSSpace                                   ; allocate space for sprites
.endOfCommandsNotRequiringSpriteSpace
    !word .starSChoose                                  ; requires allocated sprite space
    !word .starSDelete                                  ; requires allocated sprite space
    !word .starSLoad                                    ; requires allocated sprite space
    !word .starSMerge                                   ; requires allocated sprite space
    !word .starSNew                                     ; requires allocated sprite space
    !word .starSRenumber                                ; requires allocated sprite space
    !word .starSSave                                    ; requires allocated sprite space
.endOfCommandsRequiringSpriteSpace
    !word .starSEdit                                    ; call when in a graphics MODE
    !word .starSGet                                     ; call when in a graphics MODE

; ***************************************************************************************
;
; Check for a match to a star command or *HELP name
;
; ***************************************************************************************
.checkForCommandMatch
    LDA (.stringInputBufferAddressLow),Y                ; get character from user input
    INY                                                 ; move to next character
    CMP #'.'                                            ; check for abbreviation
    BEQ .endOfMatch                                     ; if (ends in dot) then branch

    ORA #$20                                            ; ensure lower case
    CMP .commandNameTable,X                             ; check against entry in table
    BNE .endOfMatch                                     ; if (doesn't match command) then branch

    INX                                                 ; move to next character in table
    LDA .commandNameTable,X                             ; get next character from table
    BNE .checkForCommandMatch                           ; if (next character not zero) then branch

.endOfMatch
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 6: Parsing OSBYTE (*FX) commands
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Get either the GXR status or size of the current sprite
;
; ***************************************************************************************
.getGXRStatusOrSpriteSize
    LDA .romWorkspaceBytes,X                            ;
    BNE .getGXRStatusOrSpriteSizeInternal               ; if (GXR is active) then branch

.resetXY
    ; Set OSBYTE X and Y to zero (always called with A=0)
    STA .osbyteX                                        ;
    STA .osbyteY                                        ;

    ; Set X and Y to 0
    TAX                                                 ;
    TAY                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.getGXRStatusOrSpriteSizeInternal
    JSR .getPrivateWorkspaceAddress                     ;

    LDA .osbyteY                                        ;
    CMP #$41                                            ;
    BNE .getCurrentSpriteSize                           ; if (not *FX 163,242,66) then branch (get size of selected sprite)

    ; Get GXR status

    ; First get dot-dash pattern in bits 0-5
    LDY #.workspaceOffsetDotDashRepeatLength            ;
    LDA (.privateWorkspaceLow),Y                        ;
    AND #$3F                                            ; dot-dash length MOD 64
    STA .osbyteX                                        ; temp store

    ; Add the current memory options in bits 6-7
    LDY #.workspaceOffsetOptions                        ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    AND #$80                                            ; } Set X to status:
    SEC                                                 ; }   bit 7: 1 (GXR active)
    ROR                                                 ; }   bit 6: flood enabled
    ORA .osbyteX                                        ; }   bits 0-5: dot-dash length MOD 64
    TAX                                                 ; }

    ; Y = number of sprite pages
    INY                                                 ; Y=#.workspaceOffsetSpritePages
    LDA (.privateWorkspaceLow),Y                        ; get sprite pages
    TAY                                                 ; Y = sprite pages

.exitStoringXY
    STX .osbyteX                                        ; OSBYTE X = status
    STY .osbyteY                                        ; OSBYTE Y = sprite pages
    LDA #0                                              ;
    RTS                                                 ;

; ***************************************************************************************
.getCurrentSpriteSize
    ; tempStoreDA/DB = sprite address
    LDY #.workspaceOffsetCurrentSpriteAddressLow        ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vduTempStoreDA                                 ; } get address of current sprite into tempStoreDA/DB
    INY                                                 ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vduTempStoreDB                                 ; }

    ORA .vduTempStoreDA                                 ; }
    BEQ .resetXY                                        ; } if (sprite address is zero) then branch

    ; X,Y = sprite width, height
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.vduTempStoreDA),Y                             ;
    TAX                                                 ; X = width of sprite - 1
    INY                                                 ;
    LDA (.vduTempStoreDA),Y                             ;
    TAY                                                 ; Y = height of sprite - 1

    INX                                                 ; X = width of sprite
    INY                                                 ; Y = height of sprite
    BNE .exitStoringXY                                  ; ALWAYS branch

; ***************************************************************************************
.notHandled
    LDA #7                                              ; unrecognised OSBYTE call reason code
    RTS                                                 ; pass on to next ROM

; ***************************************************************************************
;
; Handle an OSBYTE (*FX) call that the OS doesn't know
;
; ***************************************************************************************
.handleOSBYTECall
    ; Check for *FX 163
    LDA .osbyteA                                        ;
    CMP #163                                            ;
    BNE .notHandled                                     ; if (not *FX 163) then branch

    ; Check for *FX 163,242
    LDA .osbyteX                                        ;
    CMP #242                                            ;
    BNE .notHandled                                     ; if (not *FX 163,242) then branch

    ; Check for *FX 163,242,65
    LDA .osbyteY                                        ;
    CMP #65                                             ;
    BEQ .getGXRStatusOrSpriteSize                       ; if (*FX 163,242,65) then branch (get GXR status)

    ; Check for *FX 163,242,66
    CMP #66                                             ;
    BEQ .getGXRStatusOrSpriteSize                       ; if (*FX 163,242,66) then branch (get size of selected sprite)

    BCS .notHandled                                     ; if (.osbyteY > 66) then branch (not handled)

    ; Check GXR is active
    LDA .romWorkspaceBytes,X                            ;
    BEQ .notHandled                                     ; if (GXR not active) then branch (not handled)

    ; Handle *FX 163,242,.osbyteY (where 0<=.osbyteY<=64)
    LDA .osbyteY                                        ;
    JSR .setDotPatternAndRepeat                         ;

    LDX .osbyteX                                        ; }
    LDY .osbyteY                                        ; } Restore OSBYTE X and Y,
    LDA #0                                              ; } and return with A=0 to indicate
    RTS                                                 ; } 'handled'

; ***************************************************************************************
.setDotPatternAndRepeat
    JSR .getPrivateWorkspaceAddress                     ;
    BNE .setDotPatternToA                               ;

    ; Reset to default dot pattern (*FX 163,242,0)
    LDY #.workspaceOffsetDotDashPattern                 ;
    LDX #7                                              ; loop counter
    LDA #%10101010                                      ; value to store (default dot pattern)
-
    STA (.privateWorkspaceLow),Y                        ;
    INY                                                 ;
    DEX                                                 ;
    BPL -                                               ;

    ; Reset to default pattern length
    LDA #8                                              ; default dot-dash pattern length
    ; fall through...

; ***************************************************************************************
.setDotPatternToA
    LDY #.workspaceOffsetDotDashRepeatLength            ;
    STA (.privateWorkspaceLow),Y                        ; workspace[DotDashRepeatLength]  = dot-dash pattern length
    INY                                                 ;
    STA (.privateWorkspaceLow),Y                        ; workspace[DotDashBitsRemaining] = bits remaining of dot-dash pattern length
    INY                                                 ;
    LDA #$80                                            ;
    STA (.privateWorkspaceLow),Y                        ; workspace[DotDashBit]           = one bit set. This is the mask to extract the next dot-dash pattern bit
    INY                                                 ;
    LDA #0                                              ;
    STA (.privateWorkspaceLow),Y                        ; workspace[DotDashPatternByte]   = current dot-dash pattern byte
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 7: Parsing *HELP Commands
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Parse a *HELP command
;
; See help.png
;
; The help command responds to "*HELP GRAPHICS" and "*HELP SPRITES" as well as just "*HELP"
;
; ***************************************************************************************
.handleStarHelp
    PHA                                                 ; }
    TYA                                                 ; } remember A,Y
    PHA                                                 ; }
    JSR .getPrivateWorkspaceAddress                     ;
    JSR .OSNEWL                                         ;

    ; Print title string
    LDX #0                                              ;
-
    LDA .titleString,X                                  ;
    JSR .OSWRCH                                         ;
    INX                                                 ;
    CMP #0                                              ; print until zero byte
    BNE -                                               ;

    ; Check for parameter to *HELP
    LDA (.stringInputBufferAddressLow),Y                ;
    CMP #$0D                                            ;
    BNE .starHelpHasAParameter                          ; if (parameter found) then branch

    ; Print plain *HELP string to show items that can be *HELPed
    JSR .printInlineCounted                             ; display following message
    !byte 23                                            ; length of message to print
    !text "  Graphics",.charLF,.charCR                  ;
    !text "  Sprites",.charLF,.charCR                   ;

    JMP .exitRestoringAXY                               ;

.starHelpHasAParameter
    TYA                                                 ;
    PHA                                                 ; remember Y
    LDX #.graphicsNameTable - .commandNameTable         ; point to start of graphics name table
    JSR .checkForCommandMatch                           ;
    BNE .checkForStarHelpSpritesCommand                 ; if (not *HELP GRAPHICS) then branch

    ; Show GXR On / Off state, and flood On / Off state
    LDA .privateWorkspaceHigh                           ;
    BNE .gotWorkspace                                   ; if (got workspace) then branch

    JSR .printInlineCounted                             ; display following message
    !byte 9                                             ; length of message to print
    !text "  GXR Off"                                   ;
    JMP .afterFloodMessage                              ;

.gotWorkspace
    JSR .printInlineCounted                             ; display following message
    !byte 16                                            ; length of message to print
    !text "  GXR On, Flood "                            ;
    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ;
    AND #$C0                                            ;
    BNE .floodIsOn                                      ; if (workspace[options] has bit 6 or 7 set) then branch

    ; Flood is off
    JSR .printInlineCounted                             ; display following message
    !byte 3                                             ; length of message to print
    !text "Off"                                         ;
    JMP .afterFloodMessage                              ;

.floodIsOn
    JSR .printInlineCounted                             ; display following message
    !byte 2                                             ; length of message to print
    !text "On"                                          ;

.afterFloodMessage
    JSR .OSNEWL                                         ;
    JSR .OSNEWL                                         ; print two newlines [NOTE: These could be in the help text, saving 2 bytes]
    LDX #<.graphicsHelpText                             ;
    LDY #>.graphicsHelpText                             ;
    JSR .printHelpYX                                    ; print graphics help

.checkForStarHelpSpritesCommand
    PLA                                                 ;
    TAY                                                 ; recall Y
    LDX #.spritesNameTable - .commandNameTable          ;
    JSR .checkForCommandMatch                           ;
    BEQ +                                               ; if (found match) then branch
    JMP .exitRestoringAXY                               ; no match. finish up.

+
    LDA .privateWorkspaceHigh                           ;
    BEQ .printSpritesHelp                               ;

    ; Show sprite status / memory
    ; Print "  Sprite status"
    JSR .OSNEWL                                         ;
    LDX #<.spriteStatusText                             ;
    LDY #>.spriteStatusText                             ;
    JSR .printHelpYX                                    ;

    LDY #.workspaceOffsetSpritePages                    ;
    LDA (.privateWorkspaceLow),Y                        ;
    PHA                                                 ;
    LDX #0                                              ;
    JSR .printNumberA                                   ;

    JSR .printInlineCounted                             ; display following message
    !byte 25                                            ; length of message to print
    !text " page(s) sprite w/s",.charCR,.charLF,"    "  ;

    PLA                                                 ;
    BEQ .printSpritesHelp                               ;

    JSR .getFreeSpace                                   ;

    LDA .vduTempStoreDE                                 ;
    LDX .vduTempStoreDF                                 ;
    JSR .printNumberXA                                  ;

    JSR .printInlineCounted                             ; display following message
    !byte 19                                            ; length of message to print
    !text " byte(s) free",.charCR,.charLF,"    "        ;

    LDY #.workspaceOffsetNumberOfSprites                ;
    LDA (.privateWorkspaceLow),Y                        ; get number of sprites
    JSR .printNumberA                                   ; print number

    JSR .printInlineCounted                             ; display following message
    !byte 20                                            ; length of message to print
    !text " sprite(s) defined",.charCR,.charLF          ;

.printSpritesHelp
    JSR .OSNEWL                                         ;

    LDX #<.spritesHelpText                              ;
    LDY #>.spritesHelpText                              ;
    JSR .printHelpYX                                    ;

.exitRestoringAXY
    LDX .currentlySelectedROM                           ; recall X
    PLA                                                 ; }
    TAY                                                 ; } recall Y and A
    PLA                                                 ; }
    RTS                                                 ;

; ***************************************************************************************
.graphicsHelpText
    !text "  GXR commands"                      ,$0D    ;
    !text "GXR"                                 ,$0D    ;
    !text "NOGXR"                               ,$0D    ;
    !text "FLOOD"                               ,$0D    ;
    !text "NOFLOOD"                             ,$0D    ;
    !text $0D                                           ;
    !text $08,$08,"Plot codes"                  ,$0D    ;
    !text "00 Line"                             ,$0D    ;
    !text "08 Line (LPO)"                       ,$0D    ;
    !text "10 Dot-dash (R)"                     ,$0D    ;
    !text "18 Dot-dash (R,LPO)"                 ,$0D    ;
    !text "20 Line (FPO)"                       ,$0D    ;
    !text "28 Line (BEO)"                       ,$0D    ;
    !text "30 Dot-dash (C,FPO)"                 ,$0D    ;
    !text "38 Dot-dash (C,BEO)"                 ,$0D    ;
    !text $0D                                           ;
    !text "40 Point"                            ,$0D    ;
    !text "48 Fill L&R to Non-bg"               ,$0D    ;
    !text "50 Triangle"                         ,$0D    ;
    !text "58 Fill R to bg"                     ,$0D    ;
    !text "60 Rectangle"                        ,$0D    ;
    !text "68 Fill L&R to fg"                   ,$0D    ;
    !text "70 Parallelogram"                    ,$0D    ;
    !text "78 Fill R to Non-fg"                 ,$0D    ;
    !text $0D                                           ;
    !text "80 Flood to Non-bg"                  ,$0D    ;
    !text "88 Flood to fg"                      ,$0D    ;
    !text "90 Circle outline"                   ,$0D    ;
    !text "98 Circle fill"                      ,$0D    ;
    !text "A0 Circular arc"                     ,$0D    ;
    !text "A8 Circular segment"                 ,$0D    ;
    !text "B0 Circular sector"                  ,$0D    ;
    !text "B8 Block copy/move"                  ,$0D    ;
    !text $0D                                           ;
    !text "C0 Ellipse outline"                  ,$0D    ;
    !text "C8 Ellipse fill"                     ,$0D    ;
    !text "D0"                                  ,$0D    ;
    !text "D8"                                  ,$0D    ;
    !text "E0"                                  ,$0D    ;
    !text "E8 Sprite plot"                      ,$0D    ;
    !text "F0"                                  ,$0D    ;
    !text "F8"                                  ,$0D    ;
    !text $0D                                           ;
    !text $08,$08,"Set dot-dash repeat length"  ,$0D    ;
    !text "*FX 163,242,k : k=0,1-64"            ,$0D    ;
    !text $0D                                           ;
    !text $08,$08,"Define patterns"             ,$0D    ;
    !text "VDU 23,k,b,b,b,b,b,b,b,b with k="    ,$0D    ;
    !text "2,3,4,5 : full setting"              ,$0D    ;
    !text "6       : dot-dash line"             ,$0D    ;
    !text "11      : default setting"           ,$0D    ;
    !text "12,13,14,15 : simple setting"        ,$0D    ;
    !text $0D                                           ;
    !text "VDU 23,27,0,n,0;0;0;"                ,$0D    ;
    !text "  Choose sprite n for plotting"      ,$0D    ;
    !text "VDU 23,27,1,n,0;0;0;"                ,$0D    ;
    !text "  Get sprite n from screen"          ,$0D    ;
    !text $0D                                           ;
    !text $08,$08,"Select colour pattern"       ,$0D    ;
    !text "GCOL a,c"                            ,$0D    ;
    !text "a<16 solid colour c"                 ,$0D    ;
    !text "a=16-21 : pattern 1"                 ,$0D    ;
    !text "a=32-37 : pattern 2"                 ,$0D    ;
    !text "a=48-53 : pattern 3"                 ,$0D    ;
    !text "a=64-69 : pattern 4"                 ,$0D    ;
    !byte 0                                             ;

; ***************************************************************************************
.spriteStatusText
    !text "  Sprite status"                     ,$0D    ;
    !byte 0                                             ;

; ***************************************************************************************
.spritesHelpText
    !text "  Sprite commands"                   ,$0D    ;
    !text "SSPACE n"                            ,$0D    ;
    !text "SCHOOSE n"                           ,$0D    ;
    !text "SDELETE n"                           ,$0D    ;
    !text "SEDIT n"                             ,$0D    ;
    !text "SEDIT n,m"                           ,$0D    ;
    !text "SGET n"                              ,$0D    ;
    !text "SLOAD filename"                      ,$0D    ;
    !text "SMERGE filename"                     ,$0D    ;
    !text "SNEW"                                ,$0D    ;
    !text "SRENUMBER n,m"                       ,$0D    ;
    !text "SSAVE filename"                      ,$0D    ;
    !byte 0                                             ;

; ***************************************************************************************
;
; Print a help message
;
; ***************************************************************************************
.printHelpYX
    STX .vduTempStoreDA                                 ; } store YX in tempStoreDA/DB
    STY .vduTempStoreDB                                 ; }
    LDY #0                                              ; Y=0 throughout this routine
-
    LDA .vduTempStoreDA                                 ; }
    PHA                                                 ; }
    LDA .vduTempStoreDB                                 ; } remember tempStoreDA/DB
    PHA                                                 ; }

    LDA (.vduTempStoreDA),Y                             ; get next character
    CMP #.charCR                                        ;
    BNE +                                               ; if (not carriage return) then branch

    JSR .OSNEWL                                         ; print newline
    LDA #' '                                            ; }
    JSR .OSWRCH                                         ; }
    JSR .OSWRCH                                         ; } indent by three spaces
    JSR .OSWRCH                                         ; } [NOTE: could be a string, using .printInlineCounted]
+
    JSR .OSWRCH                                         ; print character

    PLA                                                 ; }
    STA .vduTempStoreDB                                 ; } restore tempStoreDA/DB
    PLA                                                 ; }
    STA .vduTempStoreDA                                 ; }
    JSR .incTempStoreDADB                               ; move pointer on to next character

    LDA (.vduTempStoreDA),Y                             ; check for terminator
    BNE -                                               ; if (terminator not found) then branch back
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 8: Intercepting unknown VDU commands
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Swaps the vectorVDUV with workspace copy
;
; This includes swapping the extended VDUV and ROM number.
;
; On Exit:
;   Preserves Y
;
; ***************************************************************************************
.swapWorkspaceWithVDUVectors
    TYA                                                 ;
    PHA                                                 ; remember Y
    JSR .getPrivateWorkspaceAddress                     ;

    ; Swaps the current vectorVDUV with workspace[.workspaceOffsetOldVDUVectorV]
    LDY #.workspaceOffsetOldVDUVectorVLow               ; }
    LDA .vectorVDUVLow                                  ; }
    PHA                                                 ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vectorVDUVLow                                  ; }
    PLA                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }
    INY                                                 ; } swap vectorVDUVLow/High with workspace
    LDA .vectorVDUVHigh                                 ; }
    PHA                                                 ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vectorVDUVHigh                                 ; }
    PLA                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }

    INY                                                 ;

    ; Swaps the extended vectorVDUV with workspace[.workspaceOffsetOldExtendedVDUV]
    LDA .extendedVDUVLow                                ; }
    PHA                                                 ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .extendedVDUVLow                                ; }
    PLA                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }
    INY                                                 ; } swap .extendedVDUVLow/High with workspace
    LDA .extendedVDUVHigh                               ; }
    PHA                                                 ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .extendedVDUVHigh                               ; }
    PLA                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }

    ; Swaps the extended VDUV ROM number with workspace[.workspaceOffsetOldExtendedVDUVROM]
    INY                                                 ; }
    LDA .extendedVDUVROM                                ; }
    PHA                                                 ; }
    LDA (.privateWorkspaceLow),Y                        ; } swap .extendedVDUVROM with workspace
    STA .extendedVDUVROM                                ; }
    PLA                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }

    PLA                                                 ;
    TAY                                                 ; recall Y
    RTS                                                 ;

; ***************************************************************************************
;
; Read and store the address of our workspace in .privateWorkspaceHigh/Low
;
; Preserves A,X,Y,Carry
;
; ***************************************************************************************
.getPrivateWorkspaceAddress
    PHA                                                 ; }
    TXA                                                 ; } store A and X
    PHA                                                 ; }

    ; Get the ROM byte for this ROM, which stores the private workspace page
    LDX .currentlySelectedROM                           ; get the ROM slot number
    LDA .romWorkspaceBytes,X                            ; get the high byte of private workspace

    ; Set up the private workspace address
    STA .privateWorkspaceHigh                           ; which is non-zero if GXR is active
    LDA #0                                              ;
    STA .privateWorkspaceLow                            ;

    PLA                                                 ; }
    TAX                                                 ; } recall A and X
    PLA                                                 ; }
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 9: Trampoline code for OSWRCH
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSWRCH routine to intercept VDU 22 and VDU 25
;
; The following code is copied into our ROM's private workspace at startup (the source of the
; memory copy is from .gxrOSWRCH up to the start of .notCompatible). This code is required to be in
; RAM in regular memory (not Sideways ROM) in order to intercept the regular OSWRCH vector. It
; detects both VDU 22 (PLOT) and VDU 25 (MODE).
;
; Executing from the private workspace, this code then selects the GXR ROM and calls into the ROM
; as needed (see .vdu22Or25EntryPoint). This is sometimes known as "trampoline" code.
;
; At the point it is copied into our private workspace, patches are applied to the code to insert
; the relevant data:
;
;   * jump address of the previous OSWRCH vector address (used if not VDU 22/25),
;   * set the private workspace page,
;   * set the ROM number for this ROM.
;
; ***************************************************************************************
.gxrOSWRCH
    PHA                                                 ;

    ; Check for VDU 25 (PLOT)
    LDA .vduJumpVectorLow                               ;
    CMP #<.vdu25EntryPoint                              ;
    BEQ .continueTestForVDU25                           ; if (VDU 25 found) then branch

    ; Check for VDU 22 (MODE)
    CMP #<.vdu22EntryPoint                              ;
    BEQ .continueTestForVDU22                           ; if (VDU 22 found) then branch

    ; Pass on any other call to the original OSWRCH
.chainToPreviousOSWRCHHandler
    PLA                                                 ;
.jmpOldWRCHPatch = * + 1
    JMP $FFFF                                           ; jump to the next old vector routine

    ; ***** VDU 25 *****
.continueTestForVDU25
    ; At this point we know the low bytes match, but check the high bytes to be sure
    LDA .vduJumpVectorHigh                              ;
    CMP #>.vdu25EntryPoint                              ;
    BNE .chainToPreviousOSWRCHHandler                   ; if (high bytes don't match) then branch

    ; This is a PLOT (the OS has decoded VDU 25 but not all its parameters yet)

    ; Change the vdu jump vector to point to our routine '.gxrVDU25EntryPoint'
    ; this means our routine will get called once all the PLOT parameters are known
    LDA #.gxrVDU25EntryPoint - .gxrOSWRCH               ;
    STA .vduJumpVectorLow                               ;
.ldaOurWRCHHighPatch = * + 1
    LDA #$FF                                            ; address patched into 'LDA #(our private workspace page)'
    STA .vduJumpVectorHigh                              ;

    ; Continue to regular OSWRCH routine
    BNE .chainToPreviousOSWRCHHandler                   ; ALWAYS branch

    ; ***** VDU 22 *****
.continueTestForVDU22
    LDA .vduJumpVectorHigh                              ;
    CMP #>.vdu22EntryPoint                              ;
    BNE .chainToPreviousOSWRCHHandler                   ; if (high bytes don't match) then branch

    ; This is a MODE change (VDU 22)
    ; This happens straight away as we have the only parameter already
    PLA                                                 ;
.jsrOldWRCHPatch = * + 1
    JSR $FFFF                                           ; call the next old vector routine (change MODE)
    SEC                                                 ;
    BCS .callIntoROM                                    ; ALWAYS branch

    ; VDU 25 detected, continue with carry clear...
.gxrVDU25EntryPoint
    CLC                                                 ;
    ; fall through...

; ***************************************************************************************
;
; Select the GXR ROM and call into the ROM
;
; On Entry:
;    carry  set  for VDU 22 (MODE)
;    carry clear for VDU 25 (PLOT)
;
; ***************************************************************************************
.callIntoROM
    PHA                                                 ; }
    LDA .currentlySelectedROM                           ; } store A and previously selected ROM
    PHA                                                 ; }
.ldaOurRomBankPatch = * + 1
    LDA #$FF                                            ; }

    ; make sure the GXR ROM is selected
!if (MACHINE = BBC_B) | (MACHINE = BBC_B_PLUS) {
    STA .currentlySelectedROM                           ;
    STA .romSelectRegister                              ;
} else if (MACHINE = ELECTRON) {
    JSR .selectRom                                      ;
} else {
    +unknown_machine
}

    JSR .vdu22Or25EntryPoint                            ; call into the GXR ROM

    PLA                                                 ;

    ; restore previously selected ROM
!if (MACHINE = BBC_B) | (MACHINE = BBC_B_PLUS) {
    STA .currentlySelectedROM                           ;
    STA .romSelectRegister                              ;
} else if (MACHINE = ELECTRON) {
    JSR .selectRom                                      ;
} else {
    +unknown_machine
}

    PLA                                                 ; restore A
    RTS                                                 ;
; [NOTE: end of code that is copied into our private workspace RAM]


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 10: Star commands affecting memory
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; The GXR is not compatible with the OS
;
; Displays a message.
;
; See star_gxr_incompatible.png
;
; ***************************************************************************************
.notCompatible
    JSR .printInlineCounted                  ; display following message
    !byte 31                                 ; number of characters to display
    !text "GXR " + .version + " is not compatible with"  ; string to display
    LDA #0                                   ; } then show *FX 0 information
    LDX #0                                   ; } [NOTE: could be TAX saving 1 byte]
    JMP .OSBYTE                              ; }

; ***************************************************************************************
;
; *GXR
;
; Enables the GXR ROM, prompting the user to press BREAK to complete the process.
;
; See star_gxr.png
;
; ***************************************************************************************
.starGXR
    LDA #129                                            ; }
    LDX #0                                              ; } *FX 129,0,255
    LDY #255                                            ; } Read machine type
    JSR .OSBYTE                                         ; }

!if MACHINE = BBC_B {
    INX                                                 ; check for BBC B, OS 1.00 or 1.20
                                                        ; [NOTE: this ROM won't work with OS 1.00,
                                                        ;  but no check is made for this]
} else if MACHINE = BBC_B_PLUS {
    CPX #$FB                                            ; check for B+
} else if MACHINE = ELECTRON {
    CPX #$01                                            ; check for Electron
} else {
    +unknown_machine
}
    BNE .notCompatible                                  ; if (wrong machine) then branch

    LDX .currentlySelectedROM                           ; }
    LDA #1                                              ; } Store 1 in the ROM workspace byte.
    STA .romWorkspaceBytes,X                            ; } This marks GXR as 'becoming active'.

.pressBREAK
    JSR .printInlineCounted                             ; display following message
    !byte 11                                            ; number of characters to display
    !text "press BREAK"                                 ; string to display
-
    JMP -                                               ; wait forever!

; ***************************************************************************************
;
; *NOGXR
;
; Disables the Graphics Extension ROM, prompting the user to press BREAK to complete the process.
;
; ***************************************************************************************
.starNoGXR
    LDX .currentlySelectedROM                           ; }
    LDA #0                                              ; } Mark GXR as not active
    STA .romWorkspaceBytes,X                            ; }
    BEQ .pressBREAK                                     ; ALWAYS branch

; ***************************************************************************************
;
; *FLOOD
;
; Enables flood filling, prompting the user to press BREAK to complete the process.
;
; ***************************************************************************************
.starFlood
    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ; workspace[options]
    AND #$C0                                            ;
    BNE .return1                                        ; if (flood already enabled or pending) then return

    ; Mark flood as pending
    LDA #$40                                            ;
    STA (.privateWorkspaceLow),Y                        ; workspace[options] = $40

    DEY                                                 ; Y=#.workspaceOffsetTotalPagesWithoutSprites

    ; Add 2 pages to private workspace for flood fill
    CLC                                                 ; }
    LDA #2                                              ; }
    ADC (.privateWorkspaceLow),Y                        ; } workspace[pages without sprites] += 2
    STA (.privateWorkspaceLow),Y                        ; }
    BNE .pressBREAK                                     ; ALWAYS break

.return1
    RTS                                                 ;

; ***************************************************************************************
;
; *NOFLOOD
;
; Disables flood filling, prompting the user to press BREAK to complete the process.
;
; ***************************************************************************************
.starNoFlood
    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ; workspace[options]
    AND #$C0                                            ;
    BEQ .return1                                        ; if (flood already disabled and not pending) then return

    ; Mark flood disabled
    LDA #0                                              ;
    STA (.privateWorkspaceLow),Y                        ; workspace[options] = 0

    ; Take off two pages from private workspace for no flood fill
    LDY #.workspaceOffsetTotalPagesWithoutSprites       ; [NOTE: could be DEY to save one byte]
    SEC                                                 ;
    LDA (.privateWorkspaceLow),Y                        ;
    SBC #2                                              ; subtract 2 pages
    STA (.privateWorkspaceLow),Y                        ;

    ; Take off two pages from start of sprites
    SEC                                                 ;
    LDY #.workspaceOffsetSpriteStartPage                ;
    LDA (.privateWorkspaceLow),Y                        ;
    STA .vduTempStoreDD                                 ; tempStoreDD = workspace[start page]
    SBC #2                                              ;
    STA (.privateWorkspaceLow),Y                        ; workspace[start page] -= 2
    STA .vduTempStoreDB                                 ; tempStoreDB = workspace[start page]

    ; If no pages reserved for sprites, branch ("press BREAK")
    LDY #.workspaceOffsetSpritePages                    ;
    LDA (.privateWorkspaceLow),Y                        ;
    BEQ .pressBREAK                                     ; if (workspace[sprite pages] == 0) then branch ("press BREAK")

    ; Copy all sprite data down two pages
    STA .vduTempStoreDF                                 ; tempStoreDF = workspace[sprite pages]
    LDA #0                                              ;
    STA .vduTempStoreDA                                 ; tempStoreDA = 0
    STA .vduTempStoreDC                                 ; tempStoreDC = 0
    STA .vduTempStoreDE                                 ; tempStoreDE = 0
    JSR .blockCopyMemoryIncrementing                    ;

    JMP .pressBREAK                                     ;

; ***************************************************************************************
;
; *SSPACE n
;
; Allocate space for sprites, prompting the user to press BREAK to complete the process.
;
; On Entry:
;   XY: address of the rest of the command line
;
; ***************************************************************************************
.starSSpace
    JSR .read8BitNumberIntoA                            ; read requested number of pages for sprites

    LDY #.workspaceOffsetSpritePages                    ;
    CMP (.privateWorkspaceLow),Y                        ;
    STA (.privateWorkspaceLow),Y                        ;
    PHP                                                 ; push flags

    ; Read
    DEY                                                 ; Y=#.workspaceOffsetOptions
    LDA (.privateWorkspaceLow),Y                        ;
    ASL                                                 ; carry = flood enabled
    LDA #$80                                            ; }
    ROL                                                 ; }
    ROL                                                 ; } A=1 (if flood is disabled) or 3 (flood enabled)
    ADC .vduTempStoreDE                                 ;
    DEY                                                 ;
    STA (.privateWorkspaceLow),Y                        ;
    PLP                                                 ; pull flags
    BCS +                                               ; if(new space >= old space) then branch
    JSR .starSNew                                       ; clear existing sprites
+
    JMP .pressBREAK                                     ; wait for BREAK key

; ***************************************************************************************
;
; *SNEW
;
; Clear all sprites
;
; ***************************************************************************************
.starSNew
    LDY #.workspaceOffsetNumberOfSprites                ;
    LDA #0                                              ;
    STA (.privateWorkspaceLow),Y                        ; set number of sprites to zero
.resetCurrentSpriteAddress
    LDY #.workspaceOffsetCurrentSpriteAddressLow        ; }
    LDA #0                                              ; }
    STA (.privateWorkspaceLow),Y                        ; } set current sprite address to zero
    INY                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }
    RTS                                                 ;

; ***************************************************************************************
;
; Generate error
;
; Copy the error details into page 1 along with a BRK instruction. Call it to generate
; an error.
;
; ***************************************************************************************
.generateError
    PLA                                                 ; }
    STA .vduTempStoreDA                                 ; }
    PLA                                                 ; } store the 'return address-1' in temp store
    STA .vduTempStoreDB                                 ; }
    LDY #0                                              ; loop counter

-
    INY                                                 ; store the error details at $0101 upwards
    LDA (.vduTempStoreDA),Y                             ;
    STA .page1Start,Y                                   ;
    BNE -                                               ;

    STA .page1Start                                     ; store zero at $0100, which is a BRK instruction
    JMP .page1Start                                     ; jump to the BRK instruction

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 11: Shared PLOT subroutines and tables
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Byte mask table
;
; This table stores masks for setting the rightmost pixels of a byte in each MODE.
;
; ***************************************************************************************
.plotByteMaskTable
    !byte %11111111                                     ; 2 pixels per byte (MODE 2)
    !byte %01010101                                     ;

    !byte %11111111                                     ; 4 pixels per byte (MODE 1 or 5)
    !byte %01110111                                     ;
    !byte %00110011                                     ;
    !byte %00010001                                     ;

    !byte %11111111                                     ; 8 pixels per byte (MODE 0 or 4)
    !byte %01111111                                     ;
    !byte %00111111                                     ;
    !byte %00011111                                     ;
    !byte %00001111                                     ;
    !byte %00000111                                     ;
    !byte %00000011                                     ;
    !byte %00000001                                     ;

; ***************************************************************************************
;
; Default patterns
;
; Each MODE has four patterns, each pattern is eight bytes. These are the default patterns
; for each MODE.
;
; See pattern.png
;
; ***************************************************************************************
.defaultPatterns
    ; MODE 4 patterns
    !byte %10101010                                     ; one dot in four
    !byte %00000000                                     ;
    !byte %10101010                                     ;
    !byte %00000000                                     ;
    !byte %10101010                                     ;
    !byte %00000000                                     ;
    !byte %10101010                                     ;
    !byte %00000000                                     ;

    !byte %10101010                                     ; checkerboard
    !byte %01010101                                     ;
    !byte %10101010                                     ;
    !byte %01010101                                     ;
    !byte %10101010                                     ;
    !byte %01010101                                     ;
    !byte %10101010                                     ;
    !byte %01010101                                     ;

    !byte %11111111                                     ; three dots in four
    !byte %01010101                                     ;
    !byte %11111111                                     ;
    !byte %01010101                                     ;
    !byte %11111111                                     ;
    !byte %01010101                                     ;
    !byte %11111111                                     ;
    !byte %01010101                                     ;

    !byte %00010001                                     ; diagonal stripes
    !byte %00100010                                     ;
    !byte %01000100                                     ;
    !byte %10001000                                     ;
    !byte %00010001                                     ;
    !byte %00100010                                     ;
    !byte %01000100                                     ;
    !byte %10001000                                     ;

    ; MODE 1 and 5 patterns
    !byte $A5,$0F,$A5,$0F,$A5,$0F,$A5,$0F               ; one dot in four is colour 2, the rest are colour 1
    !byte $A5,$5A,$A5,$5A,$A5,$5A,$A5,$5A               ; checkerboard colour 1 and 2
    !byte $F0,$5A,$F0,$5A,$F0,$5A,$F0,$5A               ; three dots in four are colour 2, the other is colour 1
    !byte $F5,$FA,$F5,$FA,$F5,$FA,$F5,$FA               ; checkerboard colour 2 and 3

    ; MODE 2 patterns
    !byte $0B,$07,$0B,$07,$0B,$07,$0B,$07               ; checkerboard colour 1 and 2
    !byte $23,$13,$23,$13,$23,$13,$23,$13               ; checkerboard colour 1 and 5
    !byte $0E,$0D,$0E,$0D,$0E,$0D,$0E,$0D               ; checkerboard colour 3 and 2
    !byte $1F,$2F,$1F,$2F,$1F,$2F,$1F,$2F               ; checkerboard colour 3 and 7

    ; MODE 0 Patterns
    !byte $CC,$00,$CC,$00,$CC,$00,$CC,$00               ; one dot in four
    !byte $CC,$33,$CC,$33,$CC,$33,$CC,$33               ; checkerboard
    !byte $FF,$33,$FF,$33,$FF,$33,$FF,$33               ; three dots in four
    !byte $03,$0C,$30,$C0,$03,$0C,$30,$C0               ; diagonal stripes

; ***************************************************************************************
;
; Pixel shape
;
; Pixel shape is based on the current MODE, and defines the relative width and height
; of a pixel.
;
; Used when drawing a circle to make sure we increment appropriately for the screen resolution:
;   MODE 0 has half width pixels, since there is twice as much X resolution than MODE 1
;   MODE 1 and 4 are regular square pixels
;   MODE 2 and 5 are double width (wide pixels)
; ***************************************************************************************
.pixelShapeForMODE
    ; MODE  0,  1,  2,  3,  4,  5,  6,  7
    !byte $02,$00,$01,$FF,$00,$01,$FF,$FF               ; indexed by screen MODE
                                                        ; pixel shape compared to the square pixels of MODE 1:
                                                        ;   bit 0 set = double width
                                                        ;   bit 1 set = half width
                                                        ;   $FF = non-graphics mode
                                                        ; [NOTE: bytes 6,7 could be removed]

; ***************************************************************************************
;
; Fill row
;
; Copies the left and right X coordinates and a Y coordinate, then set graphics colour
; masks and fills the row.
;
; On Entry:
;       X = offset into VDU variables for one extreme graphics pixel X coordinate and Y coordinate
;       Y = offset into VDU variables for the other extreme graphics pixel X coordinate
;
; ***************************************************************************************
.copyCoordinatesSetMasksAndFillRow
    ; Copy two bytes at vdu[Y,Y+1] to .vduOldGraphicsCursorPixelsX
    LDA .vduVariablesStart + 0,Y                        ;
    STA .vduOldGraphicsCursorPixelsXLow                 ;
    LDA .vduVariablesStart + 1,Y                        ;
    STA .vduOldGraphicsCursorPixelsXHigh                ;

    ; Copy two bytes at vdu[X+2,X+3] to .vduOldGraphicsCursorPixelsY
    LDA .vduVariablesStart + 2,X                        ;
    STA .vduOldGraphicsCursorPixelsYLow                 ;
    LDA .vduVariablesStart + 3,X                        ;
    STA .vduOldGraphicsCursorPixelsYHigh                ;

    ; vdu[Y] is one extreme X coordinate
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart ;
    ; fall through...

; ***************************************************************************************
;
; Set graphics colour masks and fill row
;
; On Entry:
;       X: offset into VDU variables for one extreme graphics pixel X coordinate
;       Y: offset into VDU variables for the other extreme graphics pixel X coordinate
;
; ***************************************************************************************
.setMasksAndFillRow
    STY .vduTempStoreDE                                 ; remember Y
    LDA .vduVariablesStart + 2,X                        ; } get Y coordinate
    EOR #7                                              ; }
    AND #7                                              ; } Y = offset within cell
    TAY                                                 ; }
    JSR .gxrSetGraphicsColourMasks                      ;
    LDY .vduTempStoreDE                                 ; recall Y
    JMP .fillRow                                        ; calls OS routine to fill the row

; ***************************************************************************************
;
; Check the given point is within the graphics window, and if so plot it
;
; On Entry:
;   X: offset into VDU variables for a point
;
; ***************************************************************************************
.plotPointXInternal
    JSR .gxrCheckInBoundsThenSetScreenAddressAndSetGraphicsColourMask ;
    BNE .return3                                        ; if (out of bounds) then return
    JMP .plotPointWithinBoundsAtY                       ; plot point

.return3
    RTS                                                 ;

; ***************************************************************************************
;
; Prepare to read or write a pixel
;
; Check the point is in the graphics window, if so get the screen address and set the
; colour masks.
;
; On Entry:
;   X: offset into VDU variables for a point
;
; On Exit:
;   Z set if inside graphics window
;   Z clear otherwise
;
; ***************************************************************************************
.gxrCheckInBoundsThenSetScreenAddressAndSetGraphicsColourMask
    JSR .checkPointXIsWithinGraphicsWindow              ;
    BNE .return3                                        ; failure, return with Z flag clear

.gxrSetScreenAddressAndSetGraphicsColourMask
    JSR .setScreenAddress                               ;

.gxrSetGraphicsColourMasks
    LDA .fillPattern,Y                                  ; fill pattern byte (Y is the vertical offset 0-7 within cell)
    PHA                                                 ;
    ORA .gcolModeMask0                                  ;
    EOR .gcolModeMask1                                  ;
    STA .vduGraphicsColourByteOR                        ;
    PLA                                                 ;
    ORA .gcolModeMask2                                  ;
    EOR .gcolModeMask3                                  ;
    STA .vduGraphicsColourByteEOR                       ;
    LDA #0                                              ; success, return with Z flag set
    RTS                                                 ;

; ***************************************************************************************
;
; Table of routines that handle PLOT commands
;
; ***************************************************************************************
.plotTypeRoutineTable
    !word .plotLine                       ;   0  |  Line: Both ends, no pattern
    !word .plotLine                       ;   2  |  Line: End omitted, no pattern
    !word .plotLine                       ;   4  |  Line: Both ends, pattern restarts
    !word .plotLine                       ;   6  |  Line: End omitted, pattern restarts
    !word .plotLine                       ;   8  |  Line: Start omitted, no pattern
    !word .plotLine                       ;  10  |  Line: Neither end, no pattern
    !word .plotLine                       ;  12  |  Line: Start omitted, pattern continues
    !word .plotLine                       ;  14  |  Line: Neither end, pattern continues
    !word .plotPoint                      ;  16  |  Plot single point
    !word .plotHorizontalFillLRToNonBg    ;  18  |  Horizontal fill left and right to non-background colour
    !word .plotTriangleFilled             ;  20  |  Fill a triangle
    !word .plotHorizontalFillRToBg        ;  22  |  Horizontal fill right to background colour
    !word .plotRectangleFilled            ;  24  |  Rectangle fill
    !word .plotHorizontalFillLRToFg       ;  26  |  Horizontal fill left and right to foreground colour
    !word .plotParallelogramFilled        ;  28  |  Parallelogram fill
    !word .plotHorizontalFillRToNonFg     ;  30  |  Horizontal fill right to non-foreground colour
    !word .floodFillToNonBg               ;  32  |  Flood fill to non-background colour
    !word .floodFillToFg                  ;  34  |  Flood fill to foreground colour
    !word .plotCircleOutline              ;  36  |  Circle outline
    !word .plotCircleFilled               ;  38  |  Circle fill
    !word .plotCircleArc                  ;  40  |  Circle arc
    !word .plotCircleSegment              ;  42  |  Circle segment
    !word .plotCircleSector               ;  44  |  Circle sector
    !word .blockCopyOrMoveScreenRectangle ;  46  |  On screen rectangle copy or move
    !word .plotEllipseOutline             ;  48  |  Ellipse outline
    !word .plotEllipseFilled              ;  50  |  Ellipse fill
    !word .unknownPlot                    ;  52  |  [unused]
    !word .unknownPlot                    ;  54  |  [unused]
    !word .unknownPlot                    ;  56  |  [unused]
    !word .plotSprite                     ;  58  |  Sprite
    !word .unknownPlot                    ;  60  |  [unused]
    !word .unknownPlot                    ;  62  |  [unused]

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 12: VDU commands
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Unknown PLOT
;
; For PLOT commands we don't know about, we finish up by restoring the soft character
; definitions, then send it along for other ROMs to check.
;
; ***************************************************************************************
.unknownPlot
    JSR .copyWorkspaceCacheBackIntoCharacterDefinitons  ;
.passOnPLOT
    LDA .vdu25ParameterPlotType                         ;
    CLC                                                 ;
    JMP (.vectorVDUVLow)                                ;

; ***************************************************************************************
;
; Reset fill patterns and dot-dash line pattern
;
; Preserves A, X, Y
;
; ***************************************************************************************
.resetFillPatternsAndDotDashPattern
    PHA                                                 ; }
    TXA                                                 ; }
    PHA                                                 ; } remember A,X,Y
    TYA                                                 ; }
    PHA                                                 ; }

    JSR .resetPatternFillsToDefaults                    ;
    LDA #0                                              ;
    JSR .setDotPatternAndRepeat                         ;

    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } recall A,X,Y
    TAX                                                 ; }
    PLA                                                 ; }
    RTS                                                 ;

; ***************************************************************************************
;
; Intercepting VDU 22 (MODE change) and VDU 25 (PLOT command)
;
; The trampoline code (see Chapter 9) that intercepts OSWRCH sends VDU 22 (MODE) and VDU 25 (PLOT)
; here.
;
; On Entry:
;   Carry  set  for VDU 22 (MODE change)
;   Carry clear for VDU 25 (PLOT command)
;
;  PLOT Codes              |  Effect
; -------------------------+-------------------------------------------------------------
;  $00 - $07   ( 0 -   7)  |  Line: Both ends, no pattern
;  $08 - $0F   ( 8 -  15)  |  Line: End omitted, no pattern
;  $10 - $17   (16 -  23)  |  Line: Both ends, pattern restarts
;  $18 - $1F   (24 -  31)  |  Line: End omitted, pattern restarts
;  $20 - $27   (32 -  39)  |  Line: Start omitted, no pattern
;  $28 - $2F   (40 -  47)  |  Line: Neither end, no pattern
;  $30 - $37   (48 -  55)  |  Line: Start omitted, pattern continues
;  $38 - $3F   (56 -  63)  |  Line: Neither end, pattern continues
;  $40 - $47   (64 -  71)  |  Plot single point
;  $48 - $4F   (72 -  79)  |  Horizontal line fill left and right to non-background
;  $50 - $57   (80 -  87)  |  Fill a triangle
;  $58 - $5F   (88 -  95)  |  Horizontal line fill right to background
;  $60 - $67   (96 - 103)  |  Rectangle fill
;  $68 - $6F  (104 - 111)  |  Horizontal line fill left and right to foreground
;  $70 - $77  (112 - 119)  |  Parallelogram fill
;  $78 - $7F  (120 - 127)  |  Horizontal line fill right to non-foreground
;  $80 - $87  (128 - 135)  |  Flood fill to non-background
;  $88 - $8F  (136 - 143)  |  Flood fill to foreground
;  $90 - $97  (144 - 151)  |  Circle outline
;  $98 - $9F  (152 - 159)  |  Circle fill
;  $A0 - $A7  (160 - 167)  |  Circular arc
;  $A8 - $AF  (168 - 175)  |  Circular segment
;  $B0 - $B7  (176 - 183)  |  Circular sector
;  $B8 - $BF  (184 - 191)  |  On screen rectangle copy or move
;  $C0 - $C7  (192 - 199)  |  Ellipse outline
;  $C8 - $CF  (200 - 207)  |  Ellipse fill
;  $D0 - $D7  (208 - 215)  |  [unused]
;  $D8 - $DF  (216 - 223)  |  [unused]
;  $E0 - $E7  (224 - 231)  |  [unused]
;  $E8 - $EF  (232 - 239)  |  Sprite plot
;  $F0 - $F7  (240 - 247)  |  [unused]
;  $F8 - $FF  (248 - 255)  |  [unused]
;
; ***************************************************************************************
.vdu22Or25EntryPoint
    JSR .getPrivateWorkspaceAddress                     ; get workspace address
    BCS .resetFillPatternsAndDotDashPattern             ; if (MODE change) then branch
                                                        ; (to reset patterns and line style)

    ; PLOT
    LDX .vduPixelsPerByteMinusOne                       ;
    BEQ .passOnPLOT                                     ; if (not a graphics MODE) then branch

    ; For the duration of the PLOT command, we cache the soft font definitions from
    ; $0C00 - $0C66 into private workspace memory to give us memory at $C00 (a fixed
    ; memory location). This helps with access speed and size, and uses fewer registers
    ; than having to use indirect addressing to access our private workspace.

    ; Copy $0C00 - $0C66 into workspace[$99-$FF]
    LDA #.workspaceOffsetSoftFontCache                  ;
    STA .privateWorkspaceLow                            ;
    LDY #$66                                            ; loop counter
-
    LDA .softCharacterDefinitions,Y                     ;
    STA (.privateWorkspaceLow),Y                        ;
    DEY                                                 ;
    BPL -                                               ;

    INY                                                 ;
    STY .privateWorkspaceLow                            ; reset workspace low to zero

    LDY #.workspaceOffsetHasCachedSoftCharacterDefinitions ;
    LDA #$80                                            ;
    STA (.privateWorkspaceLow),Y                        ; mark as cached

    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; X is offset to X Coordinate (low)
    JSR .plotConvertExternalRelativeCoordinatesToPixels ;

    LDY #5                                              ; Y=5 (invalid GCOL mode)
    LDA .vdu25ParameterPlotType                         ;
    AND #$C3                                            ; check for one of (0,4,8,12,16,20,24,
                                                        ; 28,32,36,40,44,48,52,56,60)
    BEQ .setGraphicsCursorPositionAndFinishPLOT         ; if (line move relative or absolute) then branch

    AND #3                                              ; check for one of (64,68,72,76,80,84,
                                                        ; 88,92,96,100,104,108,112,116,120,124,
                                                        ; 128,132,136,140,144,148,152,156,160,
                                                        ; 164,168,172,176,180,184,188,192,196,
                                                        ; 200,204,208,212,216,220,224,228,232,
                                                        ; 236,240,244,248,252)
    BEQ .skipStandardColourModes                        ; if (move relative or absolute for a non-line) then branch

    DEY                                                 ; Y=4 (inverse colour GCOL mode)
    LSR                                                 ;
    BCC .skipStandardColourModes                        ; if (logical inverse colour) then branch

    TAX                                                 ; draw using foreground colour (X=0) or background colour (X=1)
    LDY .vduForegroundGCOLMode,X                        ; Y=foreground or background GCOL mode (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)
    LDA .vduForegroundGraphicsColour,X                  ; }
    TAX                                                 ; } X = foreground or background graphics colour

.skipStandardColourModes
    TYA                                                 ; A = GCOL mode (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)
    PHA                                                 ;

    ; Set up mask variables for the GCOL Mode
    AND #$0F                                            ; make sure it is in range (0-15)
    TAY                                                 ; Y = GCOL mode
    LDA .gcolPlotOptionsTable,Y                         ;
    STA .gcolModeMask0                                  ;
    LDA .gcolPlotOptionsTable + 1,Y                     ;
    STA .gcolModeMask1                                  ;
    LDA .gcolPlotOptionsTable - 1,Y                     ;
    STA .gcolModeMask2                                  ;
    LDA .gcolPlotOptionsTable + 4,Y                     ;
    STA .gcolModeMask3                                  ;

    PLA                                                 ; A = GCOL mode top nybble
    AND #$F0                                            ; get top nybble
    LSR                                                 ; divide by two (we get multiples of 8)
    BNE .copyPattern                                    ; if (we want to use a pattern) then branch

    ; solid colour fill
    STX .fillPattern                                    ; }
    STX .fillPattern + 1                                ; }
    STX .fillPattern + 2                                ; }
    STX .fillPattern + 3                                ; } store solid graphics colour in fillPattern
    STX .fillPattern + 4                                ; }
    STX .fillPattern + 5                                ; }
    STX .fillPattern + 6                                ; }
    STX .fillPattern + 7                                ; }
    BEQ .doneCopyingPattern                             ; ALWAYS branch

.copyPattern
    LDX #7                                              ; loop counter.
    TAY                                                 ; Y = 8,16,24,32 i.e. Y = (pattern 1 to 4) * 8
    DEY                                                 ; Y = 7,15,23,31 i.e. Y = (pattern 1 to 4) * 8 - 1
    LDA #.workspaceOffsetCurrentPatterns                ;
    STA .privateWorkspaceLow                            ;
-
    LDA (.privateWorkspaceLow),Y                        ; copy from workspace[$6C+Y]
                                                        ; pattern 1 = workspace[$6C to $73]
                                                        ; pattern 2 = workspace[$74 to $7B]
                                                        ; pattern 3 = workspace[$7C to $83]
                                                        ; pattern 4 = workspace[$84 to $8C]
    STA .fillPattern,X                                  ; copy to $0C00+X
    DEY                                                 ;
    DEX                                                 ;
    BPL -                                               ; loop 8 times

.doneCopyingPattern
    LDA .vdu25ParameterPlotType                         ; get plot type
    AND #$F8                                            ; mask out the bottom three bits

    LSR                                                 ; } divide by four to get the offset
    LSR                                                 ; } within the table of PLOT routines

    TAX                                                 ; X = offset into array
    LDA .plotTypeRoutineTable,X                         ; }
    STA .vduTempStoreDA                                 ; } get address of routine from table
    LDA .plotTypeRoutineTable + 1,X                     ; }
    STA .vduTempStoreDB                                 ; }
    JSR .getPrivateWorkspaceAddress                     ;

    JMP (.vduTempStoreDA)                               ; call routine

; ***************************************************************************************
;
; Move graphics cursor and finish PLOT command
;
; Moves the graphics cursor by a relative amount or to an absolute position.
; Also restores the soft font definitions, since this is called at the end of each PLOT
; command.
;
; ***************************************************************************************
.setGraphicsCursorPositionAndFinishPLOT

    ; Update graphics cursors:
    ;   vduOldGraphicsCursor = vduGraphicsCursor
    ;   vduGraphicsCursor    = vdu25Parameter
    LDX #3                                              ; loop counter
-
    LDA .vduGraphicsCursorPixelsXLow,X                  ; get current graphics cursor
    STA .vduOldGraphicsCursorPixelsXLow,X               ; store in old graphics cursor
    LDA .vdu25ParameterXLow,X                           ; get new parameter
    STA .vduGraphicsCursorPixelsXLow,X                  ; store in current graphics cursor
    DEX                                                 ;
    BPL -                                               ; if (still bytes to copy) then branch (loop back)

    ; Copy the soft character definitions previously stored in the private workspace using
    ; code at .vdu22Or25EntryPoint back into the original memory at $0C00.
    ; Preserves X
.copyWorkspaceCacheBackIntoCharacterDefinitons
    JSR .getPrivateWorkspaceAddress                     ;

    ; Copy memory from [workspace + $99,workspace + $FF] to [$0C00, $0C66]
    LDA #.workspaceOffsetSoftFontCache                  ;
    STA .privateWorkspaceLow                            ; start address (low)
    LDY #$66                                            ; loop counter
-
    LDA (.privateWorkspaceLow),Y                        ;
    STA .softCharacterDefinitions,Y                     ;
    DEY                                                 ;
    BPL -                                               ;

    INY                                                 ; Y = 0
    STY .privateWorkspaceLow                            ; workspaceLow = 0
    TYA                                                 ; A = 0
    LDY #.workspaceOffsetHasCachedSoftCharacterDefinitions ;
    STA (.privateWorkspaceLow),Y                        ; mark as not cached
    RTS                                                 ;

; ***************************************************************************************
.vdu23SChooseOrSGet
    LDA .vdu23NParameter                                ;
    BNE .vdu23SGet                                      ;

    ; Handle 'SChoose'
    LDA .vdu23SChooseOrSGetSpriteNumberParameter        ;
    JMP .sChooseA                                       ;

.vdu23SGet
    ; Check for 'SGet'
    CMP #1                                              ;
    BNE .vdu23Unknown                                   ;

    ; Handle 'SGet'
    LDA .vdu23SChooseOrSGetSpriteNumberParameter        ;
    JMP .sgetInternal                                   ;

.vdu23Unknown
    LDA #27                                             ; VDU 27 = do nothing
    JMP .passThroughWithCarrySet                        ;

; ***************************************************************************************
;
; Extended Vector VDU Routine
;
; When a VDU sequence that is unknown to the OS is used, this routine executes allowing
; our code to process new VDU functionality.
;
; ***************************************************************************************
.extendedVectorVDURoutine
    JSR .getPrivateWorkspaceAddress                     ;
    BCC .passThrough                                    ; if (already handled) then branch

    LDX .vduPixelsPerByteMinusOne                       ;
    BEQ .passThroughWithCarrySet                        ; if (non-graphics mode) then branch
    CMP #6                                              ; check for VDU 23,6 = dot-dash line
    BEQ .defineDotDashLine                              ; if (dot-dash line) then branch
    BCC .defineFullPattern                              ; if (full pattern) then branch

    CMP #11                                             ;
    BCC .passThroughWithCarrySet                        ; if (A < 11) then branch
    BEQ .resetPatternFillsToDefaults                    ; if (VDU 23,11) then branch

    CMP #16                                             ; check for VDU 23,{12 to 15}
    BCC .defineSimplePattern                            ; if (simple pattern) then branch

    CMP #27                                             ;
    BEQ .vdu23SChooseOrSGet                             ; if (VDU 23,27) then branch
    ; fall through...

.passThroughWithCarrySet
    SEC                                                 ; carry set means 'not yet handled'
.passThrough
    PHP                                                 ;
    PHA                                                 ;
    JSR .swapWorkspaceWithVDUVectors                    ; swap out our VDUV

    PLA                                                 ;
    PLP                                                 ;
    JSR .jumpToVDURoutine                               ; execute original VDU routine

    PHA                                                 ;
    JSR .swapWorkspaceWithVDUVectors                    ; swap back in our VDUV

    PLA                                                 ;
    RTS                                                 ;

.jumpToVDURoutine
    JMP (.vectorVDUVLow)                                ;

; ***************************************************************************************
;
; Define a dot-dash line pattern
;
; The line pattern is an array of (up to) 64 on / off bits (8 bytes)
;
; See dot2.png
;
;  10 REM dotted border
;  20 MODE 1:VDU23,6,&54,&48,&3F,&A9,&26,&BB,&C3,&9D
;  30 *FX163,242,64
;  40 T%=&35:SX%=16:SY%=16
;  50 FOR N%=0 TO 2
;  60   MOVE 100+N%*SX%,100+N%*SY%
;  70   PLOT T%,1180-N%*SX%,100+N%*SY%
;  80   PLOT T%,1180-N%*SX%,924-N%*SY%
;  90   PLOT T%,100+N%*SX%,924-N%*SY%
; 100   PLOT T%,100+N%*SX%,100+N%*SY%
; 110 NEXT
; 120 VDU 23,1,0;0;0;0;:A$=GET$:VDU 23,1,1;0;0;0;
;
; ***************************************************************************************
.defineDotDashLine
    PHA                                                 ;
    LDY #.workspaceOffsetDotDashRepeatLength            ;
    LDA (.privateWorkspaceLow),Y                        ;
    INY                                                 ; workspace[dot-dash bits remaining] =
    STA (.privateWorkspaceLow),Y                        ; dot-dash line pattern bits remaining
    INY                                                 ;
    LDA #$80                                            ;
    STA (.privateWorkspaceLow),Y                        ; workspace[dot-dash bit] = $80
                                                        ; i.e. one bit set for reading next bit from pattern
    INY                                                 ;
    ASL                                                 ; workspace[pattern byte] = current byte
    STA (.privateWorkspaceLow),Y                        ; within dot-dash line pattern
    PLA                                                 ;
.defineFullPattern
    SEC                                                 ; A = 2,3,4,5,6 (2-5 = full pattern, 6 = dot-dash line pattern)
    SBC #1                                              ;
    ASL                                                 ;
    ASL                                                 ;
    ASL                                                 ;
    ADC #.workspaceOffsetCurrentPatterns                ;
    TAY                                                 ;
    DEY                                                 ; Y = ((A-1)*8) + .workspaceOffsetCurrentPatterns - 1
                                                        ; Y = $73,$7B,$83,$8B,$93
    ; [NOTE: Could do this to save three bytes:
    ; ASL
    ; ASL
    ; ASL
    ; CLC
    ; ADC #.workspaceOffsetCurrentPatterns - 9
    ; TAY
    ; ]

    LDX #7                                              ;
-
    LDA .vdu23NParameter,X                              ; }
    STA (.privateWorkspaceLow),Y                        ; }
    DEY                                                 ; } copy vdu parameters into the workspace pattern
    DEX                                                 ; }
    BPL -                                               ; }
    RTS                                                 ;

; ***************************************************************************************
;
; Reset all fill patterns
;
; ***************************************************************************************
.resetPatternFillsToDefaults
    LDA .vduCurrentScreenMODE                           ;
    BNE +                                               ; if (not MODE 0) then branch

    SEC                                                 ;
    SBC #1                                              ; A = $FF [NOTE: could just LDA #255 to save a byte]
+
    AND #3                                              ; (MODE 0,1,2,3,4,5,6,7) AND 3 = (3,1,2,X,0,1,X,X)
    CLC                                                 ;
    ADC #1                                              ; (A AND 3) + 1 = (4,2,3,X,1,2,X,X)
    ASL                                                 ;
    ASL                                                 ;
    ASL                                                 ;
    ASL                                                 ;
    ASL                                                 ; ((A AND 3) + 1) * 32, i.e.
                                                        ; MODE    0,   1,   2, 3,   4,   5, 6, 7
                                                        ;    A  $80, $40, $60, -, $20, $40, -, -
    TAX                                                 ; X is the offset to the default patterns for the current MODE

; [NOTE: alternatively this is seven bytes shorter:
;
; .offsetToDefaultTable
;    !byte $80, $40, $60, $00, $20, $40
;
; .resetPatternFillsToDefaults
;    LDY .vduCurrentScreenMODE
;    LDX .offsetToDefaultTable,Y
;    ...
; ]

    ; Copy the default patterns into the right place in the private workspace
    LDY #32                                             ; loop counter
    LDA #.workspaceOffsetCurrentPatterns - 1            ; offset in workspace to store current patterns (minus 1)
    STA .privateWorkspaceLow                            ; .privateWorkspaceLow = .workspaceOffsetCurrentPatterns - 1
-
    LDA .defaultPatterns - 1,X                          ; read default patterns from table
    STA (.privateWorkspaceLow),Y                        ; store 32 bytes of default patterns in workspace at offset $6B-$8A
    DEX                                                 ;
    DEY                                                 ;
    BNE -                                               ;
    RTS                                                 ;

; ***************************************************************************************
;
; Define simple fill pattern
;
; On Entry:
;   A: pattern number 12-15
;   carry clear
;
; ***************************************************************************************
.defineSimplePattern
    SBC #11                                             ; A = 0-3
    ASL                                                 ;
    ASL                                                 ;
    ASL                                                 ;
    ADC #3                                              ; A = 3,11,19,27
                                                        ; (offset to store within workspace patterns)
                                                        ; [NOTE: Could be ASL:ASL:ASL:SBC #32 to save 2 bytes]
    PHA                                                 ;

    ; Loop to get and mask colour information for current mode
    LDX #7                                              ;
-
    LDA .vdu23NParameter,X                              ;
    AND .vduNumberOfLogicalColoursMinusOne              ;
    STA .vduTempStoreDA                                 ; DA = parameter[X] AND numColours-1
    LDA .vduNumberOfLogicalColoursMinusOne              ; }
    AND #7                                              ; }
    ADC .vduTempStoreDA                                 ; } DA += number of colours - 1
    TAY                                                 ; }
    LDA .twoColourMODEParameterTable - 1,Y              ; look up colour data in table
    STA .vdu23NParameter,X                              ; parameter[X] = colour data
    DEX                                                 ; decrement loop counter
    BPL -                                               ; if(not done yet) then branch (loop back)

    ; Single or double pixels
    LDA #%01010101                                      ;
    LDX .vduCurrentScreenMODE                           ;
    BNE +                                               ;
    LDA #%00110011                                      ; MODE 0 uses double pixels
+
    STA .vduTempStoreDA                                 ; store mask

    PLA                                                 ; A = 3,11,19,27
    CLC                                                 ;
    ADC #.workspaceOffsetCurrentPatterns                ; A = offset to store pattern within workspace
    TAY                                                 ; Y = A = offset to store pattern within workspace

    ; Loop to set simple pattern
    LDX #7                                              ; loop counter, decrements twice (7,5,3,1)
-
    LDA .vdu23NParameter,X                              ; pixel value
    DEX                                                 ; decrement loop counter
    EOR .vdu23NParameter,X                              ; EOR previous pixel value
    AND .vduTempStoreDA                                 ; AND mask
    EOR .vdu23NParameter,X                              ; EOR previous pixel value
    STA (.privateWorkspaceLow),Y                        ;
    INY                                                 ; }
    INY                                                 ; }
    INY                                                 ; }
    INY                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; } workspace[Y] = A
    DEY                                                 ; } workspace[Y+4] = A
    DEY                                                 ; } Y--
    DEY                                                 ; }
    DEY                                                 ; }
    DEY                                                 ; }
    DEX                                                 ; decrement loop counter
    BPL -                                               ; if (not done yet) then branch (loop back)
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 13: Sprite editor block memory copy
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Used when copying sprite data
;
; Copy tempStoreDE/DF bytes from tempStoreDC/DD to tempStoreDA/DB
; This works if the blocks overlap, but only if DA/DB >= DC/DD
;
; ***************************************************************************************
.blockCopyMemoryIncrementing
    LDY #0                                              ;
.loopCopyBytesInc
    LDA (.vduTempStoreDC),Y                             ; }
    STA (.vduTempStoreDA),Y                             ; } copy byte
    JSR .incTempStoreDADB                               ;
    JSR .incTempStoreDCDD                               ;

    LDA .vduTempStoreDE                                 ; }
    BNE +                                               ; }
    DEC .vduTempStoreDF                                 ; } DE/DF -= 1
+                                                       ; }
    DEC .vduTempStoreDE                                 ; }

    LDA .vduTempStoreDE                                 ;
    ORA .vduTempStoreDF                                 ;
    BNE .loopCopyBytesInc                               ; if (DE/DF != 0) then branch

    RTS                                                 ;

; ***************************************************************************************
;
; Used when copying sprite data
;
; Copy tempStoreDE/DF bytes from tempStoreDC/DD to tempStoreDA/DB
; This works if the blocks overlap, but only if DA/DB <= DC/DD
;
; ***************************************************************************************
.blockCopyMemoryDecrementing
    CLC                                                 ; }
    LDA .vduTempStoreDE                                 ; }
    ADC .vduTempStoreDA                                 ; }
    STA .vduTempStoreDA                                 ; } DA/DB += DE/DF
    LDA .vduTempStoreDF                                 ; }
    ADC .vduTempStoreDB                                 ; }
    STA .vduTempStoreDB                                 ; }

    LDA .vduTempStoreDE                                 ; }
    ADC .vduTempStoreDC                                 ; }
    STA .vduTempStoreDC                                 ; } DC/DD += DE/DF
    LDA .vduTempStoreDF                                 ; }
    ADC .vduTempStoreDD                                 ; }
    STA .vduTempStoreDD                                 ; }

    LDY #0                                              ;
.loopCopyBytesDec
    JSR .decTempStoreDADB                               ;
    JSR .decTempStoreDCDD                               ;

    LDA (.vduTempStoreDC),Y                             ; }
    STA (.vduTempStoreDA),Y                             ; } copy byte

    LDA .vduTempStoreDE                                 ; }
    BNE +                                               ; }
    DEC .vduTempStoreDF                                 ; } DE/DF -= 1
+                                                       ; }
    DEC .vduTempStoreDE                                 ; }

    LDA .vduTempStoreDE                                 ;
    ORA .vduTempStoreDF                                 ;
    BNE .loopCopyBytesDec                               ; if (DE/DF != 0) then branch (loop back)
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 14: Point and Rectangle
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Plot a point
;
; ***************************************************************************************
.plotPoint
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ;
    JSR .plotPointXInternal                             ;
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Plot a filled rectangle
;
; Rectangle axis aligned, defined by the bottom left and top right corner points.
;
; See squares.png
;
; ***************************************************************************************
.plotRectangleFilled
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; PLOT point
    JSR .sortCoordinatesAsBottomLeftAndTopRight         ;
    JSR .plotRectangleInternal                          ;
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Plot a filled rectangle with already sorted coordinates
;
; [NOTE: This doesn't clip to graphics window before filling, so the biggest rectangle
;        takes 3.8 seconds:
;
;       MODE 1:GCOL0,1:MOVE-32768,-32768:PLOT &65,32767,32767
; ]
;
; On Entry:
;       .vduWorkspaceAB is left   coordinate of rectangle
;       .vduWorkspaceCD is top    coordinate of rectangle
;       .vduWorkspaceEF is right  coordinate of rectangle
;       .vduWorkspaceGH is bottom coordinate of rectangle
;
; ***************************************************************************************
.plotRectangleInternal
    LDX #.vduWorkspaceC - .vduVariablesStart            ;
    LDY #.vduWorkspaceG - .vduVariablesStart            ; swap CD and GH (swaps top and bottom coordinates)
    JSR .exchangeTwoVDUBytes                            ;

.rectangleFilledLoop
    ; Fill row CD from left X coordinate AB to right X coordinate EF
    LDX #.vduWorkspaceA - .vduVariablesStart            ; one X coordinate
    LDY #.vduWorkspaceE - .vduVariablesStart            ; other X Coordinate
    JSR .copyCoordinatesSetMasksAndFillRow              ; fill one row

    ; Move down a row
    LDA .vduWorkspaceC                                  ; }
    BNE +                                               ; }
    DEC .vduWorkspaceD                                  ; } CD -= 1
+                                                       ; }
    DEC .vduWorkspaceC                                  ; }

    ; Check if we are done
    LDA .vduWorkspaceC                                  ; }
    CMP .vduWorkspaceG                                  ; }
    LDA .vduWorkspaceD                                  ; } compare CD with GH
    SBC .vduWorkspaceH                                  ; }
    BPL .rectangleFilledLoop                            ; } if (CD >= GH) then branch back
    RTS                                                 ;

; ***************************************************************************************
;
; Sort the coordinates of a given point and the current graphics cursor position
;
; This results in a bottom left point and top right point.
;
; On Entry:
;   X = offset to given point
;
; ***************************************************************************************
.sortCoordinatesAsBottomLeftAndTopRight
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart  ;
    JSR .gxrSortPointsXY                                ; sort graphics cursor and current coordinate

    ; Now X,Y are offsets to the topmost and bottommost points respectively

    TYA                                                 ; }
    PHA                                                 ; } store topmost point
    TXA                                                 ; }
    PHA                                                 ; } store bottommost point

    JSR .sortCoordinatesXYByColumn                      ; set X = leftmost point, Y = rightmost point

    ; Now X,Y are the leftmost and rightmost points respectively
    PLA                                                 ; recall the bottommost point
    STA .gxrScratchspace3                               ; store in scratchspace the bottommost point
    TYA                                                 ;
    PHA                                                 ; push the rightmost point
    LDA .gxrScratchspace3                               ; get the bottommost point
    LDY #.vduWorkspaceA - .vduVariablesStart            ;
    JSR .copyTwoCoordinatesToY                          ; copy the leftmost point and the bottommost point
    PLA                                                 ;
    TAX                                                 ; X = rightmost point
    PLA                                                 ; A = topmost point

    ; Copy two bytes from X to Y
    ; Copy two bytes from A + 2 to Y
.copyTwoCoordinatesToY
    PHA                                                 ; remember A
    JSR .copyTwoBytesWithinVDUVariables                 ;
    PLA                                                 ; recall A
    TAX                                                 ;
    INX                                                 ;
    INX                                                 ;
    JMP .copyTwoBytesWithinVDUVariables                 ;

; ***************************************************************************************
;
; Set a pattern (or a solid colour from the current foreground or background colour)
;
; Stored in the eight bytes at $0C17-$0C1E
;
; On Entry:
;       X = 0 for foreground
;       X = 1 for background
; On Exit:
;       gxrCurrentPattern[0...7] holds the pattern
;
; ***************************************************************************************
.setupCurrentPattern
    LDA .vduForegroundGCOLMode,X                        ; get foreground / background GCOL mode
    AND #$F0                                            ; get top bits (pattern number)
    LSR                                                 ; as multiples of 8 (and clears carry)
    BNE .copyCurrentPattern                             ;

    ; Copy solid foreground/background colour into current pattern
    LDY #7                                              ; loop counter
    LDA .vduForegroundGraphicsColour,X                  ;
-
    STA .gxrCurrentPattern,Y                            ;
    DEY                                                 ;
    BPL -                                               ;
    RTS                                                 ;

.copyCurrentPattern
    ; Copy pattern from private workspace into current pattern memory
    ADC #.workspaceOffsetCurrentPatterns - 1            ;
    TAY                                                 ;
    JSR .getPrivateWorkspaceAddress                     ;

    LDX #7                                              ;
-
    LDA (.privateWorkspaceLow),Y                        ; read from pattern
    STA .gxrCurrentPattern,X                            ; store in current pattern
    DEY                                                 ;
    DEX                                                 ;
    BPL -                                               ;
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 15: Parallelogram and Triangle
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Plot a filled parallelogram and finish PLOT
;
; see para.png
;
; ***************************************************************************************

; ***************************************************************************************
.plotParallelogramFilled
    JSR .plotParallelogramInternal                      ;
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Plot a filled triangle and finish PLOT
;
; Triangles are reimplemented here to add the fill pattern ability. It also fixes some questionable
; rasterisation of the original OS routine. In particular, the following triangle draws a better
; base edge with GXR enabled than without:
;
;     10 MODE 2
;     20 MOVE 119*8,72*4
;     30 MOVE 40*8,71*4
;     40 PLOT 85,80*8,111*4
;
; Note that the left vertex is one pixel lower than the right vertex. This example is from the roof
; of the Witch's House from the game Citadel (See http://www.bbcmicro.co.uk/game.php?id=290 ).
;
; Firstly the regular MOS triangle routine:
; See witch_mos.png
;
; Secondly the GXR triangle routine:
; See witch_gxr.png
;
; ***************************************************************************************
.plotTriangleFilled
    JSR .plotTriangleInternal                           ;
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Plots a filled parallelogram
;
;   Specified by three vertices of the parallelogram:
;       - old graphics cursor position
;       - current graphics cursor position
;       - plot parameter point
;   The fourth vertex is calculated from these three.
;   The four vertices are sorted from the bottom up.
;
;   Drawn from the bottom up in three parts:
;
;       1. Bottom triangle      (with flat top edge)
;       2. Centre parallelogram (with flat top and bottom edges)
;       3. Top triangle         (with flat bottom edge)
;
; e.g.
;                                                                    #####  <--- workspaceABCD
;                                                                ####    #
;                                                            ####        #
;                                                        ####           #
;                                                    ####               #
;                                                ####                  #
;                                            ####                      #
;                                        ####                         #
;                                    ####                3.           #
;                                ####                                #
;                            ####                                    #
;     old graphics --->  ####---------------------------------------#
;           cursor      #                                           #
;                       #                                          #
;                      #                     2.                    #
;                      #                                          #
;                     #---------------------------------------####  <--- PLOT parameter
;                     #                                   ####
;                    #                                ####
;                    #                            ####
;                   #            1.           ####
;                   #                     ####
;                  #                  ####
;                  #              ####
;                 #           ####
;                 #       ####
;                #    ####
; graphics --->  #####
;   cursor
;
; ***************************************************************************************
.plotParallelogramInternal
    LDX #1                                              ; loop counter
    LDY #0                                              ;

    ; This calculates the fourth vertex of the parallelogram from the other three:
    ; workspaceABCD = PLOT parameter - graphics cursor + old graphics cursor
    ;
    ; Loops twice, first with Y=0 (X coordinate) and then with Y=2 (Y coordinate)
-
    SEC                                                 ; }
    LDA .vdu25ParameterXLow,Y                           ; }
    SBC .vduGraphicsCursorPixelsXLow,Y                  ; }
    STA .vduWorkspaceA,Y                                ; } workspaceAB = PLOT param - graphics cursor
    LDA .vdu25ParameterXHigh,Y                          ; }
    SBC .vduGraphicsCursorPixelsXHigh,Y                 ; }
    STA .vduWorkspaceB,Y                                ; }

    CLC                                                 ; }
    LDA .vduWorkspaceA,Y                                ; }
    ADC .vduOldGraphicsCursorPixelsXLow,Y               ; }
    STA .vduWorkspaceA,Y                                ; } workspaceAB += old graphics cursor
    LDA .vduWorkspaceB,Y                                ; }
    ADC .vduOldGraphicsCursorPixelsXHigh,Y              ; }
    STA .vduWorkspaceB,Y                                ; }
    LDY #2                                              ;
    DEX                                                 ;
    BPL -                                               ;

    ; The next code sorts the four points of the parallelogram vertically:
    ;
    ; XY = SORT(old, current)
    ; .gxrTemp1 = X                  .gxrTemp1 is the index to the smaller Y coordinate of
    ;                                 old and current, Yreg is the larger
    ; XY = SORT(param, Y)
    ; .gxrTemp2 = X                  .gxrTemp2 is the index to the smaller Y coordinate of
    ;                                 param and Yreg, Yreg is the larger
    ; XY = SORT(workspaceA, Y)
    ; .gxrTemp4 = Y                  .gxrTemp4 is the index to the larger Y coordinate of
    ;                                 workspaceA and Yreg
    ; XY = SORT(gxrTemp2, X)
    ; .gxrTemp3 = Y                  .gxrTemp3 is the index to the larger Y coordinate of
    ;                                .gxrTemp2 and Xreg
    ; Y = .gxrTemp1
    ; then calls .sortThreePointsAndPlotFlatEdgedTriangle which completes the process using two
    ; more SORT calls.
    ;
    ; [NOTE: For fewer comparisons (i.e. using 5 SORT calls total instead of 6),
    ;        see https://stackoverflow.com/questions/6145364/sort-4-number-with-few-comparisons ]

    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; } sort positions X and Y
    LDX #.vduGraphicsCursorPixelsXLow    - .vduVariablesStart   ; } so that X is the offset to
    JSR .gxrSortPointsXY                                        ; } the point with the
    STX .gxrTemp1                                       ; } smallest Y coordinate

    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; }
    JSR .gxrSortPointsXY                                ; }
    STX .gxrTemp2                                       ; }

    LDX #.vduWorkspaceA - .vduVariablesStart            ; }
    JSR .gxrSortPointsXY                                ; }
    STY .gxrTemp4                                       ; }

    LDY .gxrTemp2                                       ; }
    JSR .gxrSortPointsXY                                ; }
    STY .gxrTemp3                                       ; }

    ; Step 1. Draw bottom triangle (with flat top edge)
    LDY .gxrTemp1                                       ; }
    JSR .sortThreePointsAndPlotFlatEdgedTriangle        ;

    ; Step 2. Draw centre parallelogram (with flat top and bottom edges)
    LDA .gxrTemp4                                       ;
    STA .gxrScratchspace1                               ;
    LDX #.line2StartPointX - .vduVariablesStart         ;
    JSR .lineInitialisation                             ;

    ; The line initialisation sets up line 2 variables:
    ;    .line2StartPointX: initial and current point X [2 bytes]
    ;    .line2StartPointY: initial and current point Y [2 bytes]
    ;    .line2AbsDeltaX  : abs(deltaX)                 [2 bytes]
    ;    .line2AbsDeltaY  : abs(deltaY)                 [2 bytes]
    ;    .line2ErrorTerm  : Bresenham error term        [2 bytes]
    ;    .line2Signs      : signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

    LDY .gxrScratchspace2                               ; middle point
    JSR .drawFlatParallelogram                          ;

    ; Step 3. Draw top triangle (with flat bottom edge)
    LDY .gxrTemp3                                       ;
    LDA .gxrTemp4                                       ;
    STA .gxrScratchspace2                               ;
    LDX #.line3StartPointX - .vduVariablesStart         ;
    JSR .drawFlatBasedTriangleInternal                  ;

    ; Draw final row
    JMP .fillTriangleRowFromLeftToRight                 ;

; ***************************************************************************************
;
; Plot a filled triangle
;
; Triangles are drawn in two halves. First from the bottom to the middle point with a flat
; edge. Then from the flat middle edge up to the peak at the top.
;
;
;                                            -- <- top point
;                                          ---
;                                        --  -
;                       minor line ->  --   -
;                                    --     -
;                                  --second-
;                                --   half -
;                              --         -
;             middle point -> #############
;                              #         #
;                              #  first  #   <- main line ('line 3')
;                               #  half #    goes all the way to the top point
;                               #       #
;                                #     #
;                 minor line ->  #     #
;                                 #   #
;                                 #   #
;                                  # #
;                                  # #
;                                   #
;                                   #  <- bottom point
;
; ***************************************************************************************
.plotTriangleInternal
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; }
    LDX #.vduGraphicsCursorPixelsXLow    - .vduVariablesStart   ; } sort positions by Y then X
    JSR .gxrSortPointsXY                                        ;

    STY .gxrTemp3                                               ;
    LDY #.vdu25ParameterXLow - .vduVariablesStart               ; draw bottom half from lowest
    JSR .sortThreePointsAndPlotFlatEdgedTriangle                ; point up to the flat base

    LDA .gxrTemp3                                               ; top point
    JSR .drawFlatBasedTriangle                                  ; draw top half from the flat base to top point
    ; fall through... (to draw final row)

; ***************************************************************************************
.fillTriangleRowFromLeftToRight
    LDY #.triangleRowLeftPointX - .vduVariablesStart    ;
    LDX #.triangleRowRightPointX - .vduVariablesStart   ;
    JMP .setMasksAndFillRow                             ;

; ***************************************************************************************
;
; Sorts three points, then plots a triangle with a flat top or bottom edge
;
; On Entry:
;   Xreg and Yreg are workspace offsets to two coordinates
;   .gxrTemp3 is the offset to a third coordinate, which must be >= (Yreg offset coordinate)
; On Exit:
;   Y: index to middle point
;
; ***************************************************************************************
.sortThreePointsAndPlotFlatEdgedTriangle
    ; Sort three points
    JSR .gxrSortPointsXY                                ;

    STX .gxrTemp1                                       ; .gxrTemp1 = lower point, Yreg = higher point
    LDX .gxrTemp3                                       ; compare Yreg with third coordinate
    JSR .gxrSortPointsXY                                ;

    STY .gxrTemp3                                       ;
    STX .gxrTemp2                                       ;

    ; The three values are sorted now:
    ;
    ;   .gxrTemp3 is the highest  point of original Xreg,Yreg and .gxrTemp3
    ;   .gxrTemp2 is the middle   point of original Xreg,Yreg and .gxrTemp3
    ;   .gxrTemp1 is the lowest   point of original Xreg,Yreg and .gxrTemp3

    ; Copy the lowest point to .triangleRowLeftPointX/Y and .triangleRowRightPointX/Y.
    ; These will track the left and right edge points for the current row.
    LDY .gxrTemp1                                       ;
    LDX #$FC                                            ; loop counter ($FC,$FD,$FE,$FF)
-
    LDA .vduVariablesStart,Y                            ; }
    STA .triangleRowLeftPointX - $FC,X                  ; } store point in
    STA .triangleRowRightPointX - $FC,X                 ; } .triangleRowLeftPointX/Y and
    INY                                                 ; } .triangleRowRightPointX/Y
    INX                                                 ; }
    BNE -                                               ; }

    ; Initialise main line ('line 3') variables (see diagram below)
    LDY .gxrTemp1                                       ; bottom point
    LDA .gxrTemp3                                       ; top point
    STA .gxrScratchspace2                               ;
    LDX #.line3StartPointX - .vduVariablesStart         ;
    JSR .lineInitialisation                             ;

    ; The line initialisation sets up line 3 variables:
    ;    .line3StartPointX: initial and current point X [2 bytes]
    ;    .line3StartPointY: initial and current point Y [2 bytes]
    ;    .line3AbsDeltaX  : abs(deltaX)                 [2 bytes]
    ;    .line3AbsDeltaY  : abs(deltaY)                 [2 bytes]
    ;    .line3ErrorTerm  : Bresenham error term        [2 bytes]
    ;    .line3Signs      : signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

    LDY .gxrTemp1                                       ; bottom point
    LDA .gxrTemp2                                       ; middle point
    JSR .drawFlatBasedTriangle                          ; draw bottom half of triangle

    LDY .gxrTemp2                                       ; middle point, ready to draw top half
    RTS                                                 ;

; ***************************************************************************************
;
; Draw a flat based (or flat topped) triangle
;
; Coordinates have been pre-sorted into top, middle and bottom points of the original triangle.
;
; On Entry:
;   A: index of vduVariable for middle point
;   Y: index of vduVariable for bottom (start) point
;   .line3*: line variables hold the details for the main line
;
;                                                               -- <- top point
;                                                             ---
;                                                           --  -
;                                          minor line ->  --   -
;                                                       --     -
;                                                     --      -
;                                                   --        -
;                                                 --         -
; 'A' register, the index of the middle point -> #############
;                                                 #         #
;                                                 #         #   <- main line (aka 'line 3')
;                                                  #       #       goes all the way to the top point
;                                                  #       #
;                                                   #     #
;                                    minor line ->  #     #
;                                                    #   #
;                                                    #   #
;                                                     # #
;                                                     # #
;                                                      #
;                                                      #  <- 'Y' register, the index of the current
;                                                             point, starting at the bottom
;
; ***************************************************************************************
.drawFlatBasedTriangle
    STA .gxrScratchspace1                               ; store end of minor line index
    LDX #.line2StartPointX - .vduVariablesStart         ; where the minor line initialisation results will go

.drawFlatBasedTriangleInternal
    JSR .lineInitialisation                             ;
    ; The line initialisation sets up line variables for the minor line, (either line 2 or 3, as specified by the X register).
    ; For regular filled triangle plotting, this is line2,
    ; For top half of a parallelogram this is line3.
    ;
    ; Assuming line 2, these variables are set up:
    ;
    ;    .line2StartPointX: initial and current point X [2 bytes]
    ;    .line2StartPointY: initial and current point Y [2 bytes]
    ;    .line2AbsDeltaX  : abs(deltaX)                 [2 bytes]
    ;    .line2AbsDeltaY  : abs(deltaY)                 [2 bytes]
    ;    .line2ErrorTerm  : Bresenham error term        [2 bytes]
    ;    .line2Signs      : signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

    LDY .gxrScratchspace1                               ; get middle point index

    ; [NOTE: cheeky little entry point for drawing a parallelogram with flat top and bottom
    ;        edges using the same algorithm as drawing the triangle with a single flat edge.
    ;        This code can actually draw a trapezium with flat top and bottom edges, but in
    ;        practice is only used for a triangle or a parallelogram.]
.drawFlatParallelogram
    STY .vduTempStoreDB                                 ; remember current point index
.drawFlatTriangleLoop
    ; Check to see if we are done
    LDA .vduVariablesStart + 2,Y                        ; }
    CMP .line1AbsDeltaY                                 ; }
    BNE +                                               ; } if (minor line current Y == middle point Y) then branch (finished drawing)
    LDA .vduVariablesStart + 3,Y                        ; }
    CMP .line1AbsDeltaY+1                               ; }
    BEQ .finishedDrawingTriangle                        ; }

+
    LDX #.line2StartPointX - .vduVariablesStart         ; given the current point for the minor line, update it until about to move to a new row
    JSR .updatePointOnLineXUntilReadyToMoveToNextRow    ; and update the current left or right point for the row

    LDX #.line3StartPointX - .vduVariablesStart         ; given the current point for the main line, update it until about to move to a new row
    JSR .updatePointOnLineXUntilReadyToMoveToNextRow    ; and update the current left or right point for the row

    JSR .fillTriangleRowFromLeftToRight                 ; fill current row from left point to right

    ; Move to the first point on the next row for each line (having got ready for that before the fill above)
    LDX #.line2StartPointX - .vduVariablesStart         ;
    JSR .lineMoveToNextPixel                            ; move to next point on line 2 (which moves to a new row)

    LDX #.line3StartPointX - .vduVariablesStart         ;
    JSR .lineMoveToNextPixel                            ; move to next point on line 3 (which moves to a new row)

    LDX #.line2StartPointX - .vduVariablesStart         ;
    LDY #.line3StartPointX - .vduVariablesStart         ;
    JSR .sortCoordinatesXYByColumn                      ; sort to make X the left point, Y the right point

    ; Store the new row's left and right points in triangleRow[Left/Right]Point

    ; Remember X (the left point) for later
    STA .gxrScratchspace3                               ; [NOTE: redundant]
    TXA                                                 ;
    PHA                                                 ; remember X
    LDA .gxrScratchspace3                               ; [NOTE: redundant]

    ; First store the right point (indexed by Y)
    LDX #$FC                                            ; loop counter ($FC,$FD,$FE,$FF)
-
    LDA .vduVariablesStart,Y                            ; } copy right point
    STA .triangleRowRightPointX - $FC,X                 ; } store in .triangleRowRightPointX/Y
    INY                                                 ; }
    INX                                                 ; }
    BNE -                                               ; }

    ; Recall X (the left point)
    STA .gxrScratchspace3                               ; [NOTE: redundant]
    PLA                                                 ;
    TAX                                                 ; restore X
    LDA .gxrScratchspace3                               ; [NOTE: redundant]

    ; Lastly store the left point (indexed by X)
    LDY #$FC                                            ; loop counter
-
    LDA .vduVariablesStart,X                            ; }
    STA .triangleRowLeftPointX - $FC,Y                  ; } copy left point
    INX                                                 ; } store in .triangleRowLeftPointX/Y
    INY                                                 ; }
    BNE -                                               ; }

    LDY .vduTempStoreDB                                 ; recall current point index
    JMP .drawFlatTriangleLoop                           ;

.finishedDrawingTriangle
    ; We continue to update the line 2 point to get the row span for the final row
    LDA #.line2StartPointX - .vduVariablesStart         ;
    LDX .gxrScratchspace1                               ;
    JSR .updateToGetRowSpan                             ;

    ; We continue to update the line 3 point to get the row span for the final row
    LDY .vduTempStoreDB                                 ;
    LDA #.line3StartPointX - .vduVariablesStart         ;
    LDX .gxrScratchspace2                               ;

.updateToGetRowSpan
    STA .vduTempStoreDE                                 ;
    LDA .vduVariablesStart + 2,X                        ;
    CMP .vduVariablesStart + 2,Y                        ;
    BNE +                                               ; if (Y coordinates don't match) then branch

    LDA .vduVariablesStart + 3,X                        ;
    CMP .vduVariablesStart + 3,Y                        ;
    BEQ .updateLeftAndRightTriangleRowPoints            ; if (Y coordinates match) then branch

+
    LDX .vduTempStoreDE                                 ;
    JMP .updatePointOnLineXUntilReadyToMoveToNextRow    ;

; ***************************************************************************************
.makeErrorTermNegative
    ; Push X (preserving A)
    STA .gxrScratchspace3                               ; }
    TXA                                                 ; } push X leaving A untouched
    PHA                                                 ; } [NOTE: wasteful. No need to preserve A!]
    LDA .gxrScratchspace3                               ; }

    JSR .lineMoveToNextPixel                            ; move to next point on line X

    ; Pop X (preserving A)
    STA .gxrScratchspace3                               ; }
    PLA                                                 ; } pop X leaving A untouched
    TAX                                                 ; } [NOTE: wasteful. No need to preserve A!]
    LDA .gxrScratchspace3                               ; }
    ; fall through...

; ***************************************************************************************
;
; Update the error term then update the left and right extents for the row
;
; On Exit:
;   Preserves X
;
; ***************************************************************************************
.updatePointOnLineXUntilReadyToMoveToNextRow
    LDA .vduVariablesStart + 9,X                        ; check error term
    BPL .makeErrorTermNegative                          ; if (error term >= 0) then branch
                                                        ; which updates the error term until
                                                        ; it becomes negative
    ; fall through...

; ***************************************************************************************
;
; Update the left and right extents of the current row based on the current point on line X
;
; if (lineCurrentX < triangleRowLeftPoint) {
;     triangleRowLeftPointX = lineCurrentX
;     return
; }
; if (lineCurrentX > triangleRowRightPointX) {
;     triangleRowRightPointX = lineCurrentX
; }
;
; ***************************************************************************************
.updateLeftAndRightTriangleRowPoints
    LDA .vduVariablesStart,X                            ;
    CMP .triangleRowLeftPointX                          ;
    LDA .vduVariablesStart + 1,X                        ;
    SBC .triangleRowLeftPointX+1                        ;
    BPL .testRightPoint                                 ; if (lineCurrentX >= triangleRowLeftPointX) then branch

    LDA .vduVariablesStart,X                            ;
    STA .triangleRowLeftPointX                          ;
    LDA .vduVariablesStart + 1,X                        ;
    STA .triangleRowLeftPointX+1                        ; triangleRowLeftPointX = lineCurrentX
    RTS                                                 ;

.testRightPoint
    LDA .triangleRowRightPointX                         ;
    CMP .vduVariablesStart,X                            ;
    LDA .triangleRowRightPointX+1                       ;
    SBC .vduVariablesStart + 1,X                        ;
    BPL .return18                                       ; if (triangleRowRightPointX >= lineCurrentX) then branch (return)

    LDA .vduVariablesStart,X                            ;
    STA .triangleRowRightPointX                         ;
    LDA .vduVariablesStart + 1,X                        ;
    STA .triangleRowRightPointX+1                       ; triangleRowRightPointX = lineCurrentX
.return18
    RTS                                                 ;

; ***************************************************************************************
;
; Sort two points, sorting by row first then column
;
; Given two points (one indexed by register X the other by register Y), sort them by row (lowest
; first) then by column (leftmost first)
;
; i.e. if (point X is higher OR (level and right of point Y)) then swap points in place
;
; On Exit:
;   X is the offset to the lower point
;   Y is the offset to the higher point
;
; ***************************************************************************************
.gxrSortPointsXY
    SEC                                                 ;
    LDA .vduVariablesStart + 2,Y                        ;
    SBC .vduVariablesStart + 2,X                        ;
    STA .vduTempStoreDE                                 ; tempStoreDE is diffLow
    LDA .vduVariablesStart + 3,Y                        ;
    SBC .vduVariablesStart + 3,X                        ;
    BMI .swapXandY                                      ; if (vdu[Y,Y+1] < vdu[X,X+1]) then branch (swap)

    ORA .vduTempStoreDE                                 ;
    BNE .return5                                        ; if (coordinates are not equal) then branch (return)

    ; Sort so that X = leftmost point, Y = rightmost
.sortCoordinatesXYByColumn
    LDA .vduVariablesStart,Y                            ;
    CMP .vduVariablesStart,X                            ;
    LDA .vduVariablesStart + 1,Y                        ;
    SBC .vduVariablesStart + 1,X                        ;
    BPL .return5                                        ; if (vdu[Y,Y+1] >= vdu[X,X+1]) then branch (return)

.swapXandY
    TXA                                                 ; }
    STY .gxrScratchspace3                               ; }
    LDX .gxrScratchspace3                               ; } swap X and Y registers
    TAY                                                 ; }
.return5
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 16: Circle
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Types of circle routines available
;
; See circles_chart.png
;
; ***************************************************************************************

; ***************************************************************************************
;
; Plot the outline of a circle
;
; The circle is specified by two points, the centre point and a point on the radius.
;
; On Entry:
;   .vduGraphicsCursorPixelsXLow:   centre point    [4 bytes]
;   .vdu25ParameterXLow:            point on radius [4 bytes]
;
; ***************************************************************************************
.plotCircleOutline
    ; Copy the centre of the circle point to the old graphics position
    LDX #.vduGraphicsCursorPixelsXLow    - .vduVariablesStart   ; source (centre of circle)
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; destination (old graphics point)
    JSR .copyFourBytesWithinVDUVariables                        ; copy current graphics cursor position to old graphics cursor position
                                                                ; i.e. copy the centre of the circle

    ; Get radius squared
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; centre of circle
    LDX #.vdu25ParameterXLow             - .vduVariablesStart   ; plot position
    JSR .getCircleRadiusSquared                                 ;

    ; Initialise circle variables
    JSR .circleInitialisation                                   ;

    ; Loop to draw the circle
    ; Each time around the loop we move to the next pixel around the first quadrant
    ; of the circle and we reflect to draw the other quadrants
.circleOutlineLoop
    ; Add the centre point to get the right hand side point on the circle, then reflect
    ; about the centre Y axis to get the left side point on the circle.
    ;
    ; i.e.:
    ;   .circlePointRight = (centreX + pointX, centreY + pointY)
    ;   .circlePointLeft  = (centreX - pointX, centreY + pointY)
    JSR .reflectCirclePointXAboutCircleCentre           ; Set X coordinates
    JSR .addCirclePointYToCircleCentre                  ; Set Y coordinates

    ; Plot four points symmetrically about the centre of the circle

    ; Plot right point (quadrant 0)
    LDX #.circlePointRightXLow - .vduVariablesStart     ;
    JSR .plotPointXInternal                             ; plot point .circlePointRight

    ; Don't draw the left point if exactly on the horizontal centre line
    ; (since it would be the same as the right point already drawn)
    LDA .circlePointXLow                                ;
    ORA .circlePointXHigh                               ;
    BEQ +                                               ; if (circle X is zero) then branch (skip forward)

    ; Plot left point (quadrant 1)
    LDX #.circlePointLeftXLow - .vduVariablesStart      ;
    JSR .plotPointXInternal                             ; plot point .circlePointLeft

+
    ; Don't reflect below the centre row if exactly on the centre row
    LDA .circlePointYLow                                ;
    ORA .circlePointYHigh                               ;
    BEQ .circleOutlineNext                              ; if (circle point Y is zero) then branch (skip forward)

    JSR .reflectPointVerticallyAboutCircleCentre        ; reflect points .circlePointLeft and .circlePointRight
                                                        ; vertically about the centre

    ; Plot right point (quadrant 3)
    LDX #.circlePointRightXLow - .vduVariablesStart     ;
    JSR .plotPointXInternal                             ; plot point .circlePointRight

    ; Don't reflect if on the horizontal centre line
    LDA .circlePointXLow                                ;
    ORA .circlePointXHigh                               ;
    BEQ .circleOutlineNext                              ; if (circle X is zero) then branch (skip forward)

    ; Plot left point (quadrant 2)
    LDX #.circlePointLeftXLow - .vduVariablesStart      ;
    JSR .plotPointXInternal                             ; plot point .circlePointLeft

.circleOutlineNext
    JSR .circleIncrement                                ; move to next pixel
    LDA .circlePointXHigh                               ;
    BPL .circleOutlineLoop                              ; if (circle point X >= 0) then branch (loop back)

    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Plot a filled circle
;
; The circle is specified by two points, the centre point and a point on the radius.
;
; On Entry:
;   .vduGraphicsCursorPixelsXLow: centre point [4 bytes]
;   .vdu25ParameterXLow: point on radius [4 bytes]
;
; ***************************************************************************************
.plotCircleFilled
    ; Copy centre of circle to old graphics cursor position
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart      ; source
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; destination
    JSR .copyFourBytesWithinVDUVariables                        ;

    ; Get radius squared
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart ;
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ;
    JSR .getCircleRadiusSquared                         ;

    ; Initialise circle variables
    JSR .circleInitialisation                           ;

    ; Loop to draw the circle
    ; Each time around the loop we move to the next row of the circle moving from the
    ; centre row upwards to the top, reflecting each time to draw the rows below the
    ; centre.
.circleFilledLoop
    ; Add the centre point to get the right hand side point on the circle, then reflect
    ; about the centre Y axis to get the left side point on the circle.
    ;
    ; i.e.:
    ;   .circlePointRight = (centreX + pointX, centreY + pointY)
    ;   .circlePointLeft  = (centreX - pointX, centreY + pointY)
    JSR .reflectCirclePointXAboutCircleCentre           ; Set X coordinates
    JSR .addCirclePointYToCircleCentre                  ; Set Y coordinates

    ; draw row in upper half of circle
    LDY #.circlePointRightXLow - .vduVariablesStart     ;
    LDX #.circlePointLeftXLow - .vduVariablesStart      ;
    JSR .setMasksAndFillRow                             ;

    ; if we are on the centre row, skip forward
    LDA .circlePointYLow                                ;
    ORA .circlePointYHigh                               ;
    BEQ +                                               ;

    ; Reflect points below the centre
    JSR .reflectPointVerticallyAboutCircleCentre        ; reflect points vertically about the centre
                                                        ; this gives us the points in the remaining two quadrants

    ; draw row in lower half of circle
    LDY #.circlePointRightXLow - .vduVariablesStart     ;
    LDX #.circlePointLeftXLow - .vduVariablesStart      ;
    JSR .setMasksAndFillRow                             ;

+
    ; Increment the circle point until we reach a new row, then loop back to .circleFilledLoop
    LDA #0                                              ;
    STA .circleFillRowFlag                              ; flag to tell us when we reach a new row
.circleRowLoop
    JSR .circleIncrement                                ; move to next pixel around circle

    LDA .circlePointXHigh                               ; }
    BMI .finishedCircleFilled                           ; } if (finished) then branch

    LDA .circleFillRowFlag                              ; }
    BEQ .circleRowLoop                                  ; } if (not on new row yet) loop back
    BNE .circleFilledLoop                               ; ALWAYS branch (loop back)

.finishedCircleFilled
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Get the circle radius squared
;
; By calculating deltaX^2 + deltaY^2 we get the radius squared.
;
; On Entry:
;   X: the vdu variables offset to the centre point of the circle
;   Y: the vdu variables offset to a point on the circumference of the circle
;
; On Exit:
;   .circleRadiusSquared and .gxrTemp4567: radius squared, i.e.: (deltaX^2) + (deltaY^2)
;
; ***************************************************************************************
.getCircleRadiusSquared
    STX .vduTempStoreDE                                 ; remember initial X
    STY .vduTempStoreDF                                 ; remember initial Y

    ; .gxrTemp12 = delta X
    SEC                                                 ; }
    LDA .vduVariablesStart,X                            ; }
    SBC .vduVariablesStart,Y                            ; }
    STA .gxrTemp1                                       ; } .gxrTemp12 = point[X].X - point[Y].X
    LDA .vduVariablesStart + 1,X                        ; }            = width (signed value)
    SBC .vduVariablesStart + 1,Y                        ; }
    STA .gxrTemp2                                       ; }

    ; Compensate for double width pixels (MODE 2,5)
    LDX .vduCurrentScreenMODE                           ;
    LDA .pixelShapeForMODE,X                            ;
    STA .circlePixelShapeForCurrentMODE                 ; store pixel shape based on MODE
    AND #1                                              ;
    BEQ +                                               ; if (not double width pixels) then branch

    ; to handle double width pixels (MODE 2,5), we double delta X, and deal with the consequences
    ; in the update routine (see .circleIncrement)
    ASL .gxrTemp1                                       ; }
    ROL .gxrTemp2                                       ; } multiply X coordinate by two to compensate
+

    ; Square delta X
    JSR .square12_into4567                              ; square width in .gxrTemp12 to .gxrTemp4567

    ; .circleRadiusSquared = .gxrTemp4567
    LDX #3                                              ; loop counter
-
    LDA .gxrTemp4,X                                     ;
    STA .circleRadiusSquaredLow,X                       ;
    DEX                                                 ;
    BPL -                                               ;

    LDX .vduTempStoreDE                                 ; } recall initial X, Y variables
    LDY .vduTempStoreDF                                 ; }


    ; .gxrTemp12 = delta Y
    SEC                                                 ; }
    LDA .vduVariablesStart + 2,X                        ; }
    SBC .vduVariablesStart + 2,Y                        ; }
    STA .gxrTemp1                                       ; } .gxrTemp12 = point[X].Y - point[Y].Y
    LDA .vduVariablesStart + 3,X                        ; }            = height (signed value)
    SBC .vduVariablesStart + 3,Y                        ; }
    STA .gxrTemp2                                       ; }

    ; Compensate for half width pixels (MODE 0)
    LDA .circlePixelShapeForCurrentMODE                 ; get pixel shape based on MODE
    AND #2                                              ;
    BEQ +                                               ; if (not half width pixels) then branch

    ; to handle half width pixels (MODE 0), we double the delta Y, and deal with the consequences
    ; in the update routine (see .circleIncrement)
    ASL .gxrTemp1                                       ; }
    ROL .gxrTemp2                                       ; } multiply Y coordinate by two to compensate
+

    ; Square delta Y
    JSR .square12_into4567                              ; square height in .gxrTemp12 into .gxrTemp4567

    ; .circleRadiusSquaredLow += .gxrTemp4567
    ; i.e. .circleRadiusSquaredLow = (deltaX^2) + (deltaY^2)
    ; .sqrtNumber0 = .circleRadiusSquaredLow
    CLC                                               ;
    LDX #$FC                                          ; loop counter ($FC,$FD,$FE,$FF)
-
    LDA .circleRadiusSquaredLow - $FC,X               ; .circleRadiusSquared += .gxrTemp4567
    ADC .sqrtNumber0 - $FC,X                          ;
    STA .circleRadiusSquaredLow - $FC,X               ;
    STA .sqrtNumber0 - $FC,X                          ; .sqrtNumber0123 = .circleRadiusSquared
    INX                                               ; increment loop counter
    BMI -                                             ; if (not done) then branch (loop back)
    RTS                                               ;

; ***************************************************************************************
;
; Initialise circle plotting variables
;
; Gets the initial point on the circle (along the positive X-axis, quadrant 0), and initialises
; other variables to help in moving from point to point around the circle.
;
; Given the square of the radius 'square_r', we take the integer square root to get an integer
; value for the radius: floor_r = floor(sqrtf(square_r)).
;
; Because the square root function rounds down using the floor function, we ideally want to get
; closer to a proper rounded value: round(sqrtf(square_r)).
;
;   i.e. we want something closer to:
;
;       float float_r = sqrtf(square_r)
;       float f = float_r+0.5
;       int ideal_radius = floor(f)
;
; We first calculate the regular integer square root to get floor_r = floor(sqrtf(square_r)), but
; then want to get closer to f.
;
; Note that f = (float_r+0.5) and:
;
;   f^2 = (float_r+0.5)^2 = float_r^2 + float_r + 0.25
;
; We already know square_r = float_r^2. We approximate floor_r ~= (float_r + 0.25)
; So we calculate 'square_r + floor_r' and then take the integer square root, to get
; a closer approximation to the ideal_radius = floor(f).
;
; One of the other variables is the decision variable (.circleDecision). This tracks how
; close we are to the ideal circle radius by tracking the difference between our desired
; radius squared and the current radius squared.
;
; On Entry:
;   .circleRadiusSquared:  radius squared [4 bytes]
;   .sqrtNumber0123:       radius squared [4 bytes]
; On Exit:
;   .circlePointX: radius   } initial point on circle along X axis = (radius,0)
;   .circlePointY: 0        }
;   .circleDiameterCountdown: diameter-1    (counts down in steps of 2)
;   .circleCountOddNumbers: 1               (counts up in steps of 2)
;   .circlePixelShapeCurrentOffset: 3       (accounting for pixel shape)
;   .circleDecision: desired radius squared - current radius squared
;
; ***************************************************************************************
.circleInitialisation
    ; radius = sqrt(radius squared)
    JSR .sqrt32                                         ; .gxrTemp12 = sqrt(.gxrTemp4567)

    ; .circleRadiusSquared  += .gxrTemp12 (i.e. .circleRadiusSquaredLow = radius^2 + radius)
    ; .sqrtNumber0123 = .circleRadiusSquared
    CLC                                                 ; }
    LDA .gxrTemp1                                       ; }
    ADC .circleRadiusSquaredLow                         ; }
    STA .circleRadiusSquaredLow                         ; }
    STA .sqrtNumber0                                    ; }
    LDA .gxrTemp2                                       ; } .circleRadiusSquared +=.gxrTemp12
    ADC .circleRadiusSquaredMid1                        ; }
    STA .circleRadiusSquaredMid1                        ; } .sqrtNumber0123 = .circleRadiusSquared
    STA .sqrtNumber1                                    ; }
    LDA #0                                              ; }
    ADC .circleRadiusSquaredMid2                        ; }
    STA .circleRadiusSquaredMid2                        ; }
    STA .sqrtNumber2                                    ; }
    LDA #0                                              ; }
    ADC .circleRadiusSquaredHigh                        ; }
    STA .circleRadiusSquaredHigh                        ; }
    STA .sqrtNumber3                                    ; }

    ; .sqrtResult01 = sqrt(.sqrtNumber0123) i.e. sqrt(radius^2 + radius)
    JSR .sqrt32                                         ; .gxrTemp12 = sqrt(.gxrTemp4567)

    ; .circlePointX = .sqrtResult01
    ; .circleDiameterCountdown = 2*.circlePointX - 1
    LDA .sqrtResult0                                    ; }
    STA .circlePointXLow                                ; } .circlePointX = .sqrtResult0
    ASL                                                 ; }
    STA .circleDiameterCountdownLow                     ; } .circleDiameterCountdown = twice X point
    LDA .sqrtResult1                                    ; }
    STA .circlePointXHigh                               ; }
    ROL                                                 ; }
    STA .circleDiameterCountdownHigh                    ; }

    LDA .circleDiameterCountdownLow                     ; }
    BNE +                                               ; } .circleDiameterCountdown--
    DEC .circleDiameterCountdownHigh                    ; }
+                                                       ; }
    DEC .circleDiameterCountdownLow                     ; }

    ; Now we have our actual radius we are going to draw, we square it to get the actual
    ; radius squared
    JSR .square12_into4567                              ; .gxrTemp4567 = .sqrtResult01 * .sqrtResult01

    ; .circleDecision = .circleRadiusSquared - .gxrTemp45 = (radius^2 + radius) - (actual radius)^2
    SEC                                                 ; }
    LDA .circleRadiusSquaredLow                         ; }
    SBC .gxrTemp4                                       ; }
    STA .circleDecisionLow                              ; } .circleDecision = .circleRadiusSquared - .gxrTemp45
    LDA .circleRadiusSquaredMid1                        ; }
    SBC .gxrTemp5                                       ; }
    STA .circleDecisionHigh                             ; }

    ; .circlePointY = 0
    LDA #0                                              ;
    STA .circlePointYHigh                               ;
    STA .circlePointYLow                                ;

    ; .circleCountOddNumbers = 1
    STA .circleCountOddNumbersHigh                      ;
    LDA #1                                              ;
    STA .circleCountOddNumbersLow                       ;

    ; .circlePixelShapeCurrentOffset = 3
    LDA #3                                              ;
    STA .circlePixelShapeCurrentOffset                  ;

    ; Scale X based on pixel shape
    LDA .circlePixelShapeForCurrentMODE                 ; get pixel shape based on MODE
    AND #1                                              ;
    BEQ +                                               ; if (not double width) then branch

    LSR .circlePointXHigh                               ; divide width by two
    ROR .circlePointXLow                                ;
+
    RTS                                                 ;

; ***************************************************************************************
;
; Moves coordinates onto the next pixel around the circle
;
; Update the point 'circlePoint' to be the next pixel around the circle anticlockwise from the
; positive x-axis (in quadrant 0). Uses something akin to Bresenham's Circle Algorithm.
;
; circlePixelShapeCurrentOffset = pixel shape for current MODE
; repeat:
;     if circleDecision < circleCountOddNumbers:
;         circleDecision += circleDiameterCountdown
;         circleDiameterCountdown -= 2
;         circlePixelShapeCurrentOffset = circlePixelShapeCurrentOffset EOR 1
;         if (circlePixelShapeCurrentOffset AND 1) { circlePointX-- }
;         if (circleDecision < circleCountOddNumbers) then goto "circle_continues"
;
;     circleDecision -= circleCountOddNumbers
;     circleCountOddNumbers += 2
;     circlePixelShapeCurrentOffset = circlePixelShapeCurrentOffset EOR 2
;     if circlePixelShapeCurrentOffset AND 2:
;         circleFillRowFlag = 1               (start of new row)
;         circlePointY++
;     "circle_continues"
; until (circlePixelShapeCurrentOffset != 0)
;
; ***************************************************************************************
.circleIncrement
    ; The shape of pixels can be double width or half width (compared to MODE 1)
    LDA .circlePixelShapeCurrentOffset                  ; } .circlePixelShapeCurrentOffset &=
    AND .circlePixelShapeForCurrentMODE                 ; } pixel shape based on MODE
    STA .circlePixelShapeCurrentOffset                  ; }

.circleIncrementInternal
    SEC                                                 ; }
    LDA .circleDecisionLow                              ; }
    SBC .circleCountOddNumbersLow                       ; } X = .circleDecision -
    TAX                                                 ; }     .circleCountOddNumbersLow

    LDA .circleDecisionHigh                             ;
    SBC .circleCountOddNumbersHigh                      ;
    BPL .incrementY                                     ; if (.circleDecision >= .circleCountOddNumbers) then branch

    CLC                                                 ; }
    LDA .circleDecisionLow                              ; }
    ADC .circleDiameterCountdownLow                     ; }
    STA .circleDecisionLow                              ; } .circleDecision +=
    LDA .circleDecisionHigh                             ; }      .circleDiameterCountdown
    ADC .circleDiameterCountdownHigh                    ; }
    STA .circleDecisionHigh                             ; }

    SEC                                                 ; }
    LDA .circleDiameterCountdownLow                     ; }
    SBC #2                                              ; }
    STA .circleDiameterCountdownLow                     ; } .circleDiameterCountdown -= 2
    BCS +                                               ; }
    DEC .circleDiameterCountdownHigh                    ; }
+

    ; Account for double width pixel shape
    ;
    ; In double width pixel modes (MODE 2, 5) we skip decrementing X every other time to
    ; account for the fact we doubled the deltaX coordinate in the setup routine (see .getCircleRadiusSquared)
    LDA .circlePixelShapeCurrentOffset                  ; }
    EOR #1                                              ; } .circlePixelShapeCurrentOffset ^= 1
    STA .circlePixelShapeCurrentOffset                  ; }
    AND #1                                              ;
    BEQ .skipMoveLeft                                   ;

    LDA .circlePointXLow                                ; }
    BNE +                                               ; }
    DEC .circlePointXHigh                               ; } .circlePointX--
+                                                       ; }
    DEC .circlePointXLow                                ; }

.skipMoveLeft
    SEC                                                 ; }
    LDA .circleDecisionLow                              ; }
    SBC .circleCountOddNumbersLow                       ; } X = .circleDecisionLow -
    TAX                                                 ; }      .circleCountOddNumbersLow

    LDA .circleDecisionHigh                             ; }
    SBC .circleCountOddNumbersHigh                      ; }
    BMI .circleContinues                                ; } if (.circleDecision < .circleCountOddNumbers) then branch

.incrementY
    STA .circleDecisionHigh                             ; } Finish subtraction started earlier:
    STX .circleDecisionLow                              ; } .circleDecision -= .circleCountOddNumbers

    CLC                                                 ; }
    LDA .circleCountOddNumbersLow                       ; }
    ADC #2                                              ; } .circleCountOddNumbers += 2
    STA .circleCountOddNumbersLow                       ; }
    BCC +                                               ; }
    INC .circleCountOddNumbersHigh                      ; }
+

    ; Account for half width pixel shape
    ;
    ; In half width pixel MODEs (MODE 0) we skip incrementing Y every other time to
    ; account for the fact we doubled the deltaY coordinate in the setup routine (see .getCircleRadiusSquared)
    LDA .circlePixelShapeCurrentOffset                  ; }
    EOR #2                                              ; } .circlePixelShapeCurrentOffset ^= 2
    STA .circlePixelShapeCurrentOffset                  ; }
    AND #2                                              ;
    BEQ .circleContinues                                ; if (bit 2 clear) then branch

    INC .circleFillRowFlag                              ; set the circle fill flag (moving to a new row)

    INC .circlePointYLow                                ; }
    BNE .circleContinues                                ; }
    INC .circlePointYHigh                               ; } .circlePointY++

.circleContinues
    ; If the pixel shape for the current mode requires we do a second loop then loop back, otherwise finish
    LDA .circlePixelShapeCurrentOffset                  ;
    BNE .return10                                       ; if (done) then branch (return)
    JMP .circleIncrementInternal                        ; loop back

.return10
    RTS                                                 ;

; ***************************************************************************************
;
; Plot an arc of a circle
;
;                                        KEY: # = chord
;                             circle          * = arc
; point defining                |             / = start line
; end of arc ---->\            \|/            \ = end line
; (PLOT parameter) \         ******
;                   \    ****      ****
;  leftmost end of-> \#######          ***
;            chord    \      ########     **
;                      \             ######## <---- start of arc (current graphics cursor pos)
;                       \                 _/        = rightmost end of chord
;                        \               /
;                         \            _/
;                 end line \          / start line
;                           \       _/
;                            \     /
;                             \  _/
;                              \/ <---- centre of circle (old graphics cursor pos)
;
; ***************************************************************************************
.plotCircleArc
    LDA #0                                              ; }
    STA .circleChordLine                                ; } no chord line to track for an arc
    JSR .circleDoLineAndQuadrantInitialisation          ;

    ; Get radius squared
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; circle centre
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart      ; start point
    JSR .getCircleRadiusSquared                                 ;

    ; Initialise circle variables
    JSR .circleInitialisation                                   ;

.plotCircleArcLoop
    ; Each time around this loop is the next pixel around the circle.
    ;
    ; We start with the point on the circle to the right on the horizontal centre line
    ; and work up anticlockwise, plotting until we reach the top of the quadrant. We reflect
    ; as we go to generate the same points in the remaining quadrants.

    ; Add the centre point to get the right hand side point on the circle, then reflect
    ; about the centre Y axis to get the left side point on the circle.
    ;
    ; i.e.:
    ;   .circlePointRight = (centreX + pointX, centreY + pointY)
    ;   .circlePointLeft  = (centreX - pointX, centreY + pointY)
    JSR .reflectCirclePointXAboutCircleCentre           ; Set X coordinates
    JSR .addCirclePointYToCircleCentre                  ; Set Y coordinates

    ; Prepare data for quadrant zero (top right quadrant)
    LDY #0                                              ;
    JSR .circlePrepareForRightSideQuadrant              ;

    ; Prepare data for quadrant one (top left quadrant)
    LDY #1                                              ;
    JSR .circlePrepareForLeftSideQuadrant               ;

    ; Are we the correct side of the chord line?
    LDX .circleTrackingRightmostChordPoint              ;
    CPX #.circlePointRightXLow - .vduVariablesStart     ;
    BNE +                                               ; if (not the correct side of the chord) then branch

    ; Plot right side point (quadrant 0)
    JSR .plotPointXInternal                             ; plot point .circlePointRight

+
    ; if (on the centre column) then branch (we can't reflect left of the centre, skip forward)
    LDA .circlePointXLow                                ;
    ORA .circlePointXHigh                               ;
    BEQ +                                               ; if (X coordinate is zero) then branch

    ; Are we the correct side of the chord line?
    LDX .circleTrackingLeftmostChordPoint               ;
    CPX #.circlePointLeftXLow - .vduVariablesStart      ;
    BNE +                                               ; if (not the correct side of the chord) then branch

    ; Plot left side point (quadrant 1)
    JSR .plotPointXInternal                             ; plot point .circlePointLeft

+
    ; if (on the centre row) then branch (we can't reflect below the line, skip forward)
    LDA .circlePointYLow                                ;
    ORA .circlePointYHigh                               ;
    BEQ .nextCirclePoint                                ; if (Y coordinate is zero) then branch

    ;
    ; Draw below the centre row
    ;
    JSR .reflectPointVerticallyAboutCircleCentre        ; reflect points .circlePointLeft, .circlePointRight vertically below the centre row

    ; Prepare data for quadrant three (bottom right quadrant)
    LDY #3                                              ;
    JSR .circlePrepareForRightSideQuadrant              ;

    ; Prepare data for quadrant two (bottom left quadrant)
    LDY #2                                              ;
    JSR .circlePrepareForLeftSideQuadrant               ;

    ; Are we the correct side of the chord line?
    LDX .circleTrackingRightmostChordPoint              ;
    CPX #.circlePointRightXLow - .vduVariablesStart     ;
    BNE +                                               ; if (not the correct side of chord line) then branch

    ; Plot right point (quadrant 2)
    JSR .plotPointXInternal                             ; plot right point

+
    ; if (on centre column) then branch (we can't reflect left of the line, skip forward)
    LDA .circlePointXLow                                ;
    ORA .circlePointXHigh                               ;
    BEQ .nextCirclePoint                                ; if (X coordinate on centre column) then branch

    ; Are we the correct side of the chord line?
    LDX .circleTrackingLeftmostChordPoint               ;
    CPX #.circlePointLeftXLow - .vduVariablesStart      ;
    BNE .nextCirclePoint                                ; if (not the correct side of the chord) then branch

    ; Plot left point (quadrant 3)
    JSR .plotPointXInternal                             ; plot left point

.nextCirclePoint
    JSR .circleIncrement                                ; move to next point

    LDA .circlePointXHigh                               ;
    BPL .plotCircleArcLoop                              ; loop back if not done

    JMP .setGraphicsCursorPositionAndFinishPLOT         ; finally move graphics cursor

; ***************************************************************************************
;
; Plot a sector of a circle
;
;
;                                        KEY: * = sector
;                                             / = start line
;                                             \ = end line
; end of arc ----> \         ******
; (PLOT parameter)  \    **************
;                    \********************
;                     \*********************
;                      \********************* <---- start of arc (graphics cursor)
;                       \******************/
;                        \***************/
;                         \*************/
;                 end line \**********/ start line
;                           \********/
;                            \*****/
;                             \***/
;                              \/ <---- centre of circle (old graphics cursor)
;
; ***************************************************************************************
.plotCircleSector
    LDA #0                                                      ;
    STA .circleChordLine                                        ; no chord line to track
    LDA #1                                                      ;
    STA .circleFillRowFlag                                      ; set flag to indicate we have just incremented our circle point to a new row
    JSR .circleDoLineAndQuadrantInitialisation                  ;

    ; Get radius squared
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ;
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart      ;
    JSR .getCircleRadiusSquared                                 ;

    ; Initialise circle variables
    JSR .circleInitialisation                                   ;

.plotCircleSectorLoop
    ; Each time around this loop is the next pixel around the circle. This may or may
    ; not be on a new row. The flag '.circleFillRowFlag' is set when we should draw the
    ; next row.
    ; We start with the point on the circle to the right on the horizontal centre line
    ; and work up anticlockwise, plotting rows until we reach the top of the quadrant.
    ; We reflect about the centre point to generate the same rows moving downwards from
    ; the centre line too.

    ; Add the centre point to get the right hand side point on the circle, then reflect
    ; about the centre Y axis to get the left side point on the circle.
    ;
    ; i.e.:
    ;   .circlePointRight = (centreX + pointX, centreY + pointY)
    ;   .circlePointLeft  = (centreX - pointX, centreY + pointY)
    JSR .reflectCirclePointXAboutCircleCentre           ; Set X coordinates
    JSR .addCirclePointYToCircleCentre                  ; Set Y coordinates

    ; Prepare data for quadrant zero (top right quadrant)
    LDY #0                                              ;
    JSR .circlePrepareForRightSideQuadrant              ;

    ; Prepare data for quadrant one (top left quadrant)
    LDY #1                                              ;
    JSR .circlePrepareForLeftSideQuadrant               ;

    ; If not plotting this time around the loop (just updating), then branch
    LDA .circleFillRowFlag                              ;
    BEQ .plotRowInLowerHalf                             ;

    ; Check if on centre row
    LDA .circlePointYLow                                ;
    ORA .circlePointYHigh                               ;
    BNE .notOnCentreRow                                 ; if (not on centre row) then branch

    ; We are on the centre row
    ; Check if we have something to plot in this quadrant
    LDA .circleTrackingRightmostChordPoint              ;
    BNE .somethingInQuadrant                            ; if (something to plot in this quadrant) then branch

    ; Nothing to plot in quadrant

    ; Push the appropriate values for use in the lower half
    LDA .circleTrackingSecondLineInQuadrant             ; }
    PHA                                                 ; } push second line;
    LDA .circleTrackingLeftmostChordPoint               ; }
    PHA                                                 ; } push leftmost chord point;
    JMP .plotRowInLowerHalf                             ;


.somethingInQuadrant
    ; Push the appropriate values for use in the lower half
    PHA                                                 ; push rightmost chord point;
    LDA .circleTrackingLeftmostChordPoint               ; }
    BNE .pushAAndReflectBelowCentre                     ; } if (leftmost chord point == 0) then push radial line; else push leftmost chord point;
    LDA .circleRadialLine                               ; }
.pushAAndReflectBelowCentre
    PHA                                                 ; }
    JMP .plotRowInLowerHalf                             ;

.notOnCentreRow
    LDY .circleTrackingRightmostChordPoint              ;
    BEQ .nothingToPlot                                  ; if (nothing to plot in this quadrant) then branch

    LDX .circleRadialLine                               ;
    BEQ .nothingToPlot2                                 ;

    JSR .setMasksAndFillRow                             ; fill row

.nothingToPlot
    LDY .circleTrackingSecondLineInQuadrant             ;
.nothingToPlot2
    LDX .circleTrackingLeftmostChordPoint               ;
    BEQ .plotRowInLowerHalf                             ;

    JSR .setMasksAndFillRow                             ;


.plotRowInLowerHalf
    ;
    ; Now draw the bottom half (i.e. the bottom two quadrants)
    ;
    JSR .reflectPointVerticallyAboutCircleCentre        ; reflect points vertically about the centre row

    ; Prepare data for quadrant 3 (bottom right quadrant)
    LDY #3                                              ;
    JSR .circlePrepareForRightSideQuadrant              ;

    ; Prepare data for quadrant 2 (bottom left quadrant)
    LDY #2                                              ;
    JSR .circlePrepareForLeftSideQuadrant               ;

    LDA .circleFillRowFlag                              ;
    BEQ .nextCircleSectorPoint                          ; if (not plotting this time around the loop, just updating) then branch

    ; Check if on Y=0 centre row
    LDA .circlePointYLow                                ;
    ORA .circlePointYHigh                               ;
    BNE .notOnCentreRow2                                ;

    ;
    ; On centre row. Adjust values for centre row
    ;
    PLA                                                 ;
    TAY                                                 ;
    LDA .circleTrackingRightmostChordPoint              ;
    BNE .lNotZero                                       ;

    LDA .circleTrackingSecondLineInQuadrant             ;
    PHA                                                 ;
    LDX .circleTrackingLeftmostChordPoint               ;
    JMP .branch1                                        ;

.lNotZero
    PHA                                                 ;
    LDX .circleTrackingLeftmostChordPoint               ;
    BNE .branch1                                        ; [NOTE: Could do BNE .testY instead]

    LDX .circleRadialLine                               ;
.branch1
    BNE .testY                                          ;
    STY .circleTrackingLeftmostChordPoint               ;
    JMP .pullValuesAndTest                              ;

.testY
    CPY #0                                              ;
    BNE .sortValues                                     ; if (Y != 0) then branch (sort values)

    STX .circleTrackingLeftmostChordPoint               ;
    JMP .pullValuesAndTest                              ;

.sortValues
    JSR .gxrSortPointsXY                                ;
    STX .circleTrackingLeftmostChordPoint               ;

.pullValuesAndTest
    PLA                                                 ; }
    TAX                                                 ; } X = pull
    PLA                                                 ; } Y = pull
    TAY                                                 ; }
    BNE .testX                                          ; if (Y != 0) then branch

    TXA                                                 ;
    TAY                                                 ; Y=X
    JMP .setLineAndPlot                                 ;

.testX
    CPX #0                                              ;
    BEQ .setLineAndPlot                                 ; if (X == 0) then branch (don't sort vertices)

    JSR .gxrSortPointsXY                                ;

.setLineAndPlot
    LDX .circleTrackingLeftmostChordPoint               ;
    JMP .plotRow                                        ; plot row


.notOnCentreRow2
    LDY .circleTrackingRightmostChordPoint              ;
    BEQ .nothingToPlot3                                 ; if (nothing to plot in this quadrant) then branch

    LDX .circleRadialLine                               ;
    BEQ .nothingToPlot4                                 ;

    JSR .setMasksAndFillRow                             ; plot row

.nothingToPlot3
    LDY .circleTrackingSecondLineInQuadrant             ;
.nothingToPlot4
    LDX .circleTrackingLeftmostChordPoint               ;
    BEQ .nextCircleSectorPoint                          ; if (nothing to plot) then branch

.plotRow
    JSR .setMasksAndFillRow                             ; plot row

.nextCircleSectorPoint
    LDA #0                                              ;
    STA .circleFillRowFlag                              ; clear flag, no longer on a new row
    JSR .circleIncrement                                ;

    LDA .circlePointXHigh                               ;
    BMI +                                               ; if (X coordinate is negative) then branch (finished drawing)
    JMP .plotCircleSectorLoop                           ; jump back to continue drawing
+
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Plot a segment of a circle
;
;                                        KEY: # = chord
;                             circle          * = segment ('#' is also part of segment)
; point defining                |             / = start line
; end of arc ---->\            \|/            \ = end line
; (PLOT parameter) \         ******
;                   \    **************
;  leftmost end of-> \#######*************
;            chord    \      ########*******
;                      \             ######## <---- start of arc (current graphics cursor pos)
;                       \                 _/        = rightmost end of chord
;                        \               /
;                         \            _/
;                 end line \          / start line
;                           \       _/
;                            \     /
;                             \  _/
;                              \/ <---- centre of circle (old graphics cursor pos)
;
; ***************************************************************************************
.plotCircleSegment
    LDA #0                                              ;
    STA .circleChordLine                                ; no chord line to track, yet
    LDA #1                                              ; } set, as if we have just incremented
    STA .circleFillRowFlag                              ; } our circle point to a new row
    JSR .circleDoLineAndQuadrantInitialisation          ;

    ; Get radius squared
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ;
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart      ;
    JSR .getCircleRadiusSquared                         ;

    ; Initialise circle variables
    JSR .circleInitialisation                           ;
    JSR .segmentInitialisation                          ;

.plotUpperHalfOfCircleSegmentLoop
    ; Each time around this loop is the next pixel around the circle. This may or may
    ; not be on a new row. The flag 'circleFillRowFlag' is set when we should draw the
    ; next row.
    ; We start with the point on the circle to the right on the horizontal centre line
    ; and work up anticlockwise, plotting rows until we reach the top of the quadrant.
    ; We reflect about the centre point to generate the same rows moving downwards from
    ; the centre line too.

    ; Add the centre point to get the right hand side point on the circle, then reflect
    ; about the centre Y axis to get the left side point on the circle.
    ;
    ; i.e.:
    ;   .circlePointRight = (centreX + pointX, centreY + pointY)
    ;   .circlePointLeft  = (centreX - pointX, centreY + pointY)
    JSR .reflectCirclePointXAboutCircleCentre           ; Set X coordinates
    JSR .addCirclePointYToCircleCentre                  ; Set Y coordinates

    ; Prepare data for quadrant zero (top right quadrant)
    LDY #0                                              ;
    JSR .circlePrepareForRightSideQuadrant              ;

    ; Prepare data for quadrant one (top left quadrant)
    LDY #1                                              ;
    JSR .circlePrepareForLeftSideQuadrant               ;

    LDY .circleTrackingRightmostChordPoint              ;
    CPY #.circlePointRightXLow - .vduVariablesStart     ;
    BNE .notTrackingChord1                              ; if (not the correct side of the rightmost end of the chord vertically) then branch

    LDX .circleTrackingLeftmostChordPoint               ;
    CPX #.circlePointLeftXLow - .vduVariablesStart      ;
    BEQ .notTrackingChord2                              ; if (not the correct side of the leftmost end of the chord vertically) then branch

    ; We are vertically in between the two ends of the chord
    JSR .advanceAlongChordLineUntilNewRow               ; move along the chord line

    LDY #.circlePointRightXLow - .vduVariablesStart     ;
    LDX .circleChordLine                                ; chord line to track

.notTrackingChord2
    LDA .circleFillRowFlag                              ;
    BEQ .moveToNextCirclePoint                          ; if (not plotting this time around the loop, just updating) then branch

    JSR .setMasksAndFillRow                             ; fill row
    JMP .moveToNextCirclePoint                          ;

.notTrackingChord1
    LDX .circleTrackingLeftmostChordPoint               ;
    CPX #.circlePointLeftXLow - .vduVariablesStart      ;
    BNE .moveToNextCirclePoint                          ; if (not the correct side of the leftmost end of the chord vertically) then branch

    ; Move along the chord line horizontally
    JSR .advanceAlongChordLineUntilNewRow               ;

    LDX #.circlePointLeftXLow - .vduVariablesStart      ;
    LDY .circleChordLine                                ; chord line to track
    LDA .circleFillRowFlag                              ;
    BEQ .moveToNextCirclePoint                          ; if (not plotting this time around the loop, just updating) then branch

    JSR .setMasksAndFillRow                             ; fill row

.moveToNextCirclePoint
    LDA #0                                              ;
    STA .circleFillRowFlag                              ; zero flag
    JSR .circleIncrement                                ; move to next pixel around the circle

    LDA .circlePointXHigh                               ;
    BPL .plotUpperHalfOfCircleSegmentLoop               ; if (X coordinate is still positive) then branch (loop back)

    ;
    ; Now draw the bottom half (i.e. the bottom two quadrants)
    ;

    ; Get radius squared
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; centre of circle
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart      ; start arc point
    JSR .getCircleRadiusSquared                                 ;

    ; Initialise circle variables
    JSR .circleInitialisation                           ;

    LDA #0                                              ; }
    STA .circleChordLine                                ; } no chord line to track, yet
    JSR .segmentInitialisationIfStraddlingTheCentreRow  ;

    ; If (on centre row already) then zero the fill flag
    LDA .circlePointYLow                                ;
    ORA .circlePointYHigh                               ;
    BNE .plotLowerHalfOfCircleSegmentLoop               ; if (not on Y=0 centre row) then branch
    STA .circleFillRowFlag                              ; zero flag

.plotLowerHalfOfCircleSegmentLoop
    ; Add the centre point to get the right hand side point on the circle, then reflect
    ; about the centre Y axis to get the left side point on the circle.
    ; Reflect below the centre row.
    ;
    ; i.e.:
    ;   .circlePointRight = (centreX + pointX, centreY - pointY)
    ;   .circlePointLeft  = (centreX - pointX, centreY - pointY)
    JSR .reflectCirclePointXAboutCircleCentre           ; Set X coordinates
    JSR .reflectPointVerticallyAboutCircleCentre        ; reflect points vertically about the centre

    ; Prepare data for quadrant three
    LDY #3                                              ;
    JSR .circlePrepareForRightSideQuadrant              ;

    ; Prepare data for quadrant two
    LDY #2                                              ;
    JSR .circlePrepareForLeftSideQuadrant               ;


    ; We check to see if we are currently between the top and bottom of the chord line.
    ; If so then we are tracking the chord line.
    LDY .circleTrackingRightmostChordPoint              ;
    CPY #.circlePointRightXLow - .vduVariablesStart     ;
    BNE .notTrackingChord3                              ; if (not the correct side of the rightmost end of the chord vertically) then branch

    LDX .circleTrackingLeftmostChordPoint               ;
    CPX #.circlePointLeftXLow - .vduVariablesStart      ;
    BEQ .notTrackingChord4                              ; if (not the correct side of the leftmost end of the chord vertically) then branch

    ; Move along the chord line horizontally
    JSR .advanceAlongChordLineUntilNewRow               ;

    LDY #.circlePointRightXLow - .vduVariablesStart     ;
    LDX .circleChordLine                                ; chord line to track
.notTrackingChord4
    LDA .circleFillRowFlag                              ;
    BEQ .moveToNextCirclePoint2                         ; if (not on new row) then branch

    JSR .setMasksAndFillRow                             ;
    JMP .moveToNextCirclePoint2                         ;

.notTrackingChord3
    LDX .circleTrackingLeftmostChordPoint               ;
    CPX #.circlePointLeftXLow - .vduVariablesStart      ;
    BNE .moveToNextCirclePoint2                         ; if (not the correct side of the leftmost end of the chord vertically) then branch

    ; Move along the chord line horizontally
    JSR .advanceAlongChordLineUntilNewRow               ;

    LDX #.circlePointLeftXLow - .vduVariablesStart      ;
    LDY .circleChordLine                                ; chord line to track
    LDA .circleFillRowFlag                              ;
    BEQ .moveToNextCirclePoint2                         ; if (not plotting this time around the loop, just updating) then branch

    JSR .setMasksAndFillRow                             ;

.moveToNextCirclePoint2
    LDA #0                                              ;
    STA .circleFillRowFlag                              ; zero flag, no longer on a new row
    JSR .circleIncrement                                ; move to next point on circle

    LDA .circlePointXHigh                               ;
    BPL .plotLowerHalfOfCircleSegmentLoop               ; if (X >= 0) then loop back (more to do)

    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
.reflectCirclePointXAboutCircleCentre
    ; .circlePointRightX = centre X + .circlePointX
    CLC                                                 ;
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    ADC .circlePointXLow                                ;
    STA .circlePointRightXLow                           ;
    LDA .vduOldGraphicsCursorPixelsXHigh                ;
    ADC .circlePointXHigh                               ;
    STA .circlePointRightXHigh                          ;

    ; .circlePointLeftX = centre X - .circlePointX
    SEC                                                 ;
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    SBC .circlePointXLow                                ;
    STA .circlePointLeftXLow                            ;
    LDA .vduOldGraphicsCursorPixelsXHigh                ;
    SBC .circlePointXHigh                               ;
    STA .circlePointLeftXHigh                           ;
    RTS                                                 ;

; ***************************************************************************************
.addCirclePointYToCircleCentre
    ; .circlePointLeftY  = .circlePointRightY = centre Y + .circlePointY
    CLC                                                 ;
    LDA .vduOldGraphicsCursorPixelsYLow                 ;
    ADC .circlePointYLow                                ;
    STA .circlePointRightYLow                           ;
    STA .circlePointLeftYLow                            ;
    LDA .vduOldGraphicsCursorPixelsYHigh                ;
    ADC .circlePointYHigh                               ;
    STA .circlePointRightYHigh                          ;
    STA .circlePointLeftYHigh                           ;
    RTS                                                 ;

; ***************************************************************************************
;
; Set left and right points Y coordinate to be reflected below the centre row of the circle
;
; On Entry:
;       .vduOldGraphicsCursorPixelsY: centre of circle (Y coordinate)
;
; On Exit:
;       .circlePointRightY: centre row Y - .circlePointYLow/High
;       .circlePointLeftY : .circlePointRightY
;
; ***************************************************************************************
.reflectPointVerticallyAboutCircleCentre
    ; .circlePointLeftY  = .circlePointRightY = centre Y - .circlePointY
    SEC                                                 ;
    LDA .vduOldGraphicsCursorPixelsYLow                 ; circle centre Y
    SBC .circlePointYLow                                ;
    STA .circlePointRightYLow                           ;
    STA .circlePointLeftYLow                            ;

    LDA .vduOldGraphicsCursorPixelsYHigh                ; circle centre Y
    SBC .circlePointYHigh                               ;
    STA .circlePointRightYHigh                          ;
    STA .circlePointLeftYHigh                           ;
    RTS                                                 ;

; ***************************************************************************************
;
; Square a 16 bit number
;
; ***************************************************************************************
.square12_into4567
    LDA .gxrTemp2                                       ;
    BPL +                                               ;

    ; negate values (abs)
    SEC                                                 ; }
    LDA #0                                              ; }
    SBC .gxrTemp1                                       ; }
    STA .gxrTemp1                                       ; } .gxrTemp1 = -.gxrTemp1
    LDA #0                                              ; } .gxrTemp2 = -.gxrTemp2
    SBC .gxrTemp2                                       ; }
    STA .gxrTemp2                                       ; }
+

    ; copy first parameter into second parameter (to multiply the number by itself)
    LDA .gxrTemp1                                       ; }
    STA .gxrTemp4                                       ; }
    LDA .gxrTemp2                                       ; } .gxrTemp45 = .gxrTemp12
    STA .gxrTemp5                                       ; }
    JMP .multiply16x16                                  ;

; ***************************************************************************************
;
; Initialise variables for drawing a segment
;
; On Entry:
;   .circleRadiusSquared:
;   .line1StartPoint: original end point
;
; ***************************************************************************************
.segmentInitialisation
    ; .ellipseTempABXY = .circleRadiusSquared (remember radius squared)
    LDY #3                                              ; loop counter
-
    LDA .circleRadiusSquaredLow,Y                       ;
    STA .ellipseTempA,Y                                 ;
    DEY                                                 ;
    BPL -                                               ; if (not done yet) then branch (loop back)

.calculateEndPointOnCircle
    ; Copy line 3 point to line 1 point
    LDY #3                                              ; loop counter
-
    LDA .line3StartPointX,Y                             ; }
    STA .line1StartPointX,Y                             ; } .line1StartPoint = .line3StartPoint
    DEY                                                 ; }
    BPL -                                               ; }

    ; At this point we know the radius (squared) of the circle we want. We walk along the end line from
    ; the centre until we reach the desired radius (squared).
    LDX #.line3StartPointX - .vduVariablesStart         ; line 3 = end line
    JSR .lineMoveToNextPixel                            ; move to next point on end line

    ; Get radius squared
    LDX #.line3StartPointX - .vduVariablesStart         ; current point along end line
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart ; centre of the circle
    JSR .getCircleRadiusSquared                         ; .circleRadiusSquaredLow is radius^2

    ; Is (radius based on start point)^2 >= (radius based on end point)^2?
    SEC                                                 ;
    LDX #3                                              ; loop counter
    LDY #0                                              ;
.circleLargerLoop
    LDA .ellipseTempA,Y                                 ;
    SBC .circleRadiusSquaredLow,Y                       ; calculate .ellipseTempABXY - .circleRadiusSquaredLow
    INY                                                 ; to see which is larger
    DEX                                                 ;
    BPL .circleLargerLoop                               ;

    BCS .calculateEndPointOnCircle                      ; if (.circleOPQR >= (new radius)^2) then loop back

    ; Now .circleRadiusSquared is the end point on the circle

    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart ; centre of circle (start of line)
    LDA #.vdu25ParameterXLow - .vduVariablesStart       ; PLOT parameter = end point (end of line)
    LDX #.line3StartPointX - .vduVariablesStart         ; where to put results
    JSR .lineInitialisation                             ;
    ; The line initialisation sets up line 3 variables:
    ;    .line3StartPointX: initial and current point X [2 bytes]
    ;    .line3StartPointY: initial and current point Y [2 bytes]
    ;    .line3AbsDeltaX  : abs(deltaX)                 [2 bytes]
    ;    .line3AbsDeltaY  : abs(deltaY)                 [2 bytes]
    ;    .line3ErrorTerm  : Bresenham error term        [2 bytes]
    ;    .line3Signs      : signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

    LDA .circleLine2Quadrant                            ;
    EOR .circleLine3Quadrant                            ;
    AND #2                                              ; if (start and end lines are in the same hemisphere,
    BEQ .return29                                       ; i.e. either both above or both below the centre row) then branch (return)

    ; Start and end lines are in different hemispheres
    LDA .circleLine2Quadrant                                ;
    LSR                                                     ;
    LSR                                                     ; carry = start line is below the centre line
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart  ; beginning of line (start point)
    LDA #.line1StartPointX - .vduVariablesStart             ; end of line       (new end point on the circle)
    LDX #.line2StartPointX - .vduVariablesStart             ; where to put results
    BCS +                                                   ; if (start line is below the centre line) then branch

    LDY #.line1StartPointX - .vduVariablesStart             ; beginning of line (new end point on the circle)
    LDA #.vduGraphicsCursorPixelsXLow - .vduVariablesStart  ; end of line       (start point)
    LDX #.line3StartPointX - .vduVariablesStart             ; where to put results
+
    STX .circleChordLine                                ; index of line for chord
    STA .circleChordDestinationPoint                    ; index of end point of chord
    JSR .lineInitialisation                             ; initialise line 2 or 3 to be the chord line

    LDX .circleLine2Quadrant                            ;
    LDA .circleQuadrants,X                              ;
    AND #1                                              ;
    STA .circleFlag                                     ; which side of line to plot
.return29
    RTS                                                 ;

; ***************************************************************************************
;
; Initialise segment when chord crosses centre row
;
; When drawing a circle segment, we initialise variables again when the chord crosses the centre
; row.
;
; ***************************************************************************************
.segmentInitialisationIfStraddlingTheCentreRow
    LDA .circleLine2Quadrant                            ;
    EOR .circleLine3Quadrant                            ;
    AND #2                                              ;
    BEQ .return29                                       ; if (both lines are above the centre line, or both below) then branch (return)

    ; line 2 and line 3 quadrants are either side of the horizontal centre line
    LDA .circleLine2Quadrant                            ;
    LSR                                                 ;
    LSR                                                 ;
    PHP                                                 ; remember carry: set if start line is below the horizontal centre line

    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; beginning of line (centre of circle)
    LDA #.vduGraphicsCursorPixelsXLow - .vduVariablesStart      ; end of line (start of arc)
    LDX #.line2StartPointX - .vduVariablesStart                 ; where to put results
    BCS +                                                       ; if (line 2 is below the centre line) then branch

    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; beginning of line (centre of circle)
    LDA #.vdu25ParameterXLow - .vduVariablesStart               ; end of line (original end of arc point)
    LDX #.line3StartPointX - .vduVariablesStart                 ; where to put results
+
    JSR .lineInitialisation                             ;

    PLP                                                 ; recall carry: set if start line is below the horizontal centre line
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart ; beginning of line (start point)
    LDA #.line1StartPointX - .vduVariablesStart         ; end of line       (new end point on the circle)
    LDX #.line2StartPointX - .vduVariablesStart         ; where to put results
    BCC +                                               ; if (start line is below the centre line) then branch

    LDY #.line1StartPointX - .vduVariablesStart         ; beginning of line (new end point on the circle)
    LDA #.vduGraphicsCursorPixelsXLow - .vduVariablesStart ; end of line       (start point)
    LDX #.line3StartPointX - .vduVariablesStart         ; where to put results
+
    STX .circleChordLine                                ; index of line for chord
    STA .circleChordDestinationPoint                    ; index of end point of chord
    JMP .lineInitialisation                             ; initialise line 2 or 3 to be the chord line

; ***************************************************************************************
;
; Prepare line and quadrant data for a circle arc / sector / segment.
;
; Each circle shape is defined by a circle centre, a start point on the circle, and an end
; point.
;
; Circles are drawn row by row starting from the horizontal centre line upwards (and at
; the same time reflected to get the rows downward).
;
; To explain what's going on:
;   The *start line* is from the centre to the start point of the arc / sector / segment.
;   The *end line* is from the centre to the end point of the arc / sector / segment.
;   The *chord line* is from the start point to the end point.
;
; The code tracks the start and end lines until it reaches the chord, where it replaces
; the line that just finished with the chord line.
;
; In the code the two lines being tracked are the .line2* and .line3* variables.
;
; Data used in the circle algorithms
; ----------------------------------
;
; Quadrants
; ---------
;
; We divide the screen into four quadrants, with the origin at the centre of the circle:
;
;                             deltaY
;                               /|\
;                                |
;                      quadrant  |  quadrant
;                         1      |      0
;                                |               \
;                 ---------------+----------------   deltaX
;                                |               /
;                      quadrant  |  quadrant
;                         2      |      3
;                                |
;
; Circle quadrant data
; --------------------
;
; At the start of a circle routine, this function calculates a single data byte for each quadrant.
; The byte value depends on which quadrants the start and end lines are in, and (if both in the same
; quadrant) the anticlockwise order the lines appear in.
;
; See below for more details of what the bytes mean, but here are the byte values calculated for each
; category:
;
; see sectors.png
;
; +-------+--------+-------+------++-----------------------------------------------------------+
; | start | end    | start | end  ||                  circle quadrant data                     |
; | angle | angle  | quad  | quad ||  quadrant 0  |  quadrant 1  |  quadrant 2  |  quadrant 3  |
; +-------+--------+-------+------++--------------+--------------+--------------+--------------+
; |  30°  |   60°  |   0   |   0  || 3A=0011 1010 |       0      |       0      |       0      |
; |  60°  |   30°  |   0   |   0  || 57=0101 0111 |       1      |       1      |       1      |
; |  30°  |  120°  |   0   |   1  || 0A=0000 1010 | 0E=0000 1110 |       0      |       0      |
; |  30°  |  210°  |   0   |   2  || 0A=0000 1010 |       1      | 07=0000 0111 |       0      |
; |  30°  |  300°  |   0   |   3  || 0A=0000 1010 |       1      |       1      | 0E=0000 1110 |
;
; | 120°  |   30°  |   1   |   0  || 07=0000 0111 | 03=0000 0011 |       1      |       1      |
; | 120°  |  150°  |   1   |   1  ||       0      | 1E=0001 1110 |       0      |       0      |
; | 150°  |  120°  |   1   |   1  ||       1      | 73=0111 0011 |       1      |       1      |
; | 120°  |  210°  |   1   |   2  ||       0      | 03=0000 0011 | 07=0000 0111 |       0      |
; | 120°  |  300°  |   1   |   3  ||       0      | 03=0000 0011 |       1      | 0E=0000 1110 |
;
; | 210°  |   30°  |   2   |   0  || 07=0000 0111 |       0      | 0A=0000 1010 |       1      |
; | 210°  |  120°  |   2   |   1  ||       1      | 0E=0000 1110 | 0A=0000 1010 |       1      |
; | 210°  |  240°  |   2   |   2  ||       0      |       0      | 3A=0011 1010 |       0      |
; | 240°  |  210°  |   2   |   2  ||       1      |       1      | 57=0101 0111 |       1      |
; | 210°  |  300°  |   2   |   3  ||       0      |       0      | 0A=0000 1010 | 0E=0000 1110 |
;
; | 300°  |   30°  |   3   |   0  || 07=0000 0111 |       0      |       0      | 03=0000 0011 |
; | 300°  |  120°  |   3   |   1  ||       1      | 0E=0000 1110 |       0      | 03=0000 0011 |
; | 300°  |  210°  |   3   |   2  ||       1      |       1      | 07=0000 0111 | 03=0000 0011 |
; | 300°  |  330°  |   3   |   3  ||       0      |       0      |       0      | 1E=0001 1110 |
; | 330°  |  300°  |   3   |   3  ||       1      |       1      |       1      | 73=0111 0011 |
; +-------+--------+-------+------++--------------+--------------+--------------+--------------+
;
; One byte for each quadrant:
;
;    0 means nothing to plot in the quadrant
;    1 means plot in the entire quadrant
;
; else: (the start line and/or end line is in the quadrant)
;
;     bit 0 = for an even quadrant, set if the end line is in the quadrant
;             for an odd quadrant, set if the start line is in the quadrant
;     bit 1 = set if either the start or end line is in the quadrant (always set)
;     bit 2 = set if the end point is in quadrant
;     bit 3 = bit 0 inverted:
;             for an even quadrant, set if the start line is in the quadrant
;             for an odd quadrant, set if the end line is in the quadrant
;     bit 4 = set if start and end lines are in the same quadrant
;     bit 5 = set if start and end lines are in the same quadrant, and start point is closer to the
;             horizontal centre line
;     bit 6 = set if start and end lines are in the same quadrant, and start angle is larger
;     bit 7 = 0

; On Exit:
;   .line2*: variables for centre to start point
;   .line3*: variables for centre to end point
;   .circleQuadrants: four single byte values, one per quadrant (see above)
;
; ***************************************************************************************
.circleDoLineAndQuadrantInitialisation
    ; Zero quadrant information, (one byte per quadrant, four bytes in total)
    LDY #3                                              ; loop counter
    LDA #0                                              ;
-
    STA .circleQuadrants,Y                              ;
    DEY                                                 ;
    BPL -                                               ;

    ; Line 2 is from the centre of the circle to the start point
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; beginning of line (circle centre)
    LDA #.vduGraphicsCursorPixelsXLow - .vduVariablesStart      ; end of line       (arc start point)
    LDX #.line2StartPointX - .vduVariablesStart                 ; where to put results
    JSR .lineInitialisation                                     ;
    ; The line initialisation sets up variables for line 2:
    ;    .line2StartPointX: initial and current point X [2 bytes]
    ;    .line2StartPointY: initial and current point Y [2 bytes]
    ;    .line2AbsDeltaX  : abs(deltaX)                 [2 bytes]
    ;    .line2AbsDeltaY  : abs(deltaY)                 [2 bytes]
    ;    .line2ErrorTerm  : Bresenham error term        [2 bytes]
    ;    .line2Signs      : signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

    ; Calculate and store quadrant for line 2
    LDX #.line2StartPointX - .vduVariablesStart         ;
    JSR .getQuadrant                                    ;
    STA .circleLine2Quadrant                            ;

    ; Line 3 is from the centre of the circle to the end point
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; beginning of line (circle centre)
    LDA #.vdu25ParameterXLow - .vduVariablesStart               ; end of line       (arc end point)
    LDX #.line3StartPointX - .vduVariablesStart                 ; where to put results
    JSR .lineInitialisation                                     ;
    ; The line initialisation sets up variables for line 3:
    ;    .line3StartPointX: initial and current point X [2 bytes]
    ;    .line3StartPointY: initial and current point Y [2 bytes]
    ;    .line3AbsDeltaX  : abs(deltaX)                 [2 bytes]
    ;    .line3AbsDeltaY  : abs(deltaY)                 [2 bytes]
    ;    .line3ErrorTerm  : Bresenham error term        [2 bytes]
    ;    .line3Signs      : signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

    ; Calculate and store quadrant for line 3
    LDX #.line3StartPointX - .vduVariablesStart         ;
    JSR .getQuadrant                                    ;
    STA .circleLine3Quadrant                            ;

    ; Is the line 3 quadrant the same as line 2 quadrant?
    CMP .circleLine2Quadrant                            ;
    BEQ .sameQuadrant                                   ;

    ; lines 2 and 3 are in different quadrants

    ; line 3 (centre to end point) quadrant has a value associated and stored in circleQuadrants array:
    ;
    ; quadrant | value  binary
    ;        0 |  7     %0111
    ;        1 | 14     %1110
    ;        2 |  7     %0111
    ;        3 | 14     %1110
    ;
    ; bit 0 = odd quadrant (which side of the start line to plot in)
    ; bit 1 = either start or end line in quadrant
    ; bit 2 = end point in quadrant
    ; bit 3 = even quadrant (which side of the end line to plot in)

    TAY                                                 ; Y = line 3 quadrant
    ROR                                                 ; set carry if quadrant is odd
    LDA #7                                              ; A=7 if line 3 quadrant is 0 or 2
    BCC +                                               ; if (quadrant is 0 or 2) then branch
    EOR #9                                              ; A=14 (quadrant is 1 or 3)  [NOTE: could do LDA #14]
+
    STA .circleQuadrants,Y                              ; store in offset for the relevant quadrant

    ; line 2 (centre to start point) quadrant has a value associated and stored in circleQuadrants array:
    ;
    ; quadrant | value  binary
    ;        0 | 10     %1010
    ;        1 |  3     %0011
    ;        2 | 10     %1010
    ;        3 |  3     %0011
    ;
    ; bit 0 = even quadrant (which side of the start line to fill in)
    ; bit 1 = either start or end line in quadrant
    ; bit 2 = end point in quadrant
    ; bit 3 = odd quadrant (which side of the end line to fill in)

    LDA .circleLine2Quadrant                            ;
    TAY                                                 ; Y = line 2 quadrant
    ROR                                                 ; set carry if quadrant is odd
    LDA #10                                             ; A=10 if line 2 quadrant is 0 or 2
    BCC .fillQuadrantDataLoop                           ; if (quadrant is 0 or 2) then branch
    EOR #9                                              ; A=3 (quadrant is 1 or 3)   [NOTE: could do LDA #3]
    BCS .fillQuadrantDataLoop                           ; ALWAYS branch

.sameQuadrant
    ; Copy line 2 abs(deltaY) and line 3 abs(deltaX) in order to multiply them.
    ; This is then used to test which line is further around the circle anticlockwise
    LDY #1                                              ; loop counter
-
    LDA .line2AbsDeltaY,Y                               ;
    STA .multiplicand0,Y                                ;
    LDA .line3AbsDeltaX,Y                               ;
    STA .multiplier0,Y                                  ;
    DEY                                                 ;
    BPL -                                               ;

    JSR .multiply16x16                                  ; .line2AbsDeltaY * .line3AbsDeltaX

    ; Copy 32 bit result into .circleSlopeTest
    LDY #3                                              ;
-
    LDA .product0,Y                                     ;
    STA .circleSlopeTestLow,Y                           ;
    DEY                                                 ;
    BPL -                                               ;

    ; Copy line 2 abs(deltaX) and line 3 abs(deltaY) in order to multiply them
    ; This is then used to test which line is further around the circle anticlockwise
    LDY #1                                              ; loop counter
-
    LDA .line3AbsDeltaY,Y                               ;
    STA .multiplicand0,Y                                ;
    LDA .line2AbsDeltaX,Y                               ;
    STA .multiplier0,Y                                  ;
    DEY                                                 ;
    BPL -                                               ;

    JSR .multiply16x16                                  ; .line3AbsDeltaY * .line2AbsDeltaX

    LDX #3                                              ; loop counter
    LDY #0                                              ; index
    LDA .circleLine2Quadrant                            ;
    ROR                                                 ;
    BCS .checkWhichIsLargerLoop2                        ; if (line 2 quadrant is 1 or 3) then branch

    ; Which is larger: .circleSlopeTest or .product0
    ; i.e. (.line2AbsDeltaY * .line3AbsDeltaX) or (.line3AbsDeltaY * .line2AbsDeltaX)
    ; i.e. (.line2AbsDeltaY / .line2AbsDeltaX) or (.line3AbsDeltaY / .line3AbsDeltaX)
    ; i.e. testing which line has the larger slope (rearranged to avoid expensive
    ;      divisions and division by zero issues).
    SEC                                                 ;
.checkWhichIsLargerLoop1
    LDA .product0,Y                                     ;
    SBC .circleSlopeTestLow,Y                           ;
    INY                                                 ;
    DEX                                                 ;
    BPL .checkWhichIsLargerLoop1                        ;
    BMI .doneChecking                                   ; ALWAYS branch

    ; Which is larger, .product0 or .circleSlopeTest
.checkWhichIsLargerLoop2
    LDA .circleSlopeTestLow,Y                           ;
    SBC .product0,Y                                     ;
    INY                                                 ;
    DEX                                                 ;
    BPL .checkWhichIsLargerLoop2                        ;

.doneChecking
    ; Carry holds which slope is bigger (i.e. which line is sloped further away from the X axis)
    ; Adjust values as needed
    LDA #%00111010                                      ;
    BCS +                                               ;
    EOR #%01101101                                      ;
+
    ROR .circleLine2Quadrant                            ;
    BCC +                                               ;
    EOR #%00100100                                      ;
+
    ROL .circleLine2Quadrant                            ;
    LDY .circleLine2Quadrant                            ;
    STA .circleQuadrants,Y                              ; store value in quadrant data
    BCS .return21                                       ;

.fillQuadrantDataLoop
    ; Fill each quadrant between the start line quadrant to the end line quadrant going
    ; anticlockwise. Fill with the value 1 (all of quadrant can be plotted). The remaining
    ; quadrants store zero as initialised at the top of the routine.
    STA .circleQuadrants,Y                              ; store value in quadrant data
    INY                                                 ; }
    TYA                                                 ; } move to next quadrant anticlockwise
    AND #3                                              ; }
    CMP .circleLine3Quadrant                            ; have we reached the end quadrant
    BEQ .return21                                       ; if (same quadrant as line 3) then branch (return)

    TAY                                                 ; new quadrant back into Y
    LDA #1                                              ; new value to store
    JMP .fillQuadrantDataLoop                           ;

.return21
    RTS                                                 ;

; ***************************************************************************************
;
; Get the quadrant of the line's direction
;
;                             deltaY
;                               /|\
;                                |
;                      quadrant  |  quadrant
;                         1      |      0
;                                |               \
;                 ---------------+----------------   deltaX
;                                |               /
;                      quadrant  |  quadrant
;                         2      |      3
;                                |
;
; On Entry:
;   X: index of line to check
; On Exit:
;   A: quadrant of line
;
; ***************************************************************************************
.getQuadrant
    LDA .vduVariablesStart + 10,X                       ; look at the line signs
    AND #$C0                                            ; just the top two bits
    ASL                                                 ;
    BCS .negativeDeltaY                                 ; if (deltaY < 0) then branch

    ROL                                                 ; A = 0, carry = sgn(deltaX)
    ROL                                                 ; A = 0 if deltaX>=0
    RTS                                                 ; A = 1 if deltaX<0

.negativeDeltaY
    ROL                                                 ; carry = sgn(deltaX), A=1
    ROL                                                 ; (A = 2 if deltaX>=0)
                                                        ; (A = 3 if deltaX<0)
    EOR #1                                              ; A = 2 if deltaX<0
                                                        ; A = 3 if deltaX>=0
    RTS                                                 ;

; ***************************************************************************************
;
; Circle arc / sector / segment quadrant preparation
;
; On Entry:
;   Y is quadrant to use
;   .circlePointRight: point on circle to the right
;   .circlePointLeft:  point on circle to the left
; On Exit:
;   .circleTrackingLeftmostChordPoint:
;   .circleTrackingSecondLineInQuadrant:
;   .circleRadialLine:
;   .circleTrackingRightmostChordPoint:
;
; ***************************************************************************************
.circlePrepareForRightSideQuadrant
    LDA #.circlePointRightXLow - .vduVariablesStart     ;
    STA .circleTrackingLeftmostChordPoint               ; leftmost point = right point
    LDA #0                                              ;
    STA .circleTrackingSecondLineInQuadrant             ;
    STA .circleRadialLine                               ; radial line = 0

    JSR .circlePrepareForLeftSideQuadrant               ; prepare for left side, then swap results

    ; Copy left result into right side
    LDA .circleTrackingLeftmostChordPoint               ;
    STA .circleTrackingRightmostChordPoint              ;

    LDA .circleTrackingSecondLineInQuadrant             ; }
    PHA                                                 ; }
    LDA .circleRadialLine                               ; } swap second line and radial line
    STA .circleTrackingSecondLineInQuadrant             ; }
    PLA                                                 ; }
    STA .circleRadialLine                               ; }

    LDA #.circlePointLeftXLow - .vduVariablesStart      ;
    STA .circleTrackingLeftmostChordPoint               ; .circleTrackingLeftmostChordPoint = left point
    RTS                                                 ;

; ***************************************************************************************
;
; Circle arc / sector / segment quadrant preparation
;
; Updates line tracking for the given quadrant. Used for the left hand quadrants 1,2 but also
; called by the right hand quadrant code (.circlePrepareForRightSideQuadrant above) with quadrant
; values 0, 3.
;
; On Entry:
;   Y: quadrant to prepare (0-3)
;   .circlePointLeft: point on circle to the right
;   .circlePointRight: point on circle to the left
;   .circleQuadrants: line information about each quadrant
;   .circleTrackingLeftmostChordPoint : index of point on circle
;   .circleTrackingSecondLineInQuadrant:
;   .circleRadialLine:
;
; On Exit:
;   .circleTrackingLeftmostChordPoint : which line to check against when deciding whether
;                                       to plot; zero means nothing to plot in this quadrant
;   .circleTrackingSecondLineInQuadrant:
;   .circleRadialLine:
;
; ***************************************************************************************
.circlePrepareForLeftSideQuadrant
    LDA #0                                              ;
    STA .circleQuadrantDataShifter                      ; how many times to shift the quadrant data when starting to track the chord
    LDA .circleQuadrants,Y                              ;

    ; .circleQuadrants stores one byte for each quadrant:
    ;
    ;    0 means nothing to plot in the quadrant
    ;    1 means plot in the entire quadrant
    ;
    ; else: (the start line and/or end line is in the quadrant)
    ;
    ;     bit 0 = for an even quadrant, set if the end line is in the quadrant
    ;             for an odd quadrant, set if the start line is in the quadrant
    ;             This determines if plotting is wanted to the left of the line in the left side quadrant
    ;     bit 1 = set if either the start or end line is in the quadrant (always set)
    ;     bit 2 = set if the end point is in quadrant
    ;     bit 3 = bit 0 inverted:
    ;             for an even quadrant, set if the start line is in the quadrant
    ;             for an odd quadrant, set if the end line is in the quadrant
    ;     bit 4 = set if start and end lines are in the same quadrant
    ;     bit 5 = set if start and end lines are in the same quadrant, and start point is closer to the horizontal centre line
    ;     bit 6 = set if start and end lines are in the same quadrant, and start angle is larger
    ;     bit 7 = 0

    LSR                                                 ;
    BNE .lineFoundInQuadrant                            ; if (a line is in the quadrant) then branch

    ; No line in quadrant
    BCS .return22                                       ; if (plot in the entire quadrant) then branch (return)
    STA .circleTrackingLeftmostChordPoint               ; if (nothing in this quadrant to plot) then (return with .circleTrackingLeftmostChordPoint = 0)
.return22
    RTS                                                 ;

.lineFoundInQuadrant
    ; At least one of the two lines is within the quadrant.
    PHP                                                 ; push carry flag (was bit 0)
    LSR                                                 ;
    LSR                                                 ; carry = set if end line is in quadrant Y
    STY .circleCurrentQuadrant                          ; remember Y (current quadrant)

    ; We have a start line (line 2) and an end line (line 3).
    ; We make sure X is set to the index of the line that is within the quadrant, and Y is the other line.
    LDX #.line2StartPointX - .vduVariablesStart         ; } X is the line we are tracking (the start line), Y is the other line (the end line)
    LDY #.line3StartPointX - .vduVariablesStart         ; } (used when the end line is not in the quadrant)
    BCC +                                               ; if (end line not in quadrant) then branch

    ; End line in quadrant, use X=end line
    LDX #.line3StartPointX - .vduVariablesStart         ; } X is the line we are tracking (the end line), Y is the other line (the start line)
    LDY #.line2StartPointX - .vduVariablesStart         ; } used when the end line is in the quadrant
+

    STY .circleSecondaryLine                            ; remember the second line (we might need to track it, if it's also in the same quadrant)
    LDY .circleTrackingLeftmostChordPoint               ; index of point on circle at left end of chord
    PLP                                                 ; recall carry flag (from bit 0: which side of line in quadrant to plot)
    BCS .canPlotLeftOfLineInQuadrant                    ; if (side of line to plot is one way) then branch

    ; Can plot to the right of the line in the quadrant.
    ; Update this line until we reach a new row.
    JSR .updateLineAndMoveToNextRow                     ;
    BPL .stillTrackingLineA                             ; if (we are still tracking the line) then branch

    ; Start tracking along the chord instead of the start or end line that has just finished
    JSR .startTrackingChord                             ;
    LDY .circleCurrentQuadrant                          ; recall current quadrant
    JMP .circlePrepareForLeftSideQuadrant               ; loop back

.stillTrackingLineA
    BNE +                                               ;
    STX .circleTrackingLeftmostChordPoint               ;
+
    LDX .circleCurrentQuadrant                          ; recall current quadrant
    LDA .circleQuadrants,X                              ;
    AND #$F0                                            ;
    BEQ .startTrackingChordLocal1                       ; if (no second line in quadrant) then branch

    ; Tracking two lines in the quadrant, update the second line
    LDX .circleSecondaryLine                            ; recall the secondary line we are tracking
    JSR .updateLineToEndOfRow                           ;
    BEQ +                                               ; if (line has not yet reached the circle point) then branch

    ; Second line has reached circle
    LDA #2                                              ;
    STA .circleQuadrantDataShifter                      ; how many times to shift the quadrant data when starting to track the chord

+
    STX .circleTrackingSecondLineInQuadrant             ; remember line we are tracking (the second line in the quadrant)
.startTrackingChordLocal1
    JMP .startTrackingChordWithCorrectQuadrantData      ;


    ; Similar to above code
.canPlotLeftOfLineInQuadrant
    ; Can plot to the left of the line in the quadrant.
    ; Update this line until we reach a new row.
    JSR .updateLineToEndOfRow                           ;
    BPL .stillTrackingLineB                             ; if (we are still tracking the line) then branch

    ; Start tracking along the chord instead of the start or end line that has just finished
    JSR .startTrackingChord                             ;
    LDY .circleCurrentQuadrant                          ; recall current quadrant
    JMP .circlePrepareForLeftSideQuadrant               ; loop back

.stillTrackingLineB
    STX .circleTrackingSecondLineInQuadrant             ; remember line we are tracking (the second line in the quadrant)
    LDX .circleCurrentQuadrant                          ; recall current quadrant
    LDA .circleQuadrants,X                              ;
    AND #$F0                                            ; check if we are tracking two lines in the quadrant
    BEQ .startTrackingChordLocal2                       ; if (no second line in quadrant) then branch

    ; Tracking two lines in the quadrant, update the second line
    LDX .circleSecondaryLine                            ; recall the secondary line we are tracking
    JSR .updateLineAndMoveToNextRow                     ;
    BEQ .secondLineNotReachedCircleYet                  ; if (not yet reached circle) then branch

    ; Second line has reached circle
    LDA #2                                              ;
    STA .circleQuadrantDataShifter                      ; how many times to shift the quadrant data when starting to track the chord

.secondLineNotReachedCircleYet
    STX .circleRadialLine                               ; remember second line we are tracking
.startTrackingChordLocal2
    JMP .startTrackingChordWithCorrectQuadrantData      ; [NOTE: Redundant, could just fall through]

; ***************************************************************************************
.startTrackingChordWithCorrectQuadrantData
    DEC .circleQuadrantDataShifter                      ; how many times to shift the quadrant data when starting to track the chord
    BMI .return24                                       ; if (done) then return

    JSR .startTrackingChord                             ;
    ; Shift quadrant data bits down and start tracking the chord line
    JMP .startTrackingChordWithCorrectQuadrantData      ;

.return24
    RTS                                                 ;

; ***************************************************************************************
;
; We have reached the start of the chord
;
; We track the chord line by reusing line 2 or line 3, i.e. reusing the start or end line
; that we have just finished tracking.
;
; On Exit:
;   X, .circleChordLine:            index of the current chord line
;   .circleChordDestinationPoint:   index of the end of the chord point
;
; ***************************************************************************************
.startTrackingChord
    LDX .circleCurrentQuadrant                          ;

    ; Shift quadrant data down three bits
    LDA .circleQuadrants,X                              ; }
    LSR                                                 ; }
    LSR                                                 ; } shift right quadrant data by three bits
    LSR                                                 ; } carry = which side of line to plot (for end line)
    STA .circleQuadrants,X                              ; }
    AND #1                                              ;
    STA .circleFlag                                     ; which side of line to plot

    LDA .circleChordLine                                ; }
    BEQ +                                               ; } clear chord line
    LDA #0                                              ; } [NOTE: Redundant, .circleChordLine is set below]
    STA .circleChordLine                                ; }
+
    LDY #.line2StartPointX - .vduVariablesStart             ; line from: current point along start line
    LDA #.line1StartPointX - .vduVariablesStart             ; line to:   point on circle at end line
    LDX #.line2StartPointX - .vduVariablesStart             ; where to put results
    BCC +                                                   ; if (which side of line to plot) then branch

    LDY #.line3StartPointX - .vduVariablesStart             ; line from: current point on end line
    LDA #.vduGraphicsCursorPixelsXLow - .vduVariablesStart  ; line to: initial arc start point
    LDX #.line3StartPointX - .vduVariablesStart             ; where to put results
+
    STX .circleChordLine                                ; index of chord line
    STA .circleChordDestinationPoint                    ; index of end of chord point
    JMP .lineInitialisation                             ; start tracking the chord line

; ***************************************************************************************
;
; Updates tracking the position along the current line
;
; ... until we either:
;       (a) move incrementally to a new row (the common case),
;       (b) hit the given point on the circle (marking the end of the line tracking), or
;       (c) reach the same X as the point on the circle but not the same Y
;
; On Entry:
;   X: index of line
;   Y: index of circle point
;
; On Exit:
;   Zero flag: non-zero if the line has reached the circle. We don't need to continue tracking
;      the line any further.
;   Negative flag: set if the Y coordinates don't match but the X coordinates do.
;
;   Preserves X,Y
;
; ***************************************************************************************
.updateLineToEndOfRow
    ; We first compare the current point along the line (indexed by the X register)
    ; against the current point on the circle (indexed by the Y register)

    ; If Y coordinate doesn't match, then branch
    LDA .vduVariablesStart+2,Y                          ;
    CMP .vduVariablesStart+2,X                          ;
    BNE .yCoordinatesDontMatch                          ;

    LDA .vduVariablesStart+3,Y                          ;
    CMP .vduVariablesStart+3,X                          ;
    BNE .yCoordinatesDontMatch                          ;

    ; Y coordinates match. If X coordinates don't match, then return 0 else return 1
    LDA .vduVariablesStart,Y                            ;
    CMP .vduVariablesStart,X                            ;
    BNE .xCoordinatesDontMatch                          ;

    LDA .vduVariablesStart+1,Y                          ;
    CMP .vduVariablesStart+1,X                          ;
    BNE .xCoordinatesDontMatch                          ;

    ; Both the X and Y coordinates match the circle position.
    INC .circleQuadrantDataShifter                      ; how many times to shift the quadrant data when starting to track the chord
    LDA #1                                              ; finished tracking line
    RTS                                                 ;

.xCoordinatesDontMatch
    LDA #0                                              ; not finished tracking line
    RTS                                                 ;

.yCoordinatesDontMatch
    ; Check X if coordinates match
    LDA .vduVariablesStart,Y                            ;
    CMP .vduVariablesStart,X                            ;
    BNE .moveAlongRow                                   ;

    LDA .vduVariablesStart+1,Y                          ;
    CMP .vduVariablesStart+1,X                          ;
    BEQ .rorAndReturn                                   ; if (X coordinates match) then branch (note that carry is set in this case)

.moveAlongRow
    ; Move one pixel along the line (preserving X and Y registers) and loop back to try again
    STX .vduTempStoreDE                                 ; }
    STY .vduTempStoreDF                                 ; } remember X,Y

    JSR .lineMoveToNextPixel                            ; move to next point on line X

    LDX .vduTempStoreDE                                 ; } recall X,Y
    LDY .vduTempStoreDF                                 ; }
    JMP .updateLineToEndOfRow                           ;

.rorAndReturn
    ROR                                                 ; carry (always set in practice)
                                                        ; is shifted into top bit of A,
    RTS                                                 ; setting the Negative flag.

; ***************************************************************************************
;
; Update the line until we reach a new row, then move to that new row
;
; On Entry:
;   X: index of the line we are updating
;   Y: index of point on the circle
;
; On Exit:
;   Zero flag: non-zero if the line has reached the circle. We don't need to continue tracking
;      the line any further.
;   Negative flag: set if the X coordinates match but the Y coordinates don't.
;
; ***************************************************************************************
.updateLineAndMoveToNextRow
    JSR .updateLineToEndOfRow                           ;
    BEQ .moveToNextRow                                  ; if (not yet reached the point on the circle) then branch
    RTS                                                 ; [NOTE: Could use BNE .return20]

.moveToNextRow
    LDA .vduVariablesStart,Y                            ; } check line X coordinates to see if they match
    CMP .vduVariablesStart,X                            ; } if not, then branch
    BNE .xCoordsDontMatch                               ; }

    LDA .vduVariablesStart+1,Y                          ; }
    CMP .vduVariablesStart+1,X                          ; }
    BNE .xCoordsDontMatch                               ; }

    ; X coordinates match, we have reached the end of the row. Move to the next row and stop.
    ROL                                                 ; negative flag = bit 6 of high byte of X coordinate [NOTE: why?]
    INC .circleQuadrantDataShifter                      ; how many times to shift the quadrant data when starting to track the chord
    RTS                                                 ;

.xCoordsDontMatch
    CLC                                                 ;
    LDA .vduVariablesStart+9,X                          ; }
    AND #$80                                            ; } get sign of the error term (top bit)
    ROL                                                 ; carry = sign of error term, A=0
    BCS .return20                                       ; if (error term < 0) then branch (return)

    ; Move one pixel along the line (preserving X and Y registers) then loop back to try again
    STX .vduTempStoreDE                                 ; }
    STY .vduTempStoreDF                                 ; } remember X,Y
    JSR .lineMoveToNextPixel                            ; move to next point on line X
    LDX .vduTempStoreDE                                 ; } recall X,Y
    LDY .vduTempStoreDF                                 ; }

    JMP .moveToNextRow                                  ;

.return20
    RTS                                                 ; [NOTE: this can be removed and the previous RTS instruction used instead]

; ***************************************************************************************
;
; When drawing a circle segment, update the position along the chord
;
; Moves the position along the chord on the current row until we reach the point of moving
; to the next row.
;
; On Entry:
;   .circleChordLine: index of chord point
;   .circleChordDestinationPoint: index of destination point for chord
;   .circleFlag: set if on a new row
;   .circlePointLeftY: Y coordinate of point on circle
;
; Line drawing/tracking variables
;
; ***************************************************************************************
.advanceAlongChordLineUntilNewRow
    ; First test that we are on the same Y coordinate as the current point on the circle.
    ; If not then we loop until we are. Then we start tracking horizontally.
    LDX .circleChordLine                                ;
    LDA .vduVariablesStart+2,X                          ; get Y position along chord, compare it to current Y position on circle
    CMP .circlePointLeftYLow                            ; current Y coordinate on circle
    BNE .trackingChordLineVertically                    ; if (current point Y != .point on circle Y) then branch (update error term and try again)

    LDA .vduVariablesStart+3,X                          ;
    CMP .circlePointLeftYHigh                           ; current Y coordinate on circle
    BEQ .trackingChordLineHorizontally                  ;

.trackingChordLineVertically
    JSR .lineMoveToNextPixel                            ; move to next point on line X
    JMP .advanceAlongChordLineUntilNewRow               ;

; ***************************************************************************************
.trackingChordLineHorizontally
    LDA .circleFlag                                     ;
    BEQ .return23                                       ;

.moveAlongChordHorizontallyLoop
    ; Check if the current chord X position equals the current circle X position
    LDY .circleChordDestinationPoint                    ; check if chord line's current X position
    LDA .vduVariablesStart,X                            ; equals the chord destination point.
    CMP .vduVariablesStart,Y                            ;
    BNE +                                               ;

    LDA .vduVariablesStart+1,X                          ;
    CMP .vduVariablesStart+1,Y                          ;
    BEQ .return23                                       ; if equal then return

    ; X coordinates don't match.
    ; If ready for a new row, then return
+
    LDA .vduVariablesStart+9,X                          ; get error term
    ROL                                                 ; }
    BCS .return23                                       ; } if (error term < 0) then return [NOTE: could use BMI .return23 without the ROL?]

    ; Move to next pixel along chord line
    JSR .lineMoveToNextPixel                            ; move to next point on line X
    LDX .circleChordLine                                ;
    JMP .moveAlongChordHorizontallyLoop                 ;

.return23
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 17: Lines
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Line initialisation
;
; Used when drawing a line, triangle, circle segment or circle sector.
;
; see bear.gif
;
; Used to initialise variables to track the rasterisation of a straight line.
; e.g. Takes the difference of the coordinates to find the delta X and delta Y of the line.
; Initialises the error term of Bresenham's algorithm.
;
; On Entry:
;   A: vdu index of line end point
;   Y: vdu index of line start point
;   X: vdu index, where to store results
;       in practice X is one of .line1StartPointX
;                               .line2StartPointX
;                               .line3StartPointX
;
; On Exit:
;   vdu[X+0,X+1]: start point X
;   vdu[X+2,X+3]: start point Y
;   vdu[X+4,X+5]: abs(deltaX)
;   vdu[X+6,X+7]: abs(deltaY)
;   vdu[X+8,X+9]: initial error term
;   vdu[X+10]: bit 7 is sgn(deltaY) and bit 6 is sgn(deltaX)
;   Preserves X
;
; ***************************************************************************************
.lineInitialisation
    PHA                                                 ; }
    STA .gxrScratchspace3                               ; }
    TYA                                                 ; } remember A,Y
    PHA                                                 ; }
    LDA .gxrScratchspace3                               ; }

    ; vdu[X+0,X+1] = vdu[Y+0,Y+1]   (start point X)
    ; vdu[X+2,X+3] = vdu[Y+2,Y+3]   (start point Y)
    ; vdu[X+4,X+5] = vdu[A+0,A+1] - vdu[Y+0,Y+1]    (deltaX)
    ; vdu[X+6,X+7] = vdu[A+2,A+3] - vdu[Y+2,Y+3]    (deltaY)
    JSR .copyAndSubtractCoordinates                     ;

    PLA                                                 ; }
    TAY                                                 ; } recall A,Y
    PLA                                                 ; }

    ; Move on by two to do the same for the Y coordinates
    INY                                                 ;
    INY                                                 ; Y += 2
    CLC                                                 ;
    ADC #2                                              ; A += 2
    INX                                                 ;
    INX                                                 ; X += 2
    JSR .copyAndSubtractCoordinates                     ;
    DEX                                                 ; X -= 2
    DEX                                                 ;

    ; The rest of this routine takes two 16 bit signed numbers:
    ;
    ;       a = vdu[X+4,X+5]        = deltaX
    ;       b = vdu[X+6,X+7]        = deltaY
    ;
    ; and performs the following calculation:
    ;
    ;   isALarger = (a > b)                 ; remember which is larger
    ;   vdu[X+10] = 128*sgn(b) + 64*sgn(a)  ; remember the sign bits
    ;   a = abs(a)                          ; take absolute value
    ;   b = abs(b)                          ; take absolute value
    ;   temp = max(a, b)
    ;   if isALarger then temp -= 1
    ;   vdu[X+8,X+9] (error term) = temp/2 - b

    ; Work out which is larger: vdu[X+6,X+7] or vdu[X+4,X+5]
    LDA .vduVariablesStart + 6,X                        ;
    CMP .vduVariablesStart + 4,X                        ;
    LDA .vduVariablesStart + 7,X                        ;
    SBC .vduVariablesStart + 5,X                        ;
    PHP                                                 ; carry set if vdu[X+6,X+7] >= vdu[X+4,X+5]

    ; Remember signs of vdu[X+4,X+5] and vdu[X+6,X+7] in top two bits of vdu[X+10]
    LDA .vduVariablesStart + 5,X                        ;
    ASL                                                 ; shift top bit of vdu[X+5] into vdu[X+10]
    ROR .vduVariablesStart + 10,X                       ;
    LDA .vduVariablesStart + 7,X                        ;
    ASL                                                 ; shift top bit of vdu[X+7] into vdu[X+10]
    ROR .vduVariablesStart + 10,X                       ;
    BPL .doneAbsY                                       ;

    ; Negate vdu[X+6,X+7] to get the absolute value
    INX                                                 ;
    INX                                                 ;
    JSR .negateVDUX45                                   ;
    DEX                                                 ;
    DEX                                                 ;

.doneAbsY
    LDA .vduVariablesStart + 10,X                       ; get sign of vdu[X+4,X+5]
    ROL                                                 ;
    BPL +                                               ;

    ; Negate vdu[X+4,X+5] to get the absolute value
    JSR .negateVDUX45                                   ;

+
    ; Work out which is larger: vdu[X+6,X+7] or vdu[X+4,X+5]
    LDA .vduVariablesStart + 6,X                        ;
    CMP .vduVariablesStart + 4,X                        ;
    LDA .vduVariablesStart + 7,X                        ;
    SBC .vduVariablesStart + 5,X                        ;
    BMI .fourFiveIsLarger                               ;

    ; AY = vdu[X+6,X+7]
    LDA .vduVariablesStart + 7,X                        ;
    LDY .vduVariablesStart + 6,X                        ;
    JMP .gotMax                                         ;

.fourFiveIsLarger
    ; AY = vdu[X+4,X+5]
    LDA .vduVariablesStart + 5,X                        ;
    LDY .vduVariablesStart + 4,X                        ;

.gotMax
    PLP                                                 ;
    BMI .skipSubtractOne                                ;

    ; AY -= 1
    INY                                                 ; } [NOTE: use 'CPY #0' for two fewer cycles]
    DEY                                                 ; }
    BNE +                                               ;
    SEC                                                 ;
    SBC #1                                              ; A -= 1
+
    DEY                                                 ; Y -= 1

.skipSubtractOne
    ; vdu[X+8,X+9] = AY/2 - vdu[X+6,X+7]
    LSR                                                 ;
    PHA                                                 ;
    TYA                                                 ;
    ROR                                                 ;

    SEC                                                 ;
    SBC .vduVariablesStart + 6,X                        ;
    STA .vduVariablesStart + 8,X                        ;
    PLA                                                 ;
    SBC .vduVariablesStart + 7,X                        ;
    STA .vduVariablesStart + 9,X                        ;
    RTS                                                 ;

; ***************************************************************************************
;
; Copy and subtract coordinates
;
; vdu[X,X+1]   = vdu[Y,Y+1]
; vdu[X+4,X+5] = vdu[A,A+1] - vdu[X,X+1]
;
; ***************************************************************************************
.copyAndSubtractCoordinates
    STA .gxrScratchspace3                               ;
    LDA .vduVariablesStart,Y                            ;
    STA .vduVariablesStart,X                            ;
    LDA .vduVariablesStart+1,Y                          ;
    STA .vduVariablesStart+1,X                          ;

    LDY .gxrScratchspace3                               ;
    SEC                                                 ;
    LDA .vduVariablesStart,Y                            ;
    SBC .vduVariablesStart,X                            ;
    STA .vduVariablesStart+4,X                          ;
    LDA .vduVariablesStart+1,Y                          ;
    SBC .vduVariablesStart+1,X                          ;
    STA .vduVariablesStart+5,X                          ;
    RTS                                                 ;

; ***************************************************************************************
;
; Negate vdu[X+4,X+5]
;
; On Entry:
;   X: vdu offset
; On Exit:
;   A,Y: low byte of negated value
;
; ***************************************************************************************
.negateVDUX45
    SEC                                                 ;
    LDA #0                                              ;
    SBC .vduVariablesStart + 4,X                        ;
    TAY                                                 ;
    LDA #0                                              ;
    SBC .vduVariablesStart + 5,X                        ;
    STA .vduVariablesStart + 5,X                        ;
    TYA                                                 ;
    STA .vduVariablesStart + 4,X                        ;
    RTS                                                 ;

; ***************************************************************************************
;
; Move to next pixel along a line
;
; Update the current point to move to the next pixel along the line.
; Also updates the error term.
;
; Notes:
; if the error term is negative, then jump to a routine to handle that, then return
; else:
;   add abs(deltaX) to error term
;   if the error term is now negative, then call a routine to handle that
;   increment or decrement current X coordinate (based on sign of deltaY)
;
; On Entry:
;   the straight line variables are initialised:
;      vdu[X+4,X+5]: abs(deltaX)
;      vdu[X+6,X+7]: abs(deltaY)
;      vdu[X+8,X+9]: error term
;      vdu[X+10]:    sign bits of deltaX and deltaY
; On Exit:
;   error term updated
;   X: incremented by 2
;
; ***************************************************************************************
.lineMoveToNextPixel
    LDA .vduVariablesStart + 9,X                        ; get error term (high byte)
    BPL .errorTermMinusEqualsAbsDeltaY                  ; if (error term < 0) then branch

.errorTermPlusEqualsAbsDeltaX
    CLC                                                 ; }
    LDA .vduVariablesStart + 8,X                        ; }
    ADC .vduVariablesStart + 4,X                        ; }
    STA .vduVariablesStart + 8,X                        ; } error term += abs(deltaX)
    LDA .vduVariablesStart + 9,X                        ; }
    ADC .vduVariablesStart + 5,X                        ; }
    STA .vduVariablesStart + 9,X                        ; }
    BMI +                                               ; if (error term < 0) then branch
    JSR .errorTermMinusEqualsAbsDeltaY                  ;
+
    INX                                                 ;
    INX                                                 ;
    LDA .vduVariablesStart + 8,X                        ;
    BMI .decrementCoordinateX                           ; increment or decrement Y coordinate
    ; fall through...

; ***************************************************************************************
.incrementCoordinateX
    INC .vduVariablesStart,X                            ;
    BNE +                                               ;
    INC .vduVariablesStart+1,X                          ;
+
    RTS                                                 ;

; ***************************************************************************************
;
; Move to a new column, updating the X coordinate and the error term
;
; error term -= abs(deltaY)
; currentPointX += 1 (or -= 1 depending on the sign of deltaX)
;
; ***************************************************************************************
.errorTermMinusEqualsAbsDeltaY
    SEC                                                 ; }
    LDA .vduVariablesStart + 8,X                        ; }
    SBC .vduVariablesStart + 6,X                        ; }
    STA .vduVariablesStart + 8,X                        ; } error term -= abs(deltaY)
    LDA .vduVariablesStart + 9,X                        ; }
    SBC .vduVariablesStart + 7,X                        ; }
    STA .vduVariablesStart + 9,X                        ; }

    LDA .vduVariablesStart + 10,X                       ; sign of deltaX
    ASL                                                 ;
    BPL .incrementCoordinateX                           ; increment or decrement X coordinate
    ; fall through...

; ***************************************************************************************
.decrementCoordinateX
    LDA .vduVariablesStart,X                            ;
    BNE +                                               ;
    DEC .vduVariablesStart+1,X                          ;
+
    DEC .vduVariablesStart,X                            ;
    RTS                                                 ;

; ***************************************************************************************
.clipLineCoordinateX
    JSR .swapXAndYCoordinatesOfPointXAndInvertErrorTerm ;

    LDA .vduVariablesStart + 10,X                       ; signs of the two lines
    ASL                                                 ; carry = sgn(deltaY)   (ignored)
    ASL                                                 ; carry = sgn(deltaX)
    LDA .vduVariablesStart + 10,X                       ;
    ROR                                                 ; put sgn(deltaX) back into the top bit in the sgn(deltaY) position.
    STA .vduTempStoreDA                                 ; clearing the sgn(deltaX) position.
                                                        ;

    CLC                                                 ; having done the swap
    BPL .distanceFromleftEdge                           ; if (sgn(deltaY) >= 0) then branch

    LDA .vduVariablesStart + 2,X                        ; }
    SBC .vduGraphicsWindowPixelsRightLow                ; }
    TAY                                                 ; } YA = Y coordinate - graphics window right edge
    LDA .vduVariablesStart + 3,X                        ; }
    SBC .vduGraphicsWindowPixelsRightHigh               ; }
    JMP .clipYCoordinateAndSwapBack                     ; }

.distanceFromleftEdge
    LDA .vduGraphicsWindowPixelsLeftLow                 ; }
    SBC .vduVariablesStart + 2,X                        ; } YA = graphics window left edge - Y coordinate
    TAY                                                 ; }
    LDA .vduGraphicsWindowPixelsLeftHigh                ; }
    SBC .vduVariablesStart + 3,X                        ; }

.clipYCoordinateAndSwapBack
    JSR .clipYCoordinate                                ;
    JSR .swapXAndYCoordinatesOfPointXAndInvertErrorTerm ; restore original sense of X and Y coordinates
    JMP .errorTermMinusEqualsAbsDeltaY                  ;

; ***************************************************************************************
;
; Swap the X and Y coordinates of the current point on a line and invert the error term
;
; On Entry:
;       vdu[X+0,X+1] = x1 coordinate
;       vdu[X+2,X+3] = y1 coordinate
;       vdu[X+4,X+5] = x2 coordinate
;       vdu[X+6,X+7] = y2 coordinate
;
; On Exit:
;       vdu[X+0,X+1] = y1 coordinate
;       vdu[X+2,X+3] = x1 coordinate
;       vdu[X+4,X+5] = y2 coordinate
;       vdu[X+6,X+7] = x2 coordinate
;       vdu[X+8,X+9] ^= $FFFF (i.e. inverted)
;
; ***************************************************************************************
.swapXAndYCoordinatesOfPointXAndInvertErrorTerm
    INX                                                 ; }
    TXA                                                 ; } push X+1
    PHA                                                 ; }

    ; Swap X coordinate with Y coordinate
    INX                                                 ;
    TXA                                                 ; A = X+2
    DEX                                                 ;
    DEX                                                 ; return to original X
    TAY                                                 ; Y = X+2

; [NOTE: the above can be optimised to save 2 bytes:
; .swapXAndYCoordinatesOfPointXAndInvertErrorTerm
;   INX     ; }
;   TXA     ; } A=X+1
;   DEX     ; }
;   PHA     ; push X+1
;   TAY     ; Y=X+1
;   INY     ; Y=X+2
;  ]

    JSR .exchangeTwoVDUBytes                            ; this also increments X, Y by two

    ; Exchange Y coordinates
    INX                                                 ;
    INX                                                 ; X+=2
    INY                                                 ;
    INY                                                 ; Y+=2
    JSR .exchangeTwoVDUBytes                            ; X+=2, Y+=2

    ; Invert error term
    STA .gxrScratchspace3                               ; [NOTE: Redundant]
    PLA                                                 ; }
    TAX                                                 ; } recall X+1 from above
    LDA .gxrScratchspace3                               ; [NOTE: Redundant]

    ; Invert error term
    JSR .invertVDUX8                                    ; invert high byte
    DEX                                                 ; decrement X and invert low byte
.invertVDUX8
    LDA .vduVariablesStart + 8,X                        ; error term (high or low)
    EOR #$FF                                            ;
    STA .vduVariablesStart + 8,X                        ; error term (high or low)
    RTS                                                 ;

; ***************************************************************************************
;
; Clip line to graphics window in Y
;
; Use the results of the line initialisation to clip the line to the graphics window.
;
; Note: The line initialisation leaves us with vduVariables:
;
;     offset    variable name        meaning
;     ------------------------------------------
;     +0,+1     .line1StartPointX    start point X
;     +2,+3     .line1StartPointY    start point Y
;     +4,+5     .line1AbsDeltaX      abs(deltaX)
;     +6,+7     .line1AbsDeltaY      abs(deltaY)
;     +8,+9     .line1ErrorTerm      error term
;     +10       .line1Signs          bit 7 is sgn(deltaY) and bit 6 is sgn(deltaX)
;
; ***************************************************************************************
.clipLineCoordinateY
    CLC                                                 ;
    LDA .vduVariablesStart + 10,X                       ; get the signs of the line's deltas
    STA .vduTempStoreDA                                 ; store signs of deltas
    BPL .offsetFromBottomOfGraphicsWindow               ; if (deltaY >= 0) then branch

    LDA .vduVariablesStart + 2,X                        ; }
    SBC .vduGraphicsWindowPixelsTopLow                  ; }
    TAY                                                 ; } YA = line1StartPointY - graphics window top
    LDA .vduVariablesStart + 3,X                        ; }
    SBC .vduGraphicsWindowPixelsTopHigh                 ; }
    JMP .gotHowMuchToClipInY                            ;

.offsetFromBottomOfGraphicsWindow
    LDA .vduGraphicsWindowPixelsBottomLow               ; }
    SBC .vduVariablesStart + 2,X                        ; }
    TAY                                                 ; } YA = graphics window bottom - line1StartPointY
    LDA .vduGraphicsWindowPixelsBottomHigh              ; }
    SBC .vduVariablesStart + 3,X                        ; }

.gotHowMuchToClipInY
    JSR .clipYCoordinate                                ;
    JMP .errorTermPlusEqualsAbsDeltaX                   ;

.clipYCoordinate
    STY .vduTempStoreDE                                 ; } store how much to clip in Y
    STA .vduTempStoreDF                                 ; }

    LDA .vduVariablesStart + 2,X                        ; AY = line1StartPointY
    LDY .vduVariablesStart + 3,X                        ;

    ASL .vduTempStoreDA                                 ; shift signs of the deltas
    BCS +                                               ; if (deltaY < 0) then branch

    ; line1StartPointY += amount to clip in Y
    ADC .vduTempStoreDE                                 ;
    STA .vduVariablesStart + 2,X                        ;
    TYA                                                 ;
    ADC .vduTempStoreDF                                 ;
    JMP ++                                              ;

+
    ; line1StartPointY -= amount to clip in Y
    SBC .vduTempStoreDE                                 ;
    STA .vduVariablesStart + 2,X                        ;
    TYA                                                 ;
    SBC .vduTempStoreDF                                 ;
++
    STA .vduVariablesStart + 3,X                        ;

    LDA .vduVariablesStart + 9,X                        ; line1ErrorTerm+1 (high byte)
    ; If top bit of A set, then A=255 else A=0
    PHP                                                 ;
    LDA #0                                              ;
    PLP                                                 ;
    BPL +                                               ;
    SEC                                                 ; } [NOTE: could be LDA #255 for one byte saving]
    SBC #1                                              ; }
+

; [NOTE: Alternatively this saves 3 bytes and a few cycles:
;   LDA #0
;   LDY .vduVariablesStart + 9,X
;   BPL +
;   LDA #255
;+
; ]

    STA .vduTempStoreDC                                 ;
    LSR                                                 ;
    STA .vduTempStoreDD                                 ;

    ; At this point DC/DD is either $0000, or $7FFF, which is added to result of the following 16 bit multiply
    ; This is to add rounding, with the result in the top two bytes.

    ; We multiply the error term by the amount we are clipping by in Y
    ;   which to give details is (line1ErrorTerm + fractional part given in .vduTempStoreDC/D) * .vduTempStoreDE/F
    ; this will give us the new error term

    ; 16 bit x 16 bit = 32 bit multiply (but only top 16 bits used)
    ; (similar to https://github.com/TobyLobster/multiply_test/blob/main/tests/mult43.a but for 16 bit)
    LDY #16                                             ; loop counter
.multiply16loop
    ; Rotate the four bytes one bit at a time
    LDA .vduTempStoreDD                                 ;
    ASL                                                 ; carry = top bit of DD
    ROL .vduVariablesStart + 8,X                        ; }
    ROL .vduVariablesStart + 9,X                        ; }
    ROL .vduTempStoreDC                                 ; } shift result
    ROL .vduTempStoreDD                                 ; }

    ASL .vduTempStoreDE                                 ; shift multiplier
    ROL .vduTempStoreDF                                 ;
    BCC +                                               ;

    ; Add multiplicand to result
    CLC                                                 ; }
    LDA .vduTempStoreDC                                 ; }
    ADC .vduVariablesStart + 4,X                        ; }
    STA .vduTempStoreDC                                 ; } DC/D += vdu[X+4,X+5]
    LDA .vduTempStoreDD                                 ; }
    ADC .vduVariablesStart + 5,X                        ; }
    STA .vduTempStoreDD                                 ; }
    BCC +                                               ;

    ; Add one to result
    INC .vduVariablesStart + 8,X                        ;
    BNE +                                               ;
    INC .vduVariablesStart + 9,X                        ;
+

    DEY                                                 ;
    BNE .multiply16loop                                 ; loop back until done 16 times
    ; (end of multiply)

    STA .gxrScratchspace3                               ;
    LDA .vduVariablesStart + 9,X                        ; get .line1ErrorTerm high byte
    ASL                                                 ;
    PHP                                                 ; }
    LDA .gxrScratchspace3                               ; } [NOTE: redundant instructions, just use BCC .clipDivide instead?]
    PLP                                                 ; }
    BPL .clipDivide                                     ; }

    ; Store new error term
    LDA .vduTempStoreDC                                 ;
    STA .vduVariablesStart + 8,X                        ; store new error term
    LDA .vduTempStoreDD                                 ;
    STA .vduVariablesStart + 9,X                        ; store new error term
    RTS                                                 ;

.clipDivide
    ; 16 bit divide: error term / line1AbsDeltaY
    LDY #16                                             ; loop counter
.divideLoop16
    ROL .vduTempStoreDC                                 ; dividend
    ROL .vduTempStoreDD                                 ; dividend
    ROL .vduVariablesStart + 8,X                        ; remainder
    ROL .vduVariablesStart + 9,X                        ; remainder

    SEC                                                 ; }
    LDA .vduVariablesStart + 8,X                        ; } temp = remainder - divisor
    SBC .vduVariablesStart + 6,X                        ; }
    STA .vduTempStoreDE                                 ; }
    LDA .vduVariablesStart + 9,X                        ; }
    SBC .vduVariablesStart + 7,X                        ; }
    BCC .skip                                           ; if (temp < 0) then branch

    STA .vduVariablesStart + 9,X                        ;
    LDA .vduTempStoreDE                                 ; remainder = temp
    STA .vduVariablesStart + 8,X                        ;
.skip
    DEY                                                 ;
    BNE .divideLoop16                                   ; loop back until done all 16 bits

    ; Last iteration of divide
    ; dividend *= 2
    ROL .vduTempStoreDC                                 ;
    ROL .vduTempStoreDD                                 ;
    ; (end of divide)

    ; textLeft[X] -= divisor
    SEC                                                 ;
    LDA .vduVariablesStart + 8,X                        ;
    SBC .vduVariablesStart + 6,X                        ;
    STA .vduVariablesStart + 8,X                        ;

    LDA .vduVariablesStart + 9,X                        ;
    SBC .vduVariablesStart + 7,X                        ;
    STA .vduVariablesStart + 9,X                        ;

    LDA .vduVariablesStart,X                            ; AY = .line1StartPointX
    LDY .vduVariablesStart+1,X                          ;
    ASL .vduTempStoreDA                                 ;
    BCS .subtractDCDDPlusOne                            ; if (deltaX < 0) then branch

    ; Add
    SEC                                                 ; }
    ADC .vduTempStoreDC                                 ; }
    STA .vduVariablesStart,X                            ; } .line1StartPointX += 1 + DC/DD
    TYA                                                 ; }
    ADC .vduTempStoreDD                                 ; }
    JMP .storeAndReturn                                 ; }

.subtractDCDDPlusOne
    ; Subtract
    CLC                                                 ; }
    SBC .vduTempStoreDC                                 ; }
    STA .vduVariablesStart,X                            ; } .line1StartPointX -= 1 + DC/DD
    TYA                                                 ; }
    SBC .vduTempStoreDD                                 ; }
.storeAndReturn
    STA .vduVariablesStart+1,X                          ; }
.return16
    RTS                                                 ;

; ***************************************************************************************
;
; Plot line
;
; ***************************************************************************************
.plotLine
    JSR .copyDashPatternAndStateIntoPageC               ;
    LDA .vdu25ParameterPlotType                         ;
    JSR .plotLineInternal                               ;
    JSR .copyDashStateBackIntoWorkspace                 ;
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Plot a line
;
; This overrides the OS line plotting, to add the dot-dash pattern and fill pattern features.
; Note that dot-dash and fill patterns can be mixed:
;
;      10 MODE 1
;      20 GCOL 16,0
;      30 VDU 23,6,&F0;0;0;0;
;      40 FOR A=1 TO 200
;      50 MOVE 640,512
;      60 PLOT 21,RND(1280),RND(1024)
;      70 NEXT
;
; (See https://stardot.org.uk/forums/viewtopic.php?p=341226#p341226 )
;
; On Entry:
;   A: plot type (one of the line plot types)
;
;                     |           |           | Plot  | Plot  |
;                     |           | AND $c0:  | First | Last  |
; PLOT Codes          | x4        | EOR $40   | Point | Point | Pattern
; --------------------+-------------------------------------------------
; $00 - $07 ( 0 -  7) | %00000000 | %01000000 |   Y   |   Y   | none
; $08 - $0F ( 8 - 15) | %00100000 | %01000000 |   Y   |   N   | none
; $10 - $17 (16 - 23) | %01000000 | %00000000 |   Y   |   Y   | restarts on each new line
; $18 - $1F (24 - 31) | %01100000 | %00000000 |   Y   |   N   | restarts on each new line
; $20 - $27 (32 - 39) | %10000000 | %11000000 |   N   |   Y   | none
; $28 - $2F (40 - 47) | %10100000 | %11000000 |   N   |   N   | none
; $30 - $37 (48 - 55) | %11000000 | %10000000 |   N   |   Y   | continues on each new line
; $38 - $3F (56 - 63) | %11100000 | %10000000 |   N   |   N   | continues on each new line
;
; ***************************************************************************************
.plotLineInternal
    ASL                                                 ; }
    ASL                                                 ; }
    STA .vduTempStoreDB                                 ; } x 4
    AND #$C0                                            ; }
    EOR #$40                                            ; } see table in comment above to see how plot codes change
    BNE .skipPatternReset                               ; }

    ; Reset pattern
    LDA #$80                                            ;
    STA .currentDotDashPatternBitMask                   ; mask = top bit
    LDA #0                                              ;
    STA .currentDotDashPatternByte                      ; current dot-dash byte = 0
    LDA .currentDotDashPatternBitLength                 ;
    STA .currentDotDashPatternNumBitsRemaining          ; remaining = length

.skipPatternReset
    ; Check if the initial point is within the graphics window
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart ; graphics cursor = initial point of line
    JSR .checkPointXIsWithinGraphicsWindow              ;

    STA .vduTempStoreDC                                 ; store result of graphics windows boundary check
    ; .vduTempStoreDC is the result of the initial point boundary check:
    ;       %0000   success (point is within window)
    ;       %0001   graphics cursor X is left of  the left   edge of the graphics window
    ;       %0010   graphics cursor X is right of the right  edge of the graphics window
    ;       %0100   graphics cursor Y is below    the bottom edge of the graphics window
    ;       %1000   graphics cursor Y is above    the top    edge of the graphics window
    BEQ +                                               ; if (in graphics window) then branch

    ; Initial point is outside graphics window, so change the plot code to not draw the initial point
    ; Remove top bit from PLOT type [NOTE: the logic is the wrong way round. It should OR in (set)
    ; bit 5. The effect is benign though.]
    LDA #%01111111                                      ;
    AND .vduTempStoreDB                                 ;
    STA .vduTempStoreDB                                 ;
+

    ; Check if the final point is within the graphics window
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; PLOT parameter = final point of line
    JSR .checkPointXIsWithinGraphicsWindow              ;
    STA .gxrScratchspace1                               ; store result of graphics windows bounds check
    ; .gxrScratchspace1 is the result of the final point boundary check:
    ;       %0000   success (point is within window)
    ;       %0001   graphics cursor X is left of  the left   edge of the graphics window
    ;       %0010   graphics cursor X is right of the right  edge of the graphics window
    ;       %0100   graphics cursor Y is below    the bottom edge of the graphics window
    ;       %1000   graphics cursor Y is above    the top    edge of the graphics window
    BEQ .pointIsInsideGraphicsWindow                    ; if (point is within graphics window) then branch

    ; Final point is outside the graphics window, so change the plot code to not draw the final
    ; point [NOTE: the logic is the wrong way round. It should OR in (set) bit 5. The effect is
    ; benign though.]
    TAX                                                 ;
    ; Remove bit 5
    LDA #%11011111                                      ;
    AND .vduTempStoreDB                                 ;
    STA .vduTempStoreDB                                 ;
    TXA                                                 ;

    BIT .vduTempStoreDC                                 ; bit test (like doing an AND) the two graphics bounds checks together
.ifNotEqualReturn
    BNE .return16                                       ; if (both points are in the same offscreen region) then branch (return,
                                                        ;                                  since the line is entirely offscreen)

.pointIsInsideGraphicsWindow
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart ; start point
    LDA #.vdu25ParameterXLow - .vduVariablesStart       ;
    LDX #.line1StartPointX - .vduVariablesStart         ;
    JSR .lineInitialisation                             ;

    ; The line initialisation sets up line 1 variables:
    ;    .line1StartPointX: initial and current point X [2 bytes]
    ;    .line1StartPointY: initial and current point Y [2 bytes]
    ;    .line1AbsDeltaX  : abs(deltaX)                 [2 bytes]
    ;    .line1AbsDeltaY  : abs(deltaY)                 [2 bytes]
    ;    .line1ErrorTerm  : Bresenham error term        [2 bytes]
    ;    .line1Signs      : signs of deltaY (top bit) and deltaX (bit 6) [1 byte]

    ; .vduTempStoreDC holds the result of the initial point boundary check:
    ;       %0000   success (point is within window)
    ;       %0001   graphics cursor X is left of  the left   edge of the graphics window
    ;       %0010   graphics cursor X is right of the right  edge of the graphics window
    ;       %0100   graphics cursor Y is below    the bottom edge of the graphics window
    ;       %1000   graphics cursor Y is above    the top    edge of the graphics window
    LDA .vduTempStoreDC                                 ; initial point graphics boundary check result
    AND #$0C                                            ; get the Y result
    PHP                                                 ; remember if zero or not
    LDA .vduTempStoreDC                                 ;
    PLP                                                 ; recall
    BEQ .initialPointIsWithinGraphicsWindowY            ; if (the Y coordinate is inside the graphics window) then branch

    ; Clip Y coordinate
    LDX #.line1StartPointX - .vduVariablesStart         ;
    JSR .clipLineCoordinateY                            ;

    ; Check the point is in the graphics window now it has been clipped
    LDX #.line1StartPointX - .vduVariablesStart         ;
    JSR .checkPointXIsWithinGraphicsWindow              ;

    BIT .gxrScratchspace1                               ; check previous result
    BNE .ifNotEqualReturn                               ; if (the two ends are now in the same offscreen region) then return (nothing to draw)

.initialPointIsWithinGraphicsWindowY
    STA .gxrScratchspace3                               ; result of graphics window boundary check for the clipped initial point
    AND #3                                              ; get just the X result
    PHP                                                 ; remember if X is in the graphics window or not
    LDA .gxrScratchspace3                               ;
    PLP                                                 ; recall if X is in the graphics window or not
    BEQ .initialPointIsWithinGraphicsWindowX            ; if (the X coordinate is inside the graphics window) then branch

    LDX #.line1StartPointX - .vduVariablesStart         ;
    JSR .clipLineCoordinateX                            ;

    ; Check the point is in the graphics window now it has been clipped
    LDX #.line1StartPointX - .vduVariablesStart         ;
    JSR .checkPointXIsWithinGraphicsWindow              ;

.initialPointIsWithinGraphicsWindowX
    TAY                                                 ; }
    BNE .ifNotEqualReturn                               ; } if (clipped line is still off screen) then return

    ; Get X and Y as offsets to the final point, taking into account clipping
    LDY #.vdu25ParameterXLow - .vduVariablesStart               ; } use final point by default
    LDX #.vdu25ParameterYLow - .vduVariablesStart               ; } (note reversed Y and X in this section)
    LDA .gxrScratchspace1                                       ; result of final point graphics windows bounds check
    BEQ .skipFinalPointCheck                                    ; if (final point within graphics window) then branch
    LDY #.vduGraphicsWindowPixelsRightLow - .vduVariablesStart  ; use top right of graphics window
    LDX #.vduGraphicsWindowPixelsTopLow - .vduVariablesStart    ;
    BIT .line1Signs                                             ;
    BPL +                                                       ; if (deltaY >= 0) then branch
    LDX #.vduGraphicsWindowPixelsBottomLow - .vduVariablesStart ; use bottom of graphics window
+
    BVC .skipFinalPointCheck                                    ; if (deltaX >= 0) then branch
    LDY #.vduGraphicsWindowPixelsLeftLow - .vduVariablesStart   ; use left of graphics window
.skipFinalPointCheck

    ; Y and X registers are the indices to the X,Y coordinates for the final point

    ; First get abs(deltaY)
    CLC                                                 ;
    LDA .vduVariablesStart,X                            ;
    SBC .line1StartPointY                               ; start point Y
    BCC +                                               ;

    ; Negate A to get absolute value
    ADC #0                                              ;
    EOR #$FF                                            ;
+
    STA .vduTempStoreDC                                 ; store abs(deltaY)

    ; Get -abs(deltaX)
    CLC                                                 ;
    LDA .vduVariablesStart,Y                            ; final clipped X point (low)
    SBC .line1StartPointX                               ; start point X (low)
    TAX                                                 ;
    LDA .vduVariablesStart+1,Y                          ; final clipped X point (high)
    SBC .line1StartPointX+1                             ; start point X (high)
    BMI ++                                              ; if negative then branch (no need to negate result)

    ; Negate XA by adding one then inverting the bits
    INX                                                 ;
    BNE +                                               ;
    CLC                                                 ;
    ADC #1                                              ;
+
    ; Invert A
    EOR #$FF                                            ;

    ; Invert X
    TAY                                                 ; remember A
    TXA                                                 ; }
    EOR #$FF                                            ; } invert X
    TAX                                                 ; }
    TYA                                                 ; recall A

++
    STA .vduTempStoreDD                                 ; } store -abs(deltaX)
    STX .gxrScratchspace1                               ; } this counts upwards towards zero, used as a loop counter

    LDX #.line1StartPointX - .vduVariablesStart         ;
    JSR .gxrSetScreenAddressAndSetGraphicsColourMask    ; get screen address of start point

    ;                                           | Plot  | Plot  |
    ;                                           | First | Last  |
    ;  PLOT Codes              | vduTempStoreDB | Point | Point | Pattern
    ; -------------------------+------------------------------------------
    ;  $00 - $07   ( 0 -   7)  | %00000000      |   Y   |   Y   | none
    ;  $08 - $0F   ( 8 -  15)  | %00100000      |   Y   |   N   | none
    ;  $10 - $17   (16 -  23)  | %01000000      |   Y   |   Y   | restarts on each new line
    ;  $18 - $1F   (24 -  31)  | %01100000      |   Y   |   N   | restarts on each new line
    ;  $20 - $27   (32 -  39)  | %10000000      |   N   |   Y   | none
    ;  $28 - $2F   (40 -  47)  | %10100000      |   N   |   N   | none
    ;  $30 - $37   (48 -  55)  | %11000000      |   N   |   Y   | continues on each new line
    ;  $38 - $3F   (56 -  63)  | %11100000      |   N   |   N   | continues on each new line

    ASL .vduTempStoreDB                                 ;
    BCS .skipLinePlotPixel                              ; skip if initial point is omitted

.plotLineLoop

    ;                                           | Plot  | Plot  |
    ;                                           | First | Last  |
    ;  PLOT Codes              | vduTempStoreDB | Point | Point | Pattern
    ; -------------------------+------------------------------------------
    ;  $00 - $07   ( 0 -   7)  | %00000000      |   Y   |   Y   | none
    ;  $08 - $0F   ( 8 -  15)  | %01000000      |   Y   |   N   | none
    ;  $10 - $17   (16 -  23)  | %10000000      |   Y   |   Y   | restarts on each new line
    ;  $18 - $1F   (24 -  31)  | %11000000      |   Y   |   N   | restarts on each new line
    ;  $20 - $27   (32 -  39)  | %00000000      |   N   |   Y   | none
    ;  $28 - $2F   (40 -  47)  | %01000000      |   N   |   N   | none
    ;  $30 - $37   (48 -  55)  | %10000000      |   N   |   Y   | continues on each new line
    ;  $38 - $3F   (56 -  63)  | %11000000      |   N   |   N   | continues on each new line

    BIT .vduTempStoreDB                                 ; test plot type
    BVC .finalPointIncluded                             ; if (final point included) then branch

    ; Final point omitted
    ; Check if we are about to plot the final point
    LDA .gxrScratchspace1                               ; top byte of -abs(deltaX)
    AND .vduTempStoreDC                                 ;
    AND .vduTempStoreDD                                 ; low byte of -abs(deltaX)
    CLC                                                 ;
    ADC #1                                              ; add one
    BEQ .return17                                       ; if (zero) then branch (finished)

    BIT .vduTempStoreDB                                 ; test plot type (see table above)

.finalPointIncluded
    BPL .linePlotPixel                                  ; if (first point is included) then branch (plot pixel)

    STX .gxrScratchspace3                               ; index of line1StartPointX

    ; Move dot-dash line pattern on by one bit, restart when we reach the pattern end
    LDX .currentDotDashPatternByte                      ;
    LDA .currentDotDashPattern,X                        ;
    AND .currentDotDashPatternBitMask                   ; and with mask to see if bit is set
    PHP                                                 ;
    LSR .currentDotDashPatternBitMask                   ; shift the current mask one place to look at next bit
    BCC +                                               ; if (mask byte not exhausted) branch

    ROR .currentDotDashPatternBitMask                   ; sets the mask back to $80 for the next byte
    INC .currentDotDashPatternByte                      ; move to next byte
+
    DEC .currentDotDashPatternNumBitsRemaining          ;
    BNE .skipResetPattern                               ;

    ; Restart pattern
    LDA .currentDotDashPatternBitLength                 ;
    STA .currentDotDashPatternNumBitsRemaining          ; remaining = length
    LDA #$80                                            ;
    STA .currentDotDashPatternBitMask                   ; set mask to top bit set (the first bit of the pattern)
    LDA #0                                              ;
    STA .currentDotDashPatternByte                      ; start at first byte of pattern
.skipResetPattern

    LDX .gxrScratchspace3                               ; recall index to line1StartPointX [NOTE: could be LDX #line1StartPointX - vduStart]
    PLP                                                 ; get flag to see if the dot pattern pixel is set
    BEQ .skipLinePlotPixel                              ; if (no pixel required) then branch

.linePlotPixel
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    LDA .vduCurrentPlotByteMask                         ; current pixel
    AND .vduGraphicsColourByteOR                        ; and to get colour
    ORA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; OR in byte from screen
    STA .vduTempStoreDA                                 ; store
    LDA .vduCurrentPlotByteMask                         ; }
    AND .vduGraphicsColourByteEOR                       ; } plot mode
    EOR .vduTempStoreDA                                 ; }
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; store byte to screen
} else if MACHINE = BBC_B_PLUS {
    JSR .plotPointWithinBoundsAtY
} else {
    +unknown_machine
}

.skipLinePlotPixel
    LDA .line1ErrorTerm+1                               ; error term (high byte)
    BPL .moveToNextColumn                               ;

    INC .vduTempStoreDC                                 ; increment deltaY until it reaches zero
    BEQ .return17                                       ; if (deltaY == 0) then return

    BIT .line1Signs                                     ; sign of deltaY
    BMI .moveDownARow                                   ; if (deltaY < 0) then branch

    DEY                                                 ; move up one row
    BPL .moveUpOrDownDone                               ; if (not at top of character cell) then branch

    JSR .moveGraphicsCursorAddressUpOneCharacterCell    ;
    JMP .moveUpOrDownDone                               ;

.return17
    RTS                                                 ;

.moveDownARow
    INY                                                 ;
    CPY #8                                              ;
    BNE .moveUpOrDownDone                               ; if (not at bottom of character cell) then branch

    JSR .plotSpriteMoveDownOneCell                      ; move to next cell

.moveUpOrDownDone
    JSR .gxrSetGraphicsColourMasks                      ;

    ; Add to error term
    CLC                                                 ; }
    LDA .line1ErrorTerm                                 ; }
    ADC .line1AbsDeltaX                                 ; }
    STA .line1ErrorTerm                                 ; } line1ErrorTerm += line1AbsDeltaX
    LDA .line1ErrorTerm+1                               ; }
    ADC .line1AbsDeltaX+1                               ; }
    STA .line1ErrorTerm+1                               ; }
    BPL .moveToNextColumn                               ;

    JMP .plotLineLoop                                   ;

.moveToNextColumn
    ; Add one to X coordinate stored in (.gxrScratchspace1, .vduTempStoreDD)
    INC .gxrScratchspace1                               ;
    BNE +                                               ;
    INC .vduTempStoreDD                                 ;
    BEQ .return17                                       ; if (last column) then branch (return)
+

    BIT .line1Signs                                     ; sign of original deltaX
    BVS .movePixelToTheLeft                             ; if (deltaX < 0) then branch

    ; Move a pixel to the right
    LSR .vduCurrentPlotByteMask                         ;
    BCC .afterShiftingLeftOrRight                       ;

    JSR .moveGraphicsCursorAddressTotheRightAndUpdateMask ;
    JMP .afterShiftingLeftOrRight                       ;

.movePixelToTheLeft
    ; Move a pixel to the left
    ASL .vduCurrentPlotByteMask                         ;
    BCC .afterShiftingLeftOrRight                       ;
    JSR .moveGraphicsCursorAddressTotheLeftAndUpdateMask ;

.afterShiftingLeftOrRight
    ; Subtract from the error term: line1ErrorTerm -= line1AbsDeltaY
    SEC                                                 ;
    LDA .line1ErrorTerm                                 ;
    SBC .line1AbsDeltaY                                 ;
    STA .line1ErrorTerm                                 ;
    LDA .line1ErrorTerm+1                               ; }
    SBC .line1AbsDeltaY+1                               ; } high byte
    STA .line1ErrorTerm+1                               ; }

    JMP .plotLineLoop                                   ;

; ***************************************************************************************
;
; Unused
;
; Increment .vduWorkspaceAB,X or decrement it, based on negative flag on entry
;
; ***************************************************************************************
.incOrDecWorkspaceAB_X
    BMI .dec                                            ;
    INC .vduWorkspaceA,X                                ;
    BNE ++                                              ;
    INC .vduWorkspaceB,X                                ;
    RTS                                                 ;

.dec
    LDA .vduWorkspaceA,X                                ;
    BNE +                                               ;
    DEC .vduWorkspaceB,X                                ;
+
    DEC .vduWorkspaceA,X                                ;
++
    RTS                                                 ;

; ***************************************************************************************
;
; Unused
;
; Check if .vduWorkspaceABCD == .vduWorkspaceEFGH
;
; ***************************************************************************************
.checkIfABCDEqualsEFGH
    LDY #4                                              ; loop counter
.checkLoop
    LDA .vduWorkspaceA-1,Y                              ;
    CMP .vduWorkspaceE-1,Y                              ;
    BNE .checkIsDone                                    ;
    DEY                                                 ;
    BNE .checkLoop                                      ;
.checkIsDone
    RTS                                                 ;

; ***************************************************************************************
;
; Move down one cell
;
; ***************************************************************************************
.plotSpriteMoveDownOneCell
    CLC                                                 ;
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ;
    ADC .vduBytesPerCharacterRowLow                     ;
    STA .vduScreenAddressOfGraphicsCursorCellLow        ;
    LDA .vduScreenAddressOfGraphicsCursorCellHigh       ;
    ADC .vduBytesPerCharacterRowHigh                    ;
    BPL +                                               ;

    SEC                                                 ;
    SBC .vduScreenSizeHighByte                          ; loop from bottom of screen to top
+
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ;
    LDY #0                                              ; start at the top of the next cell
    RTS                                                 ;

; ***************************************************************************************
;
; Copy dot-dash line state and pattern to page C
;
; When plotting a line, copy the dot-dash line pattern data into page C for ease of access
;
; ***************************************************************************************
.copyDashPatternAndStateIntoPageC
    JSR .getPrivateWorkspaceAddress                     ;
    LDY #.workspaceOffsetDotDashPatternByte             ;
    LDX #3 + 8                                          ; loop counter (3 bytes of dot-dash state + 8 bytes of dot-dash pattern)
-
    LDA (.privateWorkspaceLow),Y                        ;
    STA .currentDotDashPattern,X                        ; copy from workspace to current pattern
    DEY                                                 ;
    DEX                                                 ;
    BPL -                                               ;
    RTS                                                 ;

; ***************************************************************************************
;
; Copy dot-dash line state back to private workspace
;
; When we are done plotting a line, copy the latest dot-dash state back into the private
; workspace area. This allows the dot-dash state to continue on the next line, if needed.
;
; ***************************************************************************************
.copyDashStateBackIntoWorkspace
    JSR .getPrivateWorkspaceAddress                 ;
    LDY #.workspaceOffsetDotDashPatternByte         ;
    LDX #2                                          ; loop counter
-
    LDA .currentDotDashPatternNumBitsRemaining,X    ; }
    STA (.privateWorkspaceLow),Y                    ; } workspace[pattern byte] = .currentDotDashPatternByte
    DEY                                             ; } workspace[dot-dash bit] = .currentDotDashPatternBitMask
    DEX                                             ; } workspace[bits remaining] = .currentDotDashPatternNumBitsRemaining
    BPL -                                           ; }

    RTS                                             ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 18: Flood fill and horizontal fill
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Flood Fill
;
; See einstein.png
;
; The flood fill feature sets any adjacent pixels (in the four cardinal directions) recursively
; starting from a given point within the graphics window, with options:
;
;   * Fill until reaching a non-background colour.
;   * Fill until reaching the current foreground colour.
;
; The filled area is set to either the current fill pattern or the current background colour.
;
; Limitations:
;
; To quote the manual...
;
; "Flooding a region with a colour which it already contains will not work. For example if you
; are attempting a flood to non-background with the background colour being black then you should
; not try to flood in black or a pattern which contains black pixels. If you do this then it will
; try to fill a region, find that pixels in it are still in the background colour and try again.
; When this occurs a small region of the screen will be flooded and then the flood fill will give
; up."
;
; Horizontal line fills:
;
; We can fill a single row, with options:
;
; * Fill left and right of the given pixel until a foreground pixel is met
; * Fill left and right of the given pixel until a non-background pixel is met
; * Fill right of the given pixel until a background pixel is met
; * Fill right of the given pixel until a non-foreground pixel is met
;
; ***************************************************************************************

; ***************************************************************************************
;
; Flood fill to foreground colour
;
; ***************************************************************************************
.floodFillToFg
    LDA #1                                              ; fill background colour
    LDX #0                                              ; X = 0 for foreground graphics colour
    BEQ .floodFillInternal                              ; ALWAYS branch

; ***************************************************************************************
;
; Flood fill to non-background colour
;
; ***************************************************************************************
.floodFillToNonBg
    LDA #0                                              ; A = 0 for 'non'
    LDX #1                                              ; X = 1 for fill background colour
.floodFillInternal
    STA .vduWorkspaceI                                  ; .vduWorkspaceI = 0 for non bg
    JSR .setupCurrentPattern                            ;

    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ;
    BPL .finishedFloodFill                              ; if (flood disabled) then branch

    LDX #.vdu25ParameterXLow - .vduVariablesStart       ;
    JSR .testParameterPointForFloodFillBoundary         ;
    BNE .finishedFloodFill                              ; if (at boundary already) then branch

    LDA #0                                              ;
    STA .vduWorkspaceF                                  ;
    STA .vduWorkspaceG                                  ;
    LDA .vdu25ParameterXLow                             ;
    LDX .vdu25ParameterXHigh                            ;
    LDY .vdu25ParameterYLow                             ;
    JSR .fillLeftAndRightRow                            ; fill row
    JSR .addEntryToFloodFillBuffer                      ; write first row to circular buffer of points to check

.floodFillLoop
    BIT .escapeFlag                                     ;
    BMI .finishedFloodFill                              ; if (ESCAPE pressed) then branch (finished)
    JSR .removeEntryFromFloodFillBuffer                 ; read row to check

    ; Check row+1
    LDY .vduWorkspaceC                                  ;
    INY                                                 ;
    BEQ .skipRow                                        ; if (edge of screen) then branch
    STY .vduWorkspaceC                                  ;
    JSR .checkAndFillRow                                ;
    BCC .finishedFloodFill                              ;

    ; Check row-1
    DEC .vduWorkspaceC                                  ;
.skipRow
    LDY .vduWorkspaceC                                  ;
    BEQ .skipRow2                                       ;
    DEY                                                 ;
    STY .vduWorkspaceC                                  ;
    JSR .checkAndFillRow                                ;

    BCC .finishedFloodFill                              ;

.skipRow2
    LDX .vduWorkspaceG                                  ; check to see if the circular buffer
    CPX .vduWorkspaceF                                  ; is empty
    BNE .floodFillLoop                                  ; if not then branch back

.finishedFloodFill
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Add an entry to a circular buffer of coordinates during a flood fill
;
; Used to store coordinates that we will revisit later when flood filling. Each entry holds
; two X coordinates and a Y coordinate, representing a row of pixels to check later.
;
; The data is stored in two pages. The first page stores the low byte of one X coordinate
; and the Y coordinate. The second page stores the other X coordinate and the high nybble
; of the first.
;
; On Entry:
;   Where to write the data:
;       .privateWorkspaceHigh: high byte of ROM private workspace
;       .vduWorkspaceG: index to write to (range 0-127) (the 'write to buffer index')
;       .vduWorkspaceF: index limit where we can write to (range 0-127) (the 'read buffer index')
;   Data to write:
;       .vduGraphicsCursorPixelsXLow/High:    pixel X coordinate
;       .vduOldGraphicsCursorPixelsXLow/High: pixel X coordinate
;       .vduOldGraphicsCursorPixelsYLow:      pixel Y coordinate
;
; ***************************************************************************************
.addEntryToFloodFillBuffer
    ; Increment .vduWorkspaceG, checking if we have completely filled the buffer already
    LDX .vduWorkspaceG                                  ;
    INX                                                 ;
    TXA                                                 ;
    AND #$7F                                            ;
    CMP .vduWorkspaceF                                  ;
    BEQ .clearCarryAndReturn                            ;
    STA .vduWorkspaceG                                  ;
    TAY                                                 ; Y=new incremented index to write to

    ; .vduTempStoreDC/DD = private workspace + 1 page = start address of flood fill data
    LDA .privateWorkspaceHigh                           ;
    STA .vduTempStoreDD                                 ;
    INC .vduTempStoreDD                                 ; +1 page
    LDA #0                                              ;
    STA .vduTempStoreDC                                 ;

    ; Store old graphics cursor X low in the flood fill data in the first page
    ; Store     graphics cursor X low in the flood fill data in the second page
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    STA (.vduTempStoreDC),Y                             ;
    INC .vduTempStoreDD                                 ; second page
    LDA .vduGraphicsCursorPixelsXLow                    ;
    STA (.vduTempStoreDC),Y                             ;

    ; In the second half of those two pages...
    LDA #$80                                            ;
    STA .vduTempStoreDC                                 ;

    ; In the second half of the second page: store the graphics cursor
    ;                                          and old graphics cursor X (high nybbles)
    LDA .vduGraphicsCursorPixelsXHigh                   ;
    ASL                                                 ;
    ASL                                                 ;
    ASL                                                 ;
    ASL                                                 ;
    ORA .vduOldGraphicsCursorPixelsXHigh                ;
    STA (.vduTempStoreDC),Y                             ;

    ; In the second half of the first page: store the old graphics cursor Y (low byte)
    DEC .vduTempStoreDD                                 ;
    LDA .vduOldGraphicsCursorPixelsYLow                 ;
    STA (.vduTempStoreDC),Y                             ;
    SEC                                                 ; set carry (all OK) and return
    RTS                                                 ;

.clearCarryAndReturn
    CLC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Remove an entry out of the circular flood fill buffer
;
; Each entry is a horizontal row of pixels for use during flood filling.
;
; On Exit:
;   .vduWorkspaceA: X1 low
;   .vduWorkspaceB: X1 high
;   .vduWorkspaceC: Y coordinate
;   .vduWorkspaceD: X2 low
;   .vduWorkspaceE: X2 high
;
; ***************************************************************************************
.removeEntryFromFloodFillBuffer
    ; Increment .vduWorkspaceF, wrapping at half a page
    INC .vduWorkspaceF                                  ;
    LDA .vduWorkspaceF                                  ;
    AND #$7F                                            ;
    STA .vduWorkspaceF                                  ;
    TAY                                                 ;

    ; Get start address of flood fill data (DC/DD = private workspace + 1 page)
    LDA .privateWorkspaceHigh                           ;
    STA .vduTempStoreDD                                 ;
    INC .vduTempStoreDD                                 ;
    LDA #0                                              ;
    STA .vduTempStoreDC                                 ;

    ; Read from flood fill memory and parse coordinates
    LDA (.vduTempStoreDC),Y                             ;
    STA .vduWorkspaceA                                  ; first half of first page (X1 low byte)
    INC .vduTempStoreDD                                 ;
    LDA (.vduTempStoreDC),Y                             ;
    STA .vduWorkspaceD                                  ; first half of second page (X2 low byte)

    ; Look at second half of the two pages
    LDA #$80                                            ;
    STA .vduTempStoreDC                                 ;
    LDA (.vduTempStoreDC),Y                             ; read top nybble of second half of second page
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    STA .vduWorkspaceE                                  ; store X2 high byte
    LDA (.vduTempStoreDC),Y                             ;
    AND #$0F                                            ;
    STA .vduWorkspaceB                                  ; store X1 high byte
    DEC .vduTempStoreDD                                 ;
    LDA (.vduTempStoreDC),Y                             ;
    STA .vduWorkspaceC                                  ; store Y
    RTS                                                 ;

; ***************************************************************************************
;
; Fills a row of pixels during flood fill
;
; Set the current and old graphics cursors to the given coordinates, clips to the graphics
; window, if within bounds then flood fill.
;
; On Entry:
;   A is the X coordinate to set (low)
;   X is the X coordinate to set (high)
;   Y is the Y coordinate to set (low) with 0 high.
;
; ***************************************************************************************
.fillLeftAndRightRow
    ; Store X and Y coordinates to the current and old graphics cursor positions
    STA .vduGraphicsCursorPixelsXLow                    ;
    STA .vduOldGraphicsCursorPixelsXLow                 ;
    STX .vduGraphicsCursorPixelsXHigh                   ;
    STX .vduOldGraphicsCursorPixelsXHigh                ;
    STY .vduGraphicsCursorPixelsYLow                    ;
    STY .vduOldGraphicsCursorPixelsYLow                 ;
    LDA #0                                              ;
    STA .vduGraphicsCursorPixelsYHigh                   ;
    STA .vduOldGraphicsCursorPixelsYHigh                ;

.fillLeftRight
    LDX #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart         ;
    JSR .gxrCheckInBoundsThenSetScreenAddressAndSetGraphicsColourMask ;
    BEQ .checkForFloodBoundary                          ;
    RTS                                                 ;

.checkForFloodBoundary
    JSR .readPixelAndTestForFloodFillBoundary           ;
    BEQ .fillLeftAndRight                               ;
    RTS                                                 ;

; ***************************************************************************************
;
; Fill left and right
;
; ***************************************************************************************
.fillLeftAndRightLoop
    JSR .readPixelAndTestForFloodFillBoundary           ;
    BNE .doneFillingLeft                                ;
    LDA .vduCurrentPlotByteMask                         ;
    ORA .vduWorkspaceH                                  ;

.fillLeftAndRight
    STA .vduWorkspaceH                                  ;
    LDA .vduOldGraphicsCursorPixelsXHigh                ;
    CMP .vduGraphicsWindowPixelsLeftHigh                ;
    BNE +                                               ;

    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    CMP .vduGraphicsWindowPixelsLeftLow                 ;
    BEQ .fillPointAndFillRight                          ; if (done filling left) then branch (fill right)

    ; Move left
+
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    BNE +                                               ;
    DEC .vduOldGraphicsCursorPixelsXHigh                ;
+
    DEC .vduOldGraphicsCursorPixelsXLow                 ;

    ; Update byte mask
    ASL .vduCurrentPlotByteMask                         ;
    BCC .fillLeftAndRightLoop                           ;

    ; Plot byte
    JSR .gxrPlotByteWithinBoundsAtY                     ;

    ; Move left
    LDA #0                                              ;
    STA .vduWorkspaceH                                  ;
    SEC                                                 ;
    JSR .moveGraphicsCursorAddressTotheLeftAndUpdateMask ;
    JMP .fillLeftAndRightLoop                           ;

; ***************************************************************************************
;
; Done filling left, now fill right
;
; ***************************************************************************************
.doneFillingLeft
    INC .vduOldGraphicsCursorPixelsXLow                 ; }
    BNE .fillPointAndFillRight                          ; } increment X
    INC .vduOldGraphicsCursorPixelsXHigh                ; }

.fillPointAndFillRight
    JSR .gxrPlotByteWithinBoundsAtY                     ; plot point at X

.fillRight
    LDA #0                                              ;
    STA .vduWorkspaceH                                  ; build up a byte to write to the screen

    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart ;
    JSR .gxrCheckInBoundsThenSetScreenAddressAndSetGraphicsColourMask ;
    BNE .return4                                        ; if (out of graphics window) then branch (return)

.fillNextPixel
    JSR .readPixelAndTestForFloodFillBoundary           ;
    BNE .floodFillReachedBoundaryRight                  ; if (reached boundary) then branch

    LDA .vduCurrentPlotByteMask                         ; }
    ORA .vduWorkspaceH                                  ; } OR in the current byte mask into
    STA .vduWorkspaceH                                  ; } the byte to write to the screen

    LDA .vduGraphicsCursorPixelsXHigh                   ; }
    CMP .vduGraphicsWindowPixelsRightHigh               ; }
    BNE +                                               ; }
    LDA .vduGraphicsCursorPixelsXLow                    ; }
    CMP .vduGraphicsWindowPixelsRightLow                ; }
    BEQ .gxrPlotByteWithinBoundsAtY                     ; } if (at right edge of graphics window) then branch (plot final byte)

+
    INC .vduGraphicsCursorPixelsXLow                    ; }
    BNE +                                               ; } move graphics cursor position
    INC .vduGraphicsCursorPixelsXHigh                   ; } one pixel right
+                                                       ; }

    LSR .vduCurrentPlotByteMask                         ;
    BCC .fillNextPixel                                  ; if (we have not finished this byte yet) then branch (loop back)

    JSR .gxrPlotByteWithinBoundsAtY                     ; write byte

    LDA #0                                              ; }
    STA .vduWorkspaceH                                  ; } clear byte to write
    SEC                                                 ;
    JSR .moveGraphicsCursorAddressTotheRightAndUpdateMask   ; move to the next byte right

    JMP .fillNextPixel                                  ;

; ***************************************************************************************
;
; Reached right boundary, fill final pixel
;
; ***************************************************************************************
.floodFillReachedBoundaryRight
    LDA .vduGraphicsCursorPixelsXLow                    ; }
    BNE +                                               ; }
    DEC .vduGraphicsCursorPixelsXHigh                   ; } move graphics cursor one pixel left
+                                                       ; }
    DEC .vduGraphicsCursorPixelsXLow                    ; }
    ; fall through...

; ***************************************************************************************
;
; Write a byte to the screen (for flood fill)
;
; On Entry:
;   .vduWorkspaceH: byte to write
;   .vduGraphicsColourByteOR:  } mask values needed for writing in the current GCOL mode
;   .vduGraphicsColourByteEOR: }
;   .vduScreenAddressOfGraphicsCursorCellLow: address of current graphics cursor cell
;   Y: offset within current graphics cursor cell (0-7)
;
; ***************************************************************************************
.gxrPlotByteWithinBoundsAtY
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    LDA .vduWorkspaceH                                  ; }
    AND .vduGraphicsColourByteOR                        ; }
    ORA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; }
    STA .vduTempStoreDA                                 ; } DA = (H AND ByteOR) OR screen
    LDA .vduGraphicsColourByteEOR                       ; } screen = (H AND ByteEOR) EOR DA
    AND .vduWorkspaceH                                  ; }
    EOR .vduTempStoreDA                                 ; }
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; }
} else if MACHINE = BBC_B_PLUS {
    LDX .vduCurrentPlotByteMask                         ;
    LDA .vduWorkspaceH                                  ;
    STA .vduCurrentPlotByteMask                         ;
    JSR .plotPointWithinBoundsAtY                       ;
    STX .vduCurrentPlotByteMask                         ;
} else {
    +unknown_machine
}

.return4
    RTS                                                 ;

; ***************************************************************************************
;
; Look along a row of pixels to check for any we can flood fill
;
; On Entry:
;   A: initial X coordinate (low)
;   X: initial X coordinate (high)
;   Y: initial Y coordinate
; On Exit:
;   Carry set if no more points to fill are found
;
; ***************************************************************************************
.findNextPointInRowToFill
    STA .vdu25ParameterXLow                             ;
    STX .vdu25ParameterXHigh                            ;
    STY .vdu25ParameterYLow                             ; low byte of Y coordinate
    LDA #0                                              ;
    STA .vduQueueEndByte                                ; high byte of Y coordinate = 0

    ; Check point is in bounds
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ;
    JSR .gxrCheckInBoundsThenSetScreenAddressAndSetGraphicsColourMask ;

    BNE .exitWithCarrySet                               ; if (not in bounds) then return with carry set

.checkRowForFillingLoop
    JSR .readPixelAndTestForFloodFillBoundary           ; read pixel

    BEQ .exitWithCarryClear                             ; if (suitable for filling) then return with carry clear

    ; Check if we are done with this row
    LDY .vdu25ParameterXLow                             ;
    CPY .vduWorkspaceD                                  ;
    BNE +                                               ;
    LDY .vdu25ParameterXHigh                            ;
    CPY .vduWorkspaceE                                  ;
    BEQ .exitWithCarrySet                               ; if (row finished) then return with carry set

    ; Move to the right to continue checking
+
    INC .vdu25ParameterXLow                             ;
    BNE +                                               ;
    INC .vdu25ParameterXHigh                            ;
+
    ; Update byte mask
    LSR .vduCurrentPlotByteMask                         ;
    BCC .checkRowForFillingLoop                         ;
    JSR .moveGraphicsCursorAddressTotheRightAndUpdateMask ;
    JMP .checkRowForFillingLoop                         ;

.exitWithCarryClear
    CLC                                                 ;
    RTS                                                 ;

.exitWithCarrySet
    SEC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Check pixels along row, filling if needed
;
; Each row of pixels we fill is added to our flood fill buffer. (We will later read those
; rows back out and check the row above and below it for any more to be filled).
;
; ***************************************************************************************
.checkAndFillRow
    LDA .vduWorkspaceA                                  ; X coordinate (low byte)
    LDX .vduWorkspaceB                                  ; X coordinate (high byte)
    LDY .vduWorkspaceC                                  ; Y coordinate
    JSR .findNextPointInRowToFill                       ; find next point to fill
    BCS .return9                                        ; if (not found) then return

.fillRowLoop
    LDA .vdu25ParameterXLow                             ;
    LDX .vdu25ParameterXHigh                            ;
    LDY .vdu25ParameterYLow                             ;
    JSR .fillLeftAndRightRow                            ; fill row
    JSR .addEntryToFloodFillBuffer                      ; add row to buffer
    BCC .return9                                        ; if (buffer full) then return

    ; If (reached right hand end of row) then return
    LDA .vduGraphicsCursorPixelsXLow                    ;
    CMP .vduWorkspaceD                                  ;
    LDA .vduGraphicsCursorPixelsXHigh                   ;
    SBC .vduWorkspaceE                                  ;
    BCS .return9                                        ;

    ; Find next point to fill
    LDA .vduGraphicsCursorPixelsXLow                    ;
    LDX .vduGraphicsCursorPixelsXHigh                   ;
    LDY .vduGraphicsCursorPixelsYLow                    ;
    JSR .findNextPointInRowToFill                       ;

    BCC .fillRowLoop                                    ;

.return9
    RTS                                                 ;

; ***************************************************************************************
;
; Check if PLOT parameter pixel is a boundary pixel
;
; ***************************************************************************************
.testParameterPointForFloodFillBoundary
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ;
    JSR .gxrCheckInBoundsThenSetScreenAddressAndSetGraphicsColourMask ;
    BNE .return8                                        ; if (outside graphics window) then branch
    ; fall through...

; ***************************************************************************************
;
; Check if pixel is a boundary pixel
;
; ***************************************************************************************
.readPixelAndTestForFloodFillBoundary
    LDY .vduGraphicsCursorVerticalOffsetInCell          ;

    ; get screen byte
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
} else if MACHINE = BBC_B_PLUS {
    JSR .checkPixelIsBackgroundColourFast               ; read byte from screen
    EOR .vduBackgroundGraphicsColour                    ; undo the unwanted eor from subroutine call
} else {
    +unknown_machine
}
    EOR .gxrCurrentPattern,Y                            ; EOR with pattern
    AND .vduCurrentPlotByteMask                         ; AND with byte mask
    BEQ +                                               ;
    LDA #1                                              ;
+
    EOR .vduWorkspaceI                                  ; boundary test
.return8
    RTS                                                 ;

; ***************************************************************************************
;
; Plot row left and right to non-background colour
;
; ***************************************************************************************
.plotHorizontalFillLRToNonBg
    LDA #0                                              ; A = 0 means fill to 'non'-
    LDX #1                                              ; X = 1 means fill to background pixels
.plotHorizontalFillLR
    STA .vduWorkspaceI                                  ; .vduWorkspaceI means fill to:
                                                        ; 0: 'non-foreground or non-background'
                                                        ; 1: 'foreground or background'
    JSR .setupCurrentPattern                            ;

    LDY #3                                              ; loop counter
-
    LDA .vdu25ParameterXLow,Y                           ;
    STA .vduOldGraphicsCursorPixelsXLow,Y               ;
    STA .vduGraphicsCursorPixelsXLow,Y                  ; graphics cursor = old graphics cursor = vdu 25 parameter
    DEY                                                 ;
    BPL -                                               ;

    JSR .fillLeftRight                                  ;
    JMP .copyWorkspaceCacheBackIntoCharacterDefinitons  ;

; ***************************************************************************************
;
; Plot row left and right to foreground colour
;
; ***************************************************************************************
.plotHorizontalFillLRToFg
    LDA #1                                              ; A = 1
    LDX #0                                              ; X = 0 means fill to foreground pixels
    BEQ .plotHorizontalFillLR                           ; ALWAYS branch

; ***************************************************************************************
;
; Plot row right to background colour
;
; ***************************************************************************************
.plotHorizontalFillRToBg
    LDA #1                                              ; A = 1
    TAX                                                 ; X = 1 means fill to background pixels
    BNE .plotHorizontalFillR                            ;

; ***************************************************************************************
;
; Plot row right to non-foreground colour
;
; ***************************************************************************************
.plotHorizontalFillRToNonFg
    LDA #0                                              ; A = 0 means fill to 'non-'
    TAX                                                 ; X = 0 means fill to foreground pixels
.plotHorizontalFillR
    STA .vduWorkspaceI                                  ; .vduWorkspaceI = 0 meaning 'non-foreground or non-background'
                                                        ;               or 1 meaning 'foreground or background'
    JSR .setupCurrentPattern                            ;

    LDY #3                                              ; loop counter
-
    LDA .vdu25ParameterXLow,Y                           ; }
    STA .vduOldGraphicsCursorPixelsXLow,Y               ; }
    STA .vduGraphicsCursorPixelsXLow,Y                  ; } set the old graphics cursor and
    DEY                                                 ; } the current graphics cursor
    BPL -                                               ; } to the parameter point

    JSR .fillRight                                      ;
    JMP .copyWorkspaceCacheBackIntoCharacterDefinitons  ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 19: Rectangle copy and move
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Moving a rectangle
;
; See rect_move.png
;
; ***************************************************************************************

; ***************************************************************************************
;
; Check coordinate of a point is in the window bounds vertically
;
; On Entry:
;       X is the offset to the coordinate to check
; On Exit:
;       .vduTempStoreDA is the error code:
;           0 = no error
;           1 = first check failed
;           2 = second check failed
;       Zero flag set if no error
;
; ***************************************************************************************
.checkPointIsWithinBoundsVertically
    LDY #2                                              ;
    ; fall through...

; ***************************************************************************************
;
; Check coordinate of a point is in the window bounds (horizontal or vertical)
;
; On Entry:
;       X is the offset to the coordinate to check
;       Y is the offset to the second variable to check (0 for horizontal or 2 for vertical)
; On Exit:
;       A=.vduTempStoreDA is the error code (0 = no error, 1 = first check failed, 2 = second check failed)
;       Zero flag set if no error
;
; ***************************************************************************************
.checkPointIsWithinBounds
    LDA #0                                              ;
    STA .vduTempStoreDA                                 ;
    DEX                                                 ;
    DEX                                                 ;
    JSR .checkPointIsWithinWindowHorizontalOrVertical   ;

    INX                                                 ;
    INX                                                 ;
    LDA .vduTempStoreDA                                 ;
    RTS                                                 ;

; ***************************************************************************************
.blockCopyOrMoveScreenRectangle
    LDA .vdu25ParameterPlotType                         ;
    JSR .blockCopyOrMoveScreenRectangleInternal         ;
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Copy a rectangle of pixels on-screen to a destination on screen
;
; Optionally fill the source rectangle the current graphics background colour ('Move').
;
; On Entry:
;   A: Holds the plot type:
;     $B8 (184) Move only       relative
;     $B9 (185) Move rectangle  relative
;     $BA (186) Copy rectangle  relative
;     $BB (187) Copy rectangle  relative
;     $BC (188) Move only       absolute
;     $BD (189) Move rectangle  absolute
;     $BE (190) Copy rectangle  absolute
;     $BF (191) Copy rectangle  absolute
;
; ***************************************************************************************
.blockCopyOrMoveScreenRectangleInternal
    AND #2                                              ;
    STA .rectCopyPlotType                               ; 0=Move, 2=Copy

    ; Set up gcol mask bytes from the plot options table
    LDA .gcolPlotOptionsTable                           ;
    STA .gcolModeMask0                                  ;
    LDA .gcolPlotOptionsTable + 1                       ;
    STA .gcolModeMask1                                  ;
    LDA .gcolPlotOptionsTable - 1                       ;
    STA .gcolModeMask2                                  ;
    LDA .gcolPlotOptionsTable + 4                       ;
    STA .gcolModeMask3                                  ;

    ; Set background colour / pattern
    LDX #1                                              ; X = 1 for background
    JSR .setupCurrentPattern                            ;

    ; Copy background pattern into fill pattern
    LDX #7                                              ; loop counter
-
    LDA .gxrCurrentPattern,X                            ;
    STA .fillPattern,X                                  ; copy current pattern into fillPattern
    DEX                                                 ; for 8 bytes
    BPL -                                               ; if (not done yet) then branch (loop back)

    ; Sort graphics cursor point and old point (the source rectangle coordinates)
    ; so we have bottom left and top right points
    LDX #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart ;
    JSR .sortCoordinatesAsBottomLeftAndTopRight         ; .rectSourceLeft/Bottom = bottom left coordinates
                                                        ; .rectSourceRight/Top   = top right coordinates

    ; Calculate destination rectangle for the operation.
    ; Copy the PLOT parameter point (position to move to) into the destination bottom left
    LDY #.rectDestinationLeft - .vduVariablesStart      ; copy bytes destination
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; copy bytes source
    JSR .copyFourBytesWithinVDUVariables                ; .rectDestinationLeft/Bottom = PLOT parameter point

    STY .vduTempStoreDA                                 ; .vduTempStoreDA = #.rectDestinationRight - .vduVariablesStart
                                                        ;                 = destination right
                                                        ; (the destination address for the next calculation)

    ; Calculate:
    ; .rectDestinationRight/Top = (source rect top right - source rect bottom left) + destination rectangle bottom left point
    ;                           = (source width, height) + destination rectangle bottom left point
    ;                           = destination rectangle top right point
    LDX #.rectDestinationLeft - .vduVariablesStart      ; } .rectDestinationRight = source rect right + dest left - source rect left
    LDY #.rectSourceRight - .vduVariablesStart          ; } .rectDestinationTop   = source rect top + dest bottom - source rect bottom
    LDA #.rectSourceLeft - .vduVariablesStart           ; } ie. destination top right
    JSR .calculatePointVduYPlusVduXMinusVduA            ; }

    ; Set X = leftmost of 'source rectangle' and 'dest rectangle'
    ; Set Y = rightmost of 'source rectangle' and 'dest rectangle'
    LDX #.rectSourceLeft - .vduVariablesStart           ;
    LDY #.rectDestinationLeft - .vduVariablesStart      ;
    JSR .sortCoordinatesXYByColumn                      ;

    STA .gxrScratchspace3                               ; } [NOTE: redundant instruction]
    TYA                                                 ; }
    PHA                                                 ; } Remember Y and X, [NOTE: redundantly preserving A]
    TXA                                                 ; }
    PHA                                                 ; }
    LDA .gxrScratchspace3                               ; } [NOTE: redundant instruction]

    ; Find left edge (clip leftmost point to graphics window)
    LDY #0                                              ;
    JSR .checkPointIsWithinBounds                       ; check within bounds horizontally
    ; A is the error code (0 = in bounds, 1 = point is left of graphics window, 2 = point is right of graphics window)
    BEQ .yesLeftEdgeInBounds                            ; if (leftmost edge point is in bounds) then branch

    LSR                                                 ; check if off the left edge
    BEQ .leftEdgeNeedsClipping                          ; if (leftmost edge point is to the left of the graphics window) then branch

    ; Leftmost edge is to the right of the graphics window.
    ; Nothing to do, rectangle is entirely out of bounds, so pull remembered values and return
    PLA                                                 ; forget about the previously saved X
.pullAndReturn
    PLA                                                 ; forget about the previously saved Y
    RTS                                                 ;

.leftEdgeNeedsClipping
    LDX #.vduGraphicsWindowPixelsLeftLow - .vduVariablesStart   ; start at left edge of graphics window
.yesLeftEdgeInBounds
    ; At this point X holds the index of the leftmost edge (which has been clipped to graphics window left)
    PLA                                                 ; A=leftmost of 'source rectangle' left and 'dest rectangle' left coordinates

    LDY #.vduWorkspaceI - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ; where to put results
    LDY #.rectSourceLeft - .vduVariablesStart           ; Y=source rectangle left coordinate
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ; IJ = source rectangle left coordinate + clipped left edge - leftmost of 'source rectangle' and 'dest rectangle' left coordinates
                                                        ;    = where in X to start copying/moving from (taking into account any source/destination left clip)

    LDY #.vduWorkspaceU - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ; where to put results
    LDY #.rectDestinationLeft - .vduVariablesStart      ; Y=destination rectangle left coordinate
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ; UV = destination rectangle left coordinate + clipped left edge - leftmost of 'source rectangle' left and 'dest rectangle' left coordinates
                                                        ;    = where in X to start copying/moving to (taking into account any source/destination left clip)

    PLA                                                 ; A=rightmost of 'source rectangle' left and 'dest rectangle' left coordinates
    CLC                                                 ;
    ADC #4                                              ; add four to X to get to right coordinate
    TAX                                                 ;
    PHA                                                 ; push A
    LDY #0                                              ;
    JSR .checkPointIsWithinBounds                       ; check if rightmost point is in bounds
    ; A is the error code (0 = in bounds, 1 = point is left of graphics window, 2 = point is right of graphics window)
    BEQ .yesRightEdgeInBounds                           ;
    LSR                                                 ;
    BEQ .pullAndReturn                                  ; if (rightmost point is left of the graphics window) then branch (nothing to do, return)

    ; Rightmost left edge is to the right of the graphics window: clip
    LDX #.vduGraphicsWindowPixelsRightLow - .vduVariablesStart  ; right edge
.yesRightEdgeInBounds
    PLA                                                 ; A=rightmost of 'source rectangle' left and 'dest rectangle' left coordinates
    LDY #.vduWorkspaceY - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ; where to put results
    LDY #.rectDestinationRight - .vduVariablesStart     ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ; .vduWorkspaceYZ = dest rect right + (clipped rightmost left point) - (rightmost left point)
                                                        ;                 = clipped right edge of destination

    ; Which is larger .vduWorkspaceYZ or .vduWorkspaceUV?
    ; i.e. which is larger, the destination left edge when clipped, or destination right edge when clipped?
    ; i.e. are we completely clipped?
    LDA .vduWorkspaceY                                  ;
    CMP .vduWorkspaceU                                  ;
    LDA .vduWorkspaceZ                                  ;
    SBC .vduWorkspaceV                                  ;
    BPL .someOfScreenNeedsMovingOrCopying               ; if (.vduWorkspaceYZ >= .vduWorkspaceUV) then branch (there are screen pixels that need copying)

    ; All of the source or all of the destination rectangle is clipped out. Therefore no
    ; screen pixels are to be copied/moved.
    ; Just fill in the source / dest rectangles in the background colour.
    LDA .rectCopyPlotType                               ; 0=Move, 2=Copy
    BNE .skipFillSourceRect                             ; if (copy rectangle) then branch

    ; Move rectangle, so fill source rectangle in background colour
    JSR .plotRectangleInternal                          ;

.skipFillSourceRect
    ; Copy destination rect to source rect
    LDX #.rectDestinationLeft - .vduVariablesStart      ; source of the 'copy eight bytes' routine
    LDY #.rectSourceLeft - .vduVariablesStart           ; destination of the 'copy eight bytes' routine
    JSR .copyEightBytesWithinVDUVariables               ;

    ; Plot source rectangle in background colour, and return
    JMP .plotRectangleInternal                          ;

.someOfScreenNeedsMovingOrCopying
    LDA #0                                              ;
    STA .rectCopyShiftingLeftFlag                       ; not shifting left initially (flag = 0)

    LDA .vduWorkspaceI                                  ; source X (low)
    AND .vduPixelsPerByteMinusOne                       ;
    STA .vduTempStoreDA                                 ; DA = the offset within the byte to start copying from

    LDA .vduWorkspaceU                                  ; destination X (low)
    AND .vduPixelsPerByteMinusOne                       ; the offset within the byte to start copying to
    SEC                                                 ;
    SBC .vduTempStoreDA                                 ; compare against the offset within the byte for the source
    BPL +                                               ; if (destination offset >= source offset) then branch (shifting bytes right or not at all)

    DEC .rectCopyShiftingLeftFlag                       ; we are shifting bytes left (flag = 255)
    AND .vduPixelsPerByteMinusOne                       ;
+
    STA .rectCopyNumberOfTimesToShiftByte               ; amount to shift each byte
    PHA                                                 ;

    ; Calculate number of pixels to copy into next byte
    EOR #$FF                                            ; }
    CLC                                                 ; } negate A
    ADC #1                                              ; }
    AND .vduPixelsPerByteMinusOne                       ;
    STA .rectCopyShiftToNextByte                        ;

    ; Calculate pixel mask needed
    PLA                                                 ; A = amount to shift each byte
    CLC                                                 ;
    ADC .vduPixelsPerByteMinusOne                       ; add offset based on current MODE
    TAX                                                 ;
    LDA .plotByteMaskTable - 1,X                        ; read mask value for the number of pixels to shift
    STA .gxrScratchspace2                               ; store pixel mask

    ; Prepare masks and byte width
    LDX #.vduWorkspaceU - .vduVariablesStart            ; destination X left
    LDY #.vduWorkspaceY - .vduVariablesStart            ; destination X right
    JSR .rectCopyPrepareMasksAndGetByteWidth            ;
    STA .rectCopyByteWidth                              ; store byte width

    LDA .vduCurrentPlotByteMask                         ;
    STA .rectCopyByteMask                               ; store into current pixel mask

    LDA .vduTempStoreDC                                 ;
    STA .gxrScratchspace1                               ;

    LDX #0                                              ;
    JSR .compareCDXwithGHX                              ; compare .vduWorkspaceCD with .vduWorkspaceGH (top and bottom coordinates)
    BEQ .rectCopyOneRow                                 ; if (top and bottom coordinates are equal) then branch (only one row to copy)

    ; Compare .vduWorkspaceCD with .vduWorkspaceOP (signed)
    ; Work out if we need to copy the rectangle from the top down or the bottom up
    ; to avoid overlapping source and destination problems.
    LDA .vduWorkspaceC                                  ;
    CMP .vduWorkspaceO                                  ;
    LDA .vduWorkspaceD                                  ;
    SBC .vduWorkspaceP                                  ;
    BVC +                                               ; if (result of subtraction high byte remains within the range -128 to 127) then branch
    ; Result of subtraction high byte moved outside the range -128 to 127
    EOR #$80                                            ; flip sign bit
+
    BMI .rectCopyDecrementingRows                       ;

    ; Main loop to copy rows, incrementing the row each time
-
    JSR .rectCopyOneRow                                 ;
    LDX #0                                              ;
    JSR .incWorkspaceCDCompareGH                        ; increment .vduWorkspaceCD
    LDX #.vduWorkspaceO - .vduWorkspaceC                ;
    JSR .incWorkspaceCDCompareGH                        ; increment .vduWorkspaceOP, compare with .vduWorkspaceST
    BNE -                                               ;
    JMP .rectCopyOneRow                                 ;

.rectCopyDecrementingRows
    LDX #.vduWorkspaceC - .vduVariablesStart            ;
    LDY #.vduWorkspaceG - .vduVariablesStart            ;
    JSR .exchangeTwoVDUBytes                            ;

    LDX #.vduWorkspaceO - .vduVariablesStart            ;
    LDY #.vduWorkspaceS - .vduVariablesStart            ;
    JSR .exchangeTwoVDUBytes                            ;

    ; Main loop to copy rows, decrementing the row each time
-
    JSR .rectCopyOneRow                                 ;
    LDX #0                                              ;
    JSR .decWorkspaceCDCompareGH                        ; decrement .vduWorkspaceCD
    LDX #.vduWorkspaceO - .vduWorkspaceC                ;
    JSR .decWorkspaceCDCompareGH                        ; decrement .vduWorkspaceOP, compare with .vduWorkspaceST
    BNE -                                               ;

.rectCopyOneRow
    ; .vduWorkspaceKL = .vduWorkspaceCD
    LDX #.vduWorkspaceC - .vduVariablesStart            ;
    LDY #.vduWorkspaceK - .vduVariablesStart            ;
    JSR .copyTwoBytesWithinVDUVariables                 ;

    ; .vduWorkspaceWX = .vduWorkspaceOP
    LDX #.vduWorkspaceO - .vduVariablesStart            ;
    LDY #.vduWorkspaceW - .vduVariablesStart            ;
    JSR .copyTwoBytesWithinVDUVariables                 ;

    ; Is .vduWorkspaceCD in the graphics window vertically?
    LDX #.vduWorkspaceC - .vduVariablesStart            ;
    JSR .checkPointIsWithinBoundsVertically             ;
    PHA                                                 ; remember result of bounds test

    ; Is .vduWorkspaceOP in the graphics window vertically?
    LDX #.vduWorkspaceO - .vduVariablesStart            ;
    JSR .checkPointIsWithinBoundsVertically             ;

    BEQ .inBoundsVertically                             ;

    PLA                                                 ;
    BNE .return32                                       ; if (.vduWorkspaceCD is out of bounds vertically) then branch (return)

    LDA .rectCopyPlotType                               ; 0=Move, 2=Copy
    BEQ .moveRectRow                                    ; if (move) then branch

.return32
    RTS                                                 ;

.moveRectRow
    LDX #.vduWorkspaceA - .vduVariablesStart            ;
    LDY #.vduWorkspaceE - .vduVariablesStart            ;
    JMP .copyCoordinatesSetMasksAndFillRowLocal         ; [NOTE: no need for this local jump, just JMP .copyCoordinatesSetMasksAndFillRow]

.inBoundsVertically
    PLA                                                 ; recall result of first bounds test
    BEQ .doneClippingVertically                         ; if (.vduWorkspaceCD is in bounds) then branch

    ; Fill row from .vduWorkspaceMN to .vduWorkspaceQR
    LDX #.vduWorkspaceM - .vduVariablesStart            ;
    LDY #.vduWorkspaceQ - .vduVariablesStart            ;
.copyCoordinatesSetMasksAndFillRowLocal
    JMP .copyCoordinatesSetMasksAndFillRow              ;

.doneClippingVertically
    LDX #.vduWorkspaceI - .vduVariablesStart            ;
    JSR .gxrSetScreenAddressAndSetGraphicsColourMask    ; prepare graphics variables

    BIT .rectCopyShiftingLeftFlag                       ;
    BMI .rectCopyRowIntoCache                           ; if (flag >= 128) then branch

    ; Decrement graphics cursor cell address by eight
    SEC                                                 ;
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ;
    SBC #8                                              ;
    STA .vduScreenAddressOfGraphicsCursorCellLow        ;
    BCS .rectCopyRowIntoCache                           ;
    DEC .vduScreenAddressOfGraphicsCursorCellHigh       ;

.rectCopyRowIntoCache
    ; Copy one row of screen pixels into cache, shifting the pixels as needed ready for
    ; writing to the destination.
    LDA .rectCopyByteWidth                              ;
    STA .vduTempStoreDD                                 ; store byte width (loop counter)
.rectCopyRowLoop

    ; get screen byte
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
} else if MACHINE = BBC_B_PLUS {
    JSR .checkPixelIsBackgroundColourFast               ; read byte from screen
    EOR .vduBackgroundGraphicsColour                    ; undo the unwanted eor from subroutine call
} else {
    +unknown_machine
}

    LDX .rectCopyShiftToNextByte                        ; number of times to shift left
    BEQ +                                               ;

    ; Shift A left by X bits: i.e. A = A << X
.shiftByteLeftLoop
    ASL                                                 ;
    DEX                                                 ;
    BNE .shiftByteLeftLoop                              ;

+
    STA .vduTempStoreDA                                 ; store pixels from the previous byte
    SEC                                                 ;
    JSR .moveGraphicsCursorAddressTotheRight            ;

    ; get screen byte
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
} else if MACHINE = BBC_B_PLUS {
    LDX .vduTempStoreDA                                 ; remember DA in X
    JSR .checkPixelIsBackgroundColourFast               ; read byte from screen
    EOR .vduBackgroundGraphicsColour                    ; undo the unwanted eor from subroutine call
    STX .vduTempStoreDA                                 ; undo the unwanted sta from subroutine call
} else {
    +unknown_machine
}

    LDX .rectCopyNumberOfTimesToShiftByte               ;
    BEQ .afterShifting                                  ;

    ; Shift A right by X bits: i.e. A = A >> X
.shiftByteRightLoop
    LSR                                                 ;
    DEX                                                 ;
    BNE .shiftByteRightLoop                             ;

.afterShifting
    EOR .vduTempStoreDA                                 ; }
    AND .gxrScratchspace2                               ; } apply pixel mask, with the previous byte data
    EOR .vduTempStoreDA                                 ; }
    LDX .vduTempStoreDD                                 ;
    STA .rectCopyRowCache,X                             ; store into current row data
    DEC .vduTempStoreDD                                 ; loop counter
    BPL .rectCopyRowLoop                                ;

    ; The row bytes are now stored in cache

    ; Fill row from .vduWorkspaceMN to .vduWorkspaceQR
    LDX #.vduWorkspaceM - .vduVariablesStart            ;
    LDY #.vduWorkspaceQ - .vduVariablesStart            ;
    JSR .copyCoordinatesSetMasksAndFillRow              ;

    ; If moving rather than copying, call .moveRectRow
    LDA .rectCopyPlotType                               ; 0=Move, 2=Copy
    BNE .rectSkipMove                                   ; if (copy) then branch

    JSR .moveRectRow                                    ;

.rectSkipMove
    LDX #.vduWorkspaceU - .vduVariablesStart            ;
    JSR .gxrSetScreenAddressAndSetGraphicsColourMask    ; prepare graphics variables

    ; Write the mask of the initial byte
    LDA .rectCopyByteMask                               ;
    STA .vduTempStoreDA                                 ;

    ; If width is zero, then there are no whole bytes to copy, jump forward
    LDX .rectCopyByteWidth                              ;
    BEQ .rectHaveFilledRowWholeBytes                    ;

    ; Write the first byte of the row, a masked partial byte
    JSR .rectWritePatternByteMasked                     ;

    ; Now make the mask full for the run of whole bytes to write
    LDA #$FF                                            ;
    STA .vduTempStoreDA                                 ;

    ; Write the whole bytes along the row in a loop
    JMP .rectPatternFillRowEntry                        ;

.rectPatternFillRowLoop
    LDA .rectCopyRowCache,X                             ;

    ; store screen byte
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
} else if MACHINE = BBC_B_PLUS {
    JSR .plotFast                                       ; write byte to screen
} else {
    +unknown_machine
}

.rectPatternFillRowEntry
    SEC                                                 ;
    JSR .moveGraphicsCursorAddressTotheRight            ;

    DEX                                                 ;
    BNE .rectPatternFillRowLoop                         ;

.rectHaveFilledRowWholeBytes
    ; With the whole bytes done, create a mask for the final byte
    LDA .gxrScratchspace1                               ;
    EOR #$FF                                            ;
    AND .vduTempStoreDA                                 ;
    STA .vduTempStoreDA                                 ;

.rectWritePatternByteMasked
    ; Write the final byte of the row
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    LDA .rectCopyRowCache,X                             ;
    EOR (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    AND .vduTempStoreDA                                 ;
    EOR (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    RTS                                                 ;
} else if MACHINE = BBC_B_PLUS {
    LDA .vduTempStoreDA                                 ; stash value at $DA which subroutine call will corrupt
    STA .vduTempStoreDB                                 ;
    JSR .checkPixelIsBackgroundColourFast               ; read byte from screen
    EOR .vduBackgroundGraphicsColour                    ; undo the unwanted eor from subroutine call
    STA .vduTempStoreDA                                 ; set $DA to ($D6),Y
    EOR .rectCopyRowCache,X                             ;
    AND .vduTempStoreDB                                 ;
    EOR .vduTempStoreDA                                 ;
    JMP .plotFast                                       ; write byte to screen
} else {
    +unknown_machine
}



; ***************************************************************************************
;
; Helper for rectangle copy (increment and compare)
;
; Increment    .vduWorkspaceCD[X]
; Compare with .vduWorkspaceGH[X]
;
; On Entry:
;   X: offset from .vduWorkspaceC (in practice 0 for .vduWorkspaceCD or 12 for .vduWorkspaceOP)
; On Exit:
;   C,Z: We set flags comparing .vduWorkspaceCD[X] with .vduWorkspaceGH[X]
;
; ***************************************************************************************
.incWorkspaceCDCompareGH
    ; Increment .vduWorkspaceCD[X]
    INC .vduWorkspaceC,X                                ;
    BNE .compareCDXwithGHX                              ;
    INC .vduWorkspaceD,X                                ;
    JMP .compareCDXwithGHX                              ;

; ***************************************************************************************
;
; Helper for rectangle copy (decrement and compare)
;
; Decrement    .vduWorkspaceCD[X]
; Compare with .vduWorkspaceGH[X]
;
; On Entry:
;   X: offset from .vduWorkspaceC (in practice 0=.vduWorkspaceCD or 12=.vduWorkspaceOP)
; On Exit:
;   C,Z: We set flags comparing .vduWorkspaceCD[X] with .vduWorkspaceGH[X]
;
; ***************************************************************************************
.decWorkspaceCDCompareGH
    ; Decrement .vduWorkspaceCD[X]
    LDA .vduWorkspaceC,X                                ;
    BNE +                                               ;
    DEC .vduWorkspaceD,X                                ;
+
    DEC .vduWorkspaceC,X                                ;

.compareCDXwithGHX
    LDA .vduWorkspaceC,X                                ;
    CMP .vduWorkspaceG,X                                ;
    BNE +                                               ;

    LDA .vduWorkspaceD,X                                ;
    CMP .vduWorkspaceH,X                                ;
+
    RTS                                                 ;

; ***************************************************************************************
;
; Add two points and subtract a third
;
; vdu[.vduTempStoreDA,DB]     = vdu[Y+0,Y+1] + vdu[X+0,X+1] - vdu[A+0, A+1]
; vdu[(.vduTempStoreDA,DB)+2] = vdu[Y+2,Y+3] + vdu[X+2,X+3] - vdu[A+2, A+3]
;
; ***************************************************************************************
.calculatePointVduYPlusVduXMinusVduA
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

    ; Move A,X,Y,and DA on by 2 for Y coordinates
    INY                                                 ;
    INY                                                 ;
    INX                                                 ;
    INX                                                 ;
    CLC                                                 ;
    ADC #2                                              ;
    INC .vduTempStoreDA                                 ;
    INC .vduTempStoreDA                                 ;
    ; fall through...

; ***************************************************************************************
;
; Add two coordinates and subtract a third
;
; vdu[vduTempStoreDA,DB] = vdu[Y,Y+1] + vdu[X,X+1] - vdu[A, A+1]
;
; ***************************************************************************************
.calculateCoordinateVduYPlusVduXMinusVduA
    STA .gxrScratchspace3                               ; }
    TXA                                                 ; }
    PHA                                                 ; } Remember X,Y, preserving A
    TYA                                                 ; }
    PHA                                                 ; }
    LDA .gxrScratchspace3                               ; }

    PHA                                                 ; remember A

    ; DE/Scratchspace3 = vdu[X] + vdu[Y]
    CLC                                                 ;
    LDA .vduVariablesStart,X                            ;
    ADC .vduVariablesStart,Y                            ;
    STA .vduTempStoreDE                                 ; DE = vdu[X] + vdu[Y]
    LDA .vduVariablesStart+1,X                          ;
    ADC .vduVariablesStart+1,Y                          ;
    STA .gxrScratchspace3                               ; scratchspace = vdu[X+1] + vdu[Y+1]
    PLA                                                 ; recall A

    TAX                                                 ; X=original A
    LDA .gxrScratchspace3                               ;
    PHA                                                 ; remember vdu[X+1] + vdu[Y+1]

    ; vdu[vduTempStoreDA] = DE/Scratchspace3 - vdu[A]
    LDY .vduTempStoreDA                                 ; Y=DA
    SEC                                                 ; }
    LDA .vduTempStoreDE                                 ; }
    SBC .vduVariablesStart,X                            ; } vdu[.vduTempStoreDA] = vdu[X] + vdu[originalY] - vdu[originalA]
    STA .vduVariablesStart,Y                            ; }
    PLA                                                 ; recall A
    SBC .vduVariablesStart+1,X                          ;
    STA .vduVariablesStart+1,Y                          ; vdu[.vduTempStoreDA+1] = vdu[X+1] + vdu[originalY+1] - vdu[originalA+1]

    STX .gxrScratchspace3                               ; remember original A
    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } Recall A,X,Y
    TAX                                                 ; }
    LDA .gxrScratchspace3                               ; }
    RTS                                                 ;

; ***************************************************************************************
;
; Prepare masks ready for the rectangle copy, and return the width in bytes.
;
; On Exit:
;   .vduTempStoreDC:         pixel mask
;   .vduCurrentPlotByteMask: pixel mask
;   A = byte width to copy
;
; ***************************************************************************************
.rectCopyPrepareMasksAndGetByteWidth
    LDA .vduVariablesStart+1,Y                          ; }
    PHA                                                 ; } push destination right X coordinate
    LDA .vduVariablesStart,Y                            ; }
    PHA                                                 ; }

    ; Calculate Y = table offset
    AND .vduPixelsPerByteMinusOne                       ; get offset within a byte
    CLC                                                 ;
    ADC .vduPixelsPerByteMinusOne                       ; add value based on current MODE
    TAY                                                 ;

    ; Read the byte value that will set one pixel to white leaving the remainder black.
    LDA .sixteenColourMODEMaskTable - 1,Y               ;
    EOR .plotByteMaskTable - 1,Y                        ; just the rightmost pixels
    STA .vduTempStoreDC                                 ;

    LDA .vduVariablesStart,X                            ; leftmost destination X coordinate

    ; Calculate Y = table offset
    AND .vduPixelsPerByteMinusOne                       ; get offset within a byte
    ADC .vduPixelsPerByteMinusOne                       ; add value based on current MODE
    TAY                                                 ;

    LDA .plotByteMaskTable - 1,Y                        ;
    STA .vduCurrentPlotByteMask                         ;

    ; Calculate (A, vduTempStoreDD) = byte width to copy
    SEC                                                 ;
    PLA                                                 ; destination right X coordinate (low)
    ORA .vduPixelsPerByteMinusOne                       ; round up to a byte's worth
    SBC .vduVariablesStart,X                            ; take of the left edge (low)
    TAY                                                 ; remember in Y

    PLA                                                 ; destination right X coordinate (high)
    SBC .vduVariablesStart+1,X                          ; take off left edge (high byte)
    STA .vduTempStoreDD                                 ; store
    TYA                                                 ; recall low byte

    ; A is low byte
    ; .vduTempStoreDD is high byte

    ; MODE  vduPixelsPerByteMinusOne    divide
    ;  0    7                           /8
    ;  1    3                           /4
    ;  2    1                           /2
    ;  3    (not a graphics mode)
    ;  4    7                           /8
    ;  5    3                           /4

    LDY .vduPixelsPerByteMinusOne                       ;
    CPY #3                                              ;
    BEQ .divideTwo                                      ;
    BCC .divideLow                                      ;

    ; Divide by four
    LSR .vduTempStoreDD                                 ;
    ROR                                                 ;
.divideTwo
    LSR .vduTempStoreDD                                 ;
    ROR                                                 ;

.divideLow
    LSR                                                 ; divide low byte by two. No need to
    RTS                                                 ; divide high byte by two, since it
                                                        ; will already be zero by this point.

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 20: Sprite plotting
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Plot a sprite
;
; ***************************************************************************************
.plotSprite
    LDY #.workspaceOffsetCurrentSpriteAddressLow        ; }
    LDA (.privateWorkspaceLow),Y                        ; } get current sprite address
    INY                                                 ; }
    ORA (.privateWorkspaceLow),Y                        ; }
    BNE .plotSpriteInternal                             ; if (we have a sprite address) then branch
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

.plotSpriteInternal
    LDA (.privateWorkspaceLow),Y                        ;
    TAX                                                 ; X = sprite address high
    DEY                                                 ;
    LDA (.privateWorkspaceLow),Y                        ; A = sprite address low
    STA .privateWorkspaceLow                            ; } make .privateWorkspace point
    STX .privateWorkspaceHigh                           ; } to current sprite

    ; Copy sprite header to workspace (for easier access)
    LDY #5                                              ; loop counter
-
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vduWorkspaceA,Y                                ; } copy sprite header
    DEY                                                 ; } to .vduWorkspaceA
    BPL -                                               ; }

    ; .vduWorkspaceCD = length of sprite data (including 6 byte header)
    CLC                                                 ; }
    LDA .privateWorkspaceLow                            ; }
    ADC #6                                              ; }
    STA .vduWorkspaceC                                  ; } .vduWorkspaceCD = sprite size
    LDA .privateWorkspaceHigh                           ; } (including header)
    ADC #0                                              ; }
    STA .vduWorkspaceD                                  ; }

    ; Reset .vduWorkspaceEFGH, .vduWorkspaceIJ (sprite width), and .vduWorkspaceKL (sprite height) to zero
    LDY #7                                              ; loop counter
    LDA #0                                              ;
-
    STA .vduWorkspaceE,Y                                ;
    DEY                                                 ;
    BPL -                                               ;

    LDA .vduWorkspaceA                                  ; sprite width
    STA .vduWorkspaceI                                  ; .vduWorkspaceI = sprite width-1 (in bytes)
    LDA .vduWorkspaceB                                  ; sprite height
    STA .vduWorkspaceK                                  ; .vduWorkspaceK = sprite height-1 (in pixels)

    ; .vduWorkspaceIJ = ((width in bytes-1) * pixels per byte) + (pixels per byte - 1) = width in pixels - 1
    LDA .vduPixelsPerByteMinusOne                       ; loop counter
-
    ASL .vduWorkspaceI                                  ; IJ *= 2
    ROL .vduWorkspaceJ                                  ;
    LSR                                                 ; loop counter divided by 2
    BNE -                                               ;

    ; Add the number of pixels per byte minus one
    LDA .vduPixelsPerByteMinusOne                       ;
    ORA .vduWorkspaceI                                  ;
    STA .vduWorkspaceI                                  ; I = I OR pixels per byte

    ; .vduWorkspaceMNOP = PLOT parameter
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; source
    LDY #.vduWorkspaceM - .vduVariablesStart            ; destination
    JSR .copyFourBytesWithinVDUVariables                ; copy: .vduWorkspaceMNOP = Parameter point

    STY .vduTempStoreDA                                 ; Store Y=.vduWorkspaceQ - .vduVariablesStart

    ; Mask off fractional pixel amounts from X coordinate
    LDA .vduPixelsPerByteMinusOne                       ;
    EOR #$FF                                            ;
    AND .vduWorkspaceM                                  ;
    STA .vduWorkspaceM                                  ;

    ; .vduWorkspaceQRST = .vduWorkspaceIJKL + .vduWorkspaceMNOP - .vduWorkspaceEFGH
    ;                   = (width-1,height-1) + PLOT point - zero
    ;                   = top right corner of sprite
    LDX #.vduWorkspaceM - .vduVariablesStart            ; PLOT point
    LDY #.vduWorkspaceI - .vduVariablesStart            ; sprite (width-1, height-1)
    LDA #.vduWorkspaceE - .vduVariablesStart            ; zero
    JSR .calculatePointVduYPlusVduXMinusVduA            ;

    ; Check if point .vduWorkspaceMNOP (bottom left of sprite) is within the graphics window
    LDX #.vduWorkspaceM - .vduVariablesStart            ;
    JSR .checkPointXIsWithinGraphicsWindow              ;
    ;       %0000   success (gpoint is within window)
    ;       %0001   gpoint X is left of  the left   edge of the graphics window
    ;       %0010   gpoint X is right of the right  edge of the graphics window
    ;       %0100   gpoint Y is below    the bottom edge of the graphics window
    ;       %1000   gpoint Y is above    the top    edge of the graphics window
    BEQ .plotSpriteAfterClippingBottomLeft              ; if (within the graphics window) then branch
    AND #%1010                                          ; look to see if above or right
    BEQ .clipSpriteBottomLeft                           ; if (to the left or below the graphics window) then branch

    ; Destination is outside of the graphics window (to the right or above) so nothing
    ; will get drawn. Finish up.
.finishUp
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

.clipSpriteBottomLeft
    LDA .vduTempStoreDA                                 ; check result of graphics window boundary check
    PHA                                                 ; remember it
    AND #%0001                                          ;
    BEQ .doneLeftClip                                   ; if (not left of the graphics window) then branch

    ; Clip sprite to left edge of graphics window
    LDX #.vduGraphicsWindowPixelsLeftLow - .vduVariablesStart ;
    LDY #.vduWorkspaceE - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ;
    LDA #.vduWorkspaceM - .vduVariablesStart            ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

    LDY #.vduWorkspaceM - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

.doneLeftClip
    PLA                                                 ; check result of graphics window boundary check
    AND #%0100                                          ; check if below
    BEQ .plotSpriteAfterClippingBottomLeft              ; if (not below the graphics window) then branch

    ; Clip sprite to bottom edge of graphics window
    LDX #.vduGraphicsWindowPixelsBottomLow - .vduVariablesStart ;
    LDY #.vduWorkspaceG - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ;
    LDA #.vduWorkspaceO - .vduVariablesStart            ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

    LDY #.vduWorkspaceO - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

.plotSpriteAfterClippingBottomLeft
    ; Check if point .vduWorkspaceQRST (top right corner of sprite) is within graphics window
    LDX #.vduWorkspaceQ - .vduVariablesStart            ;
    JSR .checkPointXIsWithinGraphicsWindow              ;
    ;       %0000   success (gpoint is within window)
    ;       %0001   gpoint X is left of  the left   edge of the graphics window
    ;       %0010   gpoint X is right of the right  edge of the graphics window
    ;       %0100   gpoint Y is below    the bottom edge of the graphics window
    ;       %1000   gpoint Y is above    the top    edge of the graphics window

    BEQ .plotSpriteAfterClippingTopRight                ; if (within graphics window) then branch

    AND #%0101                                          ;
    BNE .finishUp                                       ; if (below or left of the graphics window) then branch (finish up)

    LDA .vduTempStoreDA                                 ; check result of graphics window boundary check
    PHA                                                 ; remember it
    AND #%0010                                          ;
    BEQ .doneRightClip                                  ; if (not right of the graphics window) then branch

    ; Clip sprite to right edge of graphics window
    LDX #.vduGraphicsWindowPixelsRightLow - .vduVariablesStart ;
    LDY #.vduWorkspaceI - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ;
    LDA #.vduWorkspaceQ - .vduVariablesStart            ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

    LDY #.vduWorkspaceQ - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

.doneRightClip
    PLA                                                 ;
    AND #%1000                                          ;
    BEQ .plotSpriteAfterClippingTopRight                ; if (not above the graphics window) then branch

    ; Clip sprite to the top of the graphics window
    LDX #.vduGraphicsWindowPixelsTopLow - .vduVariablesStart ;
    LDY #.vduWorkspaceK - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ;
    LDA #.vduWorkspaceS - .vduVariablesStart            ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

    LDY #.vduWorkspaceS - .vduVariablesStart            ;
    STY .vduTempStoreDA                                 ;
    JSR .calculateCoordinateVduYPlusVduXMinusVduA       ;

.plotSpriteAfterClippingTopRight
    ; All clipping is done

    ; Divide X pixel coordinates to get byte coordinates again
    LDA .vduPixelsPerByteMinusOne                       ;
.getByteCoordinates
    LSR .vduWorkspaceJ                                  ;
    ROR .vduWorkspaceI                                  ;
    LSR .vduWorkspaceF                                  ;
    ROR .vduWorkspaceE                                  ;
    LSR                                                 ;
    BNE .getByteCoordinates                             ;

    ; Set screen address for .vduWorkspaceQRST (top right corner of sprite)
    LDX #.vduWorkspaceQ - .vduVariablesStart            ;
    JSR .setScreenAddress                               ;

    SEC                                                 ;
    LDA .vduWorkspaceB                                  ;
    SBC .vduWorkspaceK                                  ;
    TAX                                                 ; X=loop counter
    BEQ .skipAddingSpriteWidths                         ;

.addWidthToSpriteAddressLoop
    ; .vduWorkspaceCD += .vduWorkspaceA
    SEC                                                 ;
    LDA .vduWorkspaceC                                  ;
    ADC .vduWorkspaceA                                  ;
    STA .vduWorkspaceC                                  ;
    BCC +                                               ;
    INC .vduWorkspaceD                                  ;
+
    DEX                                                 ; loop counter
    BNE .addWidthToSpriteAddressLoop                    ;

.skipAddingSpriteWidths
    ; .vduWorkspaceCD += .vduWorkspaceA - .vduWorkspaceI
    SEC                                                 ;
    LDA .vduWorkspaceA                                  ;
    SBC .vduWorkspaceI                                  ;
    CLC                                                 ;
    ADC .vduWorkspaceC                                  ;
    STA .vduWorkspaceC                                  ;
    BCC +                                               ;
    INC .vduWorkspaceD                                  ;
+
    ; .vduWorkspaceG = .vduWorkspaceK - .vduWorkspaceG
    SEC                                                 ;
    LDA .vduWorkspaceK                                  ;
    SBC .vduWorkspaceG                                  ;
    STA .vduWorkspaceG                                  ;

    ; .vduWorkspaceG += 1
    INC .vduWorkspaceG                                  ;

    ; .vduWorkspaceE = .vduWorkspaceI - .vduWorkspaceE
    SEC                                                 ;
    LDA .vduWorkspaceI                                  ;
    SBC .vduWorkspaceE                                  ;
    STA .vduWorkspaceE                                  ;

    ; .vduWorkspaceE += 1
    INC .vduWorkspaceE                                  ;

.plotSpriteLoop
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    PHA                                                 ; }
    LDA .vduScreenAddressOfGraphicsCursorCellHigh       ; } remember screen address
    PHA                                                 ; } at the start of the row

    LDA .vduWorkspaceC                                  ; }
    STA .privateWorkspaceLow                            ; }
    LDA .vduWorkspaceD                                  ; } set row start of sprite data address
    STA .privateWorkspaceHigh                           ; }

    LDX .vduWorkspaceE                                  ; loop counter
.plotSpriteRowLoop
    LDY #0                                              ;
    LDA (.privateWorkspaceLow),Y                        ; read sprite byte
    PHA                                                 ;
    ORA .gcolModeMask2                                  ; }
    EOR .gcolModeMask3                                  ; }
    STA .vduGraphicsColourByteEOR                       ; } apply GCOL mode
    PLA                                                 ; }
    ORA .gcolModeMask0                                  ; }
    EOR .gcolModeMask1                                  ; }
    LDY .vduGraphicsCursorVerticalOffsetInCell          ; }

    ; write byte to screen
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    ORA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; }
    EOR .vduGraphicsColourByteEOR                       ; }
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; write byte to screen
} else if MACHINE = BBC_B_PLUS {
    STA .vduGraphicsColourByteOR                        ;
    JSR .plotByte                                       ; write byte to screen with GCOL mode
} else {
    +unknown_machine
}

    INC .privateWorkspaceLow                            ; }
    BNE +                                               ; } increment workspace pointer
    INC .privateWorkspaceHigh                           ; }
+                                                       ; }

    SEC                                                 ;
    JSR .moveGraphicsCursorAddressTotheLeftAndUpdateMask ;

    DEX                                                 ;
    BNE .plotSpriteRowLoop                              ; if (not done) then branch (loop back)

    PLA                                                 ; }
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ; } restore original screen address
    PLA                                                 ; }
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; }

    ; .vduWorkspaceCD += sprite width
    SEC                                                 ;
    LDA .vduWorkspaceC                                  ;
    ADC .vduWorkspaceA                                  ;
    STA .vduWorkspaceC                                  ;
    BCC +                                               ;
    INC .vduWorkspaceD                                  ;
+

    ; Increment offset within cell
    INC .vduGraphicsCursorVerticalOffsetInCell          ;
    LDY .vduGraphicsCursorVerticalOffsetInCell          ;
    CPY #8                                              ;
    BCC +                                               ; if (not the bottom of the cell) then branch

    JSR .plotSpriteMoveDownOneCell                      ; move down to next cell
    STY .vduGraphicsCursorVerticalOffsetInCell          ;
+

    ; Decrement number of rows left to plot
    DEC .vduWorkspaceG                                  ;
    BNE .plotSpriteLoop                                 ; if (not done yet) then branch (loop back)

    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 21: Sprite commands
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; *SGET n
;
; Executes 'VDU 23,27,1,n,0,0,0,0,0,0' to capture a rectangle of the screen to sprite n
;
; On Entry:
;   XY: address of the rest of the command line
;
; ***************************************************************************************
.starSGet
    JSR .read8BitNumberIntoA                            ;

    PHA                                                 ;
    JSR .printInlineCounted                             ; display following message
    !byte 3                                             ; length of message to print
    !text 23,27,1                                       ; get sprite from screen

    PLA                                                 ;
    JSR .OSWRCH                                         ; sprite to get

    JSR .printInlineCounted                             ; display following message
    !byte 6                                             ; length of message to print
    !text 0,0,0,0,0,0                                   ; finish VDU stream

    RTS                                                 ;

; ***************************************************************************************
.noSpriteMemoryErrorLocal
    JMP .noSpriteMemoryError                            ;

; ***************************************************************************************
.sgetRectOutOfBounds
    PLA                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.sgetInternal
    PHA                                                 ;
    LDY #.workspaceOffsetSpritePages                    ;
    LDA (.privateWorkspaceLow),Y                        ;
    BEQ .noSpriteMemoryErrorLocal                       ;

    ; Sort current graphics cursor and old graphics cursor points
    LDX #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart ;
    JSR .sortCoordinatesAsBottomLeftAndTopRight         ; set .vduWorkspaceAB,CD to bottom left point,
                                                        ; and .vduWorkspaceEF,GH to top right

    LDX #.vduWorkspaceA - .vduVariablesStart            ;
    JSR .checkPointXIsWithinGraphicsWindow              ;
    BEQ .sgetBottomLeftPointWithinBounds                ;

    AND #%00001010                                      ;
    BNE .sgetRectOutOfBounds                            ; if (bottom left point of rectangle
                                                        ; is right or above graphics window)
                                                        ; then branch (exit)

    LDA .vduTempStoreDA                                 ;
    PHA                                                 ;
    AND #1                                              ;
    BEQ +                                               ; if (bottom left point of rect is
                                                        ; not left of graphics window) then branch

    LDX #.vduGraphicsWindowPixelsLeftLow - .vduVariablesStart ; } copy left edge of graphics
    LDY #.vduWorkspaceA - .vduVariablesStart            ; } window into current workspace position
    JSR .copyTwoBytesWithinVDUVariables                 ; } i.e. clip to left edge

+
    PLA                                                 ;
    AND #4                                              ;
    BEQ .sgetBottomLeftPointWithinBounds                ; if (bottom left point is not
                                                        ; below the graphics window) then branch

    LDX #.vduGraphicsWindowPixelsBottomLow - .vduVariablesStart ; } copy bottom edge of graphics
    LDY #.vduWorkspaceC - .vduVariablesStart            ; } window into current workspace position
    JSR .copyTwoBytesWithinVDUVariables                 ; } i.e. clip to bottom edge

.sgetBottomLeftPointWithinBounds
    LDX #.vduWorkspaceE - .vduVariablesStart            ;
    JSR .checkPointXIsWithinGraphicsWindow              ;
    BEQ .sgetAllWithinBounds                            ; if (top right point is in bounds)

    AND #5                                              ;
    BNE .sgetRectOutOfBounds                            ; if (top right point of rectangle
                                                        ; is left or below graphics window)
                                                        ; then branch

    LDA .vduTempStoreDA                                 ;
    PHA                                                 ;
    AND #2                                              ;
    BEQ +                                               ; if (top right point of rect is not
                                                        ; right of the graphics window) then branch

    LDX #.vduGraphicsWindowPixelsRightLow - .vduVariablesStart ; } copy right edge of graphics
    LDY #.vduWorkspaceE - .vduVariablesStart            ; } window into current workspace position
    JSR .copyTwoBytesWithinVDUVariables                 ; } i.e. clip to right edge

+
    PLA                                                 ;
    AND #8                                              ;
    BEQ .sgetAllWithinBounds                            ; if (top right point of rect is not
                                                        ; above the graphics window) then branch

    LDX #.vduGraphicsWindowPixelsTopLow  - .vduVariablesStart ; } copy top edge of graphics
    LDY #.vduWorkspaceG - .vduVariablesStart            ; } window into current workspace position
    JSR .copyTwoBytesWithinVDUVariables                 ; } i.e. clip to top edge

.sgetAllWithinBounds
    LDX #.vduWorkspaceE - .vduVariablesStart            ;
    JSR .setScreenAddress                               ; set screen address based on top right
                                                        ; point of rectangle

    ; .vduWorkspaceAB = width of rect
    SEC                                                 ; }
    LDA .vduWorkspaceE                                  ; }
    SBC .vduWorkspaceA                                  ; }
    STA .vduWorkspaceA                                  ; } AB = EF - AB = width of rect
    LDA .vduWorkspaceF                                  ; }
    SBC .vduWorkspaceB                                  ; }
    STA .vduWorkspaceB                                  ; }

    ; Loop to convert AB into a byte width rather than width in pixels
    LDA .vduPixelsPerByteMinusOne                       ;
-
    LSR .vduWorkspaceB                                  ;
    ROR .vduWorkspaceA                                  ; .vduWorkspaceAB /= 2
    LSR                                                 ;
    BNE -                                               ;

    ; At this point .vduWorkspaceB is zero, because our sprite is less than 256 pixels wide.
    ; We reuse .vduWorkspaceB below.

    ; Calculate the width and height of the sprite we are going to create
    ;
    ; X=A+1         width of sprite
    ; B=G-C
    ; Y=G-C+1       height of sprite
    ; If Y=0 Y=255:B-=1
    LDX .vduWorkspaceA                                  ;
    INX                                                 ; X = .vduWorkspaceA + 1
    SEC                                                 ;
    LDA .vduWorkspaceG                                  ; }
    SBC .vduWorkspaceC                                  ; } B = G - C
    STA .vduWorkspaceB                                  ; }
    TAY                                                 ;
    INY                                                 ;
    BNE +                                               ;
    DEY                                                 ;
    DEC .vduWorkspaceB                                  ;
+
    ; Calculate width * height to see how much memory we need
    JSR .multiply8x8                                    ; DE/F = X*Y

    ; Store result in .vduWorkspaceCD
    CLC                                                 ; [NOTE: redundant, CLC not used]
    LDA .vduTempStoreDE                                 ;
    STA .vduWorkspaceC                                  ;
    LDA .vduTempStoreDF                                 ;
    STA .vduWorkspaceD                                  ;

    JSR .getFreeSpace                                   ;

    ; Now .vduTempStoreDE/DF holds the free space in bytes

    PLA                                                 ;
    PHA                                                 ;
    JSR .findSpriteA                                    ;
    BEQ .skipExistingSprite                             ;

    ; Add size of existing sprite to free space
    CLC                                                 ;
    LDY #.spriteHeaderOffsetSizeInBytesLow              ;
    LDA (.vduTempStoreDC),Y                             ;
    ADC .vduTempStoreDE                                 ;
    STA .vduTempStoreDE                                 ;
    INY                                                 ; Y = .spriteHeaderOffsetSizeInBytesHigh
    LDA (.vduTempStoreDC),Y                             ;
    ADC .vduTempStoreDF                                 ;
    STA .vduTempStoreDF                                 ;

    ; Add 6 to free space (for the old sprite header data)
    LDA #6                                              ; }
    ADC .vduTempStoreDE                                 ; }
    STA .vduTempStoreDE                                 ; } [NOTE: don't add six only to subtract it again, just skip forward, i.e.: JMP +]
    BCC .skipExistingSprite                             ; }
    INC .vduTempStoreDF                                 ; }

.skipExistingSprite
    ; Subtract 6 from the free space (for the new sprite header data)
    SEC                                                 ;
    LDA .vduTempStoreDE                                 ;
    SBC #6                                              ;
    BCS +                                               ;
    DEC .vduTempStoreDF                                 ;
+

    ; Check we have enough room for the new sprite
    ; if (free space >= size of new sprite)
    CMP .vduWorkspaceC                                  ;
    LDA .vduTempStoreDF                                 ;
    SBC .vduWorkspaceD                                  ;
    BMI .noRoomToGetSpriteError                         ;

    ; Delete the existing sprite
    PLA                                                 ;
    PHA                                                 ;
    JSR .deleteSpriteInternal                           ;

    ; tempStoreDC/D = DA/B = start of sprite data
    ; DA/B += 6 for the sprite header data
    CLC                                                 ;
    LDA .vduTempStoreDA                                 ;
    STA .vduTempStoreDC                                 ;
    ADC #6                                              ;
    STA .vduTempStoreDA                                 ;
    LDA .vduTempStoreDB                                 ;
    STA .vduTempStoreDD                                 ;
    BCC +                                               ;
    INC .vduTempStoreDB                                 ;
+

    ; Store sprite number
    LDY #.spriteHeaderOffsetSpriteNumber                ;
    PLA                                                 ;
    PHA                                                 ;
    STA (.vduTempStoreDC),Y                             ;

    ; Store current mode
    DEY                                                 ; Y=.spriteHeaderOffsetModeNumber
    LDA .vduCurrentScreenMODE                           ;
    STA (.vduTempStoreDC),Y                             ;

    ; Store width and height (4 bytes)
    DEY                                                 ;
.sgetStoreWidthAndHeight
    LDA .vduWorkspaceA,Y                                ;
    STA (.vduTempStoreDC),Y                             ;
    DEY                                                 ;
    BPL .sgetStoreWidthAndHeight                        ;

    INC .vduWorkspaceA                                  ; width
    INC .vduWorkspaceB                                  ; height (loop counter)

    ; Loop over each row
.sgetLoopOverRows
    LDX .vduWorkspaceA                                  ; width

    ; Remember current screen address
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ;
    PHA                                                 ;
    LDA .vduScreenAddressOfGraphicsCursorCellHigh       ;
    PHA                                                 ;

.sgetLoopOverBytesInRow
    LDY .vduGraphicsCursorVerticalOffsetInCell          ;

    ; A=byte from screen
!if (MACHINE = BBC_B) | (MACHINE = ELECTRON) {
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; read direct from screen memory
} else if MACHINE = BBC_B_PLUS {
    LDA .vduTempStoreDA                                 ; stash value at $DA which subroutine call will corrupt
    PHA                                                 ; store on stack
    JSR .checkPixelIsBackgroundColourFast               ; read byte from screen
    EOR .vduBackgroundGraphicsColour                    ; undo the unwanted eor from subroutine call

    TAY                                                 ; }
    PLA                                                 ; } restore $DA, preserving A
    STA .vduTempStoreDA                                 ; }
    TYA                                                 ; }
} else {
    +unknown_machine
}

    LDY #0                                              ;
    STA (.vduTempStoreDA),Y                             ; store byte

    ; Move sprite address on one byte
    INC .vduTempStoreDA                                 ;
    BNE +                                               ;
    INC .vduTempStoreDB                                 ;
+

    ; Call OS routine to move graphics cursor left
    SEC                                                 ;
    JSR .moveGraphicsCursorAddressTotheLeftAndUpdateMask ;

    DEX                                                 ; byte width-=1
    BNE .sgetLoopOverBytesInRow                         ;

    ; Restore the screen address
    PLA                                                 ;
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ;
    PLA                                                 ;
    STA .vduScreenAddressOfGraphicsCursorCellLow        ;

    ; Move graphics cursor down one row
    INC .vduGraphicsCursorVerticalOffsetInCell          ;
    LDY .vduGraphicsCursorVerticalOffsetInCell          ;
    CPY #8                                              ;
    BCC +                                               ;
    JSR .plotSpriteMoveDownOneCell                      ;
    STY .vduGraphicsCursorVerticalOffsetInCell          ;
+
    DEC .vduWorkspaceB                                  ; reduce loop counter
    BNE .sgetLoopOverRows                               ;

    JSR .addSprite                                      ; add the sprite

    PLA                                                 ;
    JMP .starSChooseInternal                            ; choose the new sprite

; ***************************************************************************************
.noRoomToGetSpriteError
    JSR .generateError                                  ;
    !byte $82                                           ; error number
    !text "No room to get sprite",0                     ; error message

; ***************************************************************************************
.noSpritesError
    JSR .generateError                                  ;
    !byte $83                                           ; error number
    !text "No Sprites",0                                ; error message

; ***************************************************************************************
;
; *SSAVE
;
; On Entry:
;   XY is the rest of the command line
;
; ***************************************************************************************
.starSSave
    JSR .prepareFilingSystem                            ;

    ; Store address of filename
    TYA                                                 ;
    LDY #.workspaceOffsetFilenameHigh                   ;
    STA (.privateWorkspaceLow),Y                        ;
    TXA                                                 ;
    DEY                                                 ; Y = .workspaceOffsetFilenameLow
    STA (.privateWorkspaceLow),Y                        ;

    ; Check we have at least one sprite
    LDY #.workspaceOffsetNumberOfSprites                ;
    LDA (.privateWorkspaceLow),Y                        ;
    BEQ .noSpritesError                                 ; if (no sprites) then branch (error)

    JSR .getFreeSpace                                   ; .vduTempStoreDE/DF = free space in bytes

    ; vduTempStoreDA/B = start of sprite memory
    LDY #.workspaceOffsetSpriteStartPage                ;
    LDA (.privateWorkspaceLow),Y                        ;
    STA .vduTempStoreDB                                 ;
    LDA #0                                              ;
    STA .vduTempStoreDA                                 ;

    ; Store number of sprites
    LDY #.workspaceOffsetNumberOfSprites                ; }
    LDA (.privateWorkspaceLow),Y                        ; } get number of sprites
    LDY #2                                              ;
    STA (.vduTempStoreDA),Y                             ; store number of sprites

    ; Store length of sprite data
    LDY #0                                              ;
    SEC                                                 ;
    LDA .vduTempStoreDC                                 ;
    STA (.vduTempStoreDA),Y                             ;
    INY                                                 ;
    LDA .vduTempStoreDD                                 ;
    SBC .vduTempStoreDB                                 ; subtract start of sprite memory
    STA (.vduTempStoreDA),Y                             ;

    ; Store $FF in the two high bytes of start address and all of the end address.
    ; i.e. six bytes from .workspaceOffsetStartAddressMid2
    LDY #.workspaceOffsetStartAddressMid2 + 5           ; offset from sart of private workspace
    LDX #6                                              ;
    LDA #$FF                                            ;
-
    STA (.privateWorkspaceLow),Y                        ;
    DEY                                                 ;
    DEX                                                 ;
    BNE -                                               ;

    ; Store start address (lower two bytes)
    LDY #.workspaceOffsetStartAddressLow                ;
    LDA #0                                              ; low byte zero
    STA (.privateWorkspaceLow),Y                        ;
    INY                                                 ;
    LDA .vduTempStoreDB                                 ; high byte of start of workspace memory
    STA (.privateWorkspaceLow),Y                        ;

    ; Store end address (2 bytes more than start)
    LDY #.workspaceOffsetEndAddressMid1                 ;
    STA (.privateWorkspaceLow),Y                        ; high byte of start of workspace memory
    DEY                                                 ;
    LDA #2                                              ; low byte of start of workspace memory (two).
    STA (.privateWorkspaceLow),Y                        ;

    LDX #.workspaceOffsetParamBlock                     ; }
    LDY .privateWorkspaceHigh                           ; }
    LDA #0                                              ; } Save two byte file?
    JSR .OSFILE                                         ; }


    JSR .getPrivateWorkspaceAddress                     ; .privateWorkspaceLow/High = private workspace address
    JSR .getFreeSpace                                   ; .vduTempStoreDE/DF = free space in bytes

    ; vduTempStoreDA/B = start of sprite memory
    LDY #.workspaceOffsetSpriteStartPage                ;
    LDA (.privateWorkspaceLow),Y                        ;
    STA .vduTempStoreDB                                 ;
    LDA #0                                              ;
    STA .vduTempStoreDA                                 ;

    ; Store $FF in two high bytes of start address and all of end address.
    ; i.e. six bytes from .workspaceOffsetStartAddressMid2
    LDY #.workspaceOffsetStartAddressMid2+5             ; [NOTE: duplicate of above, could be a function instead to save bytes]
    LDX #6                                              ;
    LDA #$FF                                            ;
-
    STA (.privateWorkspaceLow),Y                        ;
    DEY                                                 ;
    DEX                                                 ;
    BNE -                                               ;

    ; Store start address (start of sprite memory)
    LDY #.workspaceOffsetStartAddressLow                ;
    LDA .vduTempStoreDA                                 ;
    STA (.privateWorkspaceLow),Y                        ;
    INY                                                 ; Y=$5E
    LDA .vduTempStoreDB                                 ;
    LDY #.workspaceOffsetStartAddressMid1               ; [NOTE: Redundant: Y is already set to $5E]
    STA (.privateWorkspaceLow),Y                        ;

    ; Store end address
    LDY #.workspaceOffsetEndAddressLow                  ;
    LDA .vduTempStoreDC                                 ;
    STA (.privateWorkspaceLow),Y                        ;
    INY                                                 ; Y = .workspaceOffsetEndAddressMid1
    LDA .vduTempStoreDD                                 ;
    STA (.privateWorkspaceLow),Y                        ;

    LDX #.workspaceOffsetParamBlock                     ; }
    LDY .privateWorkspaceHigh                           ; }
    LDA #0                                              ; } Save file proper
    JMP .OSFILE                                         ; }

; ***************************************************************************************
;
; *SLOAD
;
; On Entry:
;   XY is the rest of the command line
;
; ***************************************************************************************
.starSLoad
    JSR .prepareFilingSystem                            ;

    STX .vduTempStoreDA                                 ; store filename address
    STY .vduTempStoreDB                                 ;

    ; vduTempStoreDC/D = start of sprite data
    LDY #.workspaceOffsetSpriteStartPage                ;
    LDA (.privateWorkspaceLow),Y                        ;
    STA .vduTempStoreDD                                 ;
    LDA #0                                              ;
    STA .vduTempStoreDC                                 ;

    JSR .readSpriteFile                                 ;
    BCS +                                               ; if (failed to load) then branch

    LDY #.workspaceOffsetNumberOfSprites                ; }
    STA (.privateWorkspaceLow),Y                        ; } store number of sprites
    JMP .resetCurrentSpriteAddress                      ;

+
    RTS                                                 ;

; ***************************************************************************************
;
; *SMERGE
;
; On Entry:
;   XY is the rest of the command line
;
; ***************************************************************************************
.starSMerge
    JSR .prepareFilingSystem                            ;

    STX .vduTempStoreDA                                 ;
    STY .vduTempStoreDB                                 ; store filename address

    JSR .getFreeSpace                                   ;

    JSR .readSpriteFile                                 ;
    BCS .return15                                       ; if (error reading file) then branch

    TAX                                                 ; X = number of sprites

    ; vduTempStoreDC/D += 3 (add 3 to sprite address)
    CLC                                                 ;
    LDA .vduTempStoreDC                                 ;
    ADC #3                                              ;
    STA .vduTempStoreDC                                 ;
    BCC .addSpriteLoop                                  ;
    INC .vduTempStoreDD                                 ;

    ; Add each sprite
.addSpriteLoop
    TXA                                                 ;
    PHA                                                 ;
    JSR .addSprite                                      ;

    PLA                                                 ;
    TAX                                                 ;
    DEX                                                 ;
    BNE .addSpriteLoop                                  ;

.return15
    RTS                                                 ;

; ***************************************************************************************
.cantOpenFileError
    JSR .generateError                                  ;
    !byte $85                                           ; error number [NOTE: should be $84]
    !text "Can't open file",0                           ; error message

; ***************************************************************************************
;
; Reads a sprite file
;
; On Entry:
;   .vduTempStoreDA/DB - filename address
;   .vduTempStoreDC/DD - load address
;
; On Exit:
;   Carry: clear on success
;   A: number of sprites after reading the file
;   vduTempStoreDC/D: end of sprites address
;
; ***************************************************************************************
.readSpriteFile
    ; Store filename address to parameter block in private workspace
    LDY #.workspaceOffsetFilenameLow                    ; }
    LDA .vduTempStoreDA                                 ; }
    STA (.privateWorkspaceLow),Y                        ; } set filename address
    INY                                                 ; } i.e.
    LDA .vduTempStoreDB                                 ; } workspace[.workspaceOffsetFilenameLow]  = .vduTempStoreDA = filename address low
    STA (.privateWorkspaceLow),Y                        ; } workspace[.workspaceOffsetFilenameHigh] = .vduTempStoreDB = filename address high

    ; Store load address to parameter block in private workspace
    INY                                                 ; } Y=#.workspaceOffsetLoadAddressLow
    LDA .vduTempStoreDC                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }
    INY                                                 ; }
    LDA .vduTempStoreDD                                 ; } set load address
    STA (.privateWorkspaceLow),Y                        ; }
    INY                                                 ; } i.e.
    LDA #$FF                                            ; } workspace[load address low] = .vduTempStoreDC (load address low)
    STA (.privateWorkspaceLow),Y                        ; } workspace[load address mid1] = .vduTempStoreDD (load address high)
    INY                                                 ; } workspace[load address mid2] = $FF
    STA (.privateWorkspaceLow),Y                        ; } workspace[load address high] = $FF

    ; We zero this next byte, meaning 'load the file at the load address given'
    INY                                                 ; } Y=#.workspaceOffsetExecAddressLow
    LDA #0                                              ; }
    STA (.privateWorkspaceLow),Y                        ; } workspace[.workspaceOffsetExecAddressLow] = 0

    ; Store load address
    LDY #.workspaceOffsetEndOfSpritesAddressLow         ;
    LDA .vduTempStoreDC                                 ;
    STA (.privateWorkspaceLow),Y                        ; workspace[end of sprites low] = tempStoreDC
    INY                                                 ;
    LDA .vduTempStoreDD                                 ;
    STA (.privateWorkspaceLow),Y                        ; workspace[end of sprite high] = tempStoreDD

    ; Open file for reading
    LDX .vduTempStoreDA                                 ; }
    LDY .vduTempStoreDB                                 ; } Pointer to filename
    LDA #$40                                            ;
    JSR .OSFIND                                         ; open file for reading

    CMP #0                                              ;
    BEQ .cantOpenFileError                              ; if (open file fails) then branch

    ; Read two bytes (the size) onto the stack
    TAY                                                 ; Y = file handle
    JSR .OSBGET                                         ; get first byte
    PHA                                                 ; push first byte of file
    JSR .OSBGET                                         ; get second byte
    PHA                                                 ; push second byte

    ; Close file
    LDA #0                                              ;
    JSR .OSFIND                                         ; close file

    JSR .getPrivateWorkspaceAddress                     ;

    ; Recall first two bytes from stack (size)
    PLA                                                 ; }
    STA .vduTempStoreDD                                 ; } .vduTempStoreDC/DD = first two bytes from file (size)
    PLA                                                 ; }
    STA .vduTempStoreDC                                 ; }

    ; Add size to current end of sprites address
    CLC                                                 ; }
    LDY #.workspaceOffsetEndOfSpritesAddressLow         ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    ADC .vduTempStoreDC                                 ; }
    STA .vduTempStoreDC                                 ; } .vduTempStoreDC/DD += workspace[$65/$66]
    INY                                                 ; } Y = .workspaceOffsetEndOfSpritesAddressHigh
    LDA (.privateWorkspaceLow),Y                        ; }
    ADC .vduTempStoreDD                                 ; }
    STA .vduTempStoreDD                                 ; }

    ; Check for enough room
    LDY #.workspaceOffsetSpriteEndPage                  ;
    LDA #0                                              ;
    CMP .vduTempStoreDC                                 ;
    LDA (.privateWorkspaceLow),Y                        ; workspace[.workspaceOffsetSpriteEndPage] - .vduTempStoreDC/DD
    SBC .vduTempStoreDD                                 ;
    BCC .notEnoughRoomError                             ; if (workspace[.workspaceOffsetSpriteEndPage] < .vduTempStoreDC/DD) then branch

    ; Load file
    LDX #.workspaceOffsetParamBlock                     ; }
    LDY .privateWorkspaceHigh                           ; } address of parameter block
    LDA #$FF                                            ; load named file
    JSR .OSFILE                                         ;

    JSR .getPrivateWorkspaceAddress                     ;

    ; vduTempStoreDC/D = end of sprites address
    LDY #.workspaceOffsetEndOfSpritesAddressLow         ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vduTempStoreDC                                 ; }
    INY                                                 ; }
    LDA (.privateWorkspaceLow),Y                        ; } .vduTempStoreDC/DD = workspace[.workspaceOffsetEndOfSpritesAddressLow/High]
    STA .vduTempStoreDD                                 ; }

    ; Get number of sprites
    LDY #2                                              ; }
    LDA (.vduTempStoreDC),Y                             ; } get number of sprites
    CLC                                                 ; }
    RTS                                                 ;

; ***************************************************************************************
.notEnoughRoomError
    JSR .generateError                                  ;
    !byte $85                                           ; error number
    !text "Not enough room",0                           ; error message

; ***************************************************************************************
;
; Prepare the filing system by setting short messages on a cassette / ROM based filing system
; and get the workspace address
;
; ***************************************************************************************
.prepareFilingSystem
    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } store X,Y
    PHA                                                 ; }

    LDA #0                                              ; }
    TAY                                                 ; } OSARGS 0,168,0
    LDX #$A8                                            ; }
    JSR .OSARGS                                         ; } return filing system number in A

    AND #$FC                                            ;
    BNE .restoreXY                                      ; if (not cassette or ROM filing system) then branch

    LDA #$8B                                            ; }
    LDX #1                                              ; } *FX 139,1,1
    LDY #1                                              ; } Equivalent to *OPT 1,1
    JSR .OSBYTE                                         ; } (give short messages)

.restoreXY
    PLA                                                 ;
    TAY                                                 ;
    PLA                                                 ;
    TAX                                                 ;
    JMP .getPrivateWorkspaceAddress                     ;

; ***************************************************************************************
;
; *SCHOOSE n
;
; On Entry:
;   XY is the rest of the command line
;
; ***************************************************************************************
.starSChoose
    JSR .read8BitNumberIntoA                            ;
.sChooseA
    JSR .starSChooseInternal                            ;
    BEQ .spriteDoesntExistError                         ;
    RTS                                                 ;

; ***************************************************************************************
.spriteDoesntExistError
    JSR .generateError                                  ;
    !byte $86                                           ; error number
    !text "Sprite doesn't exist",0                      ; error message

; ***************************************************************************************
.starSChooseInternal
    PHA                                                 ;
    LDY #.workspaceOffsetSpritePages                    ;
    LDA (.privateWorkspaceLow),Y                        ;
    BEQ .schooseError                                   ; if no sprite space, then branch (error)
    PLA                                                 ;
    JSR .findSpriteA                                    ;
    BEQ .dontStoreSpriteAddress                         ; if sprite not found, then skip storing the address

    ; Record the sprite address
    LDY #.workspaceOffsetCurrentSpriteAddressLow        ;
    STA (.privateWorkspaceLow),Y                        ;
    INY                                                 ;
    LDA .vduTempStoreDD                                 ;
    STA (.privateWorkspaceLow),Y                        ;

    CPX #0                                              ;
    RTS                                                 ;

.dontStoreSpriteAddress
    LDY #.workspaceOffsetCurrentSpriteAddressLow        ; }
    TXA                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; } zero the current sprite address
    INY                                                 ; }
    STA (.privateWorkspaceLow),Y                        ; }
    CPX #0                                              ;
    RTS                                                 ;

.schooseError
    JMP .noSpriteMemoryError                            ;

; ***************************************************************************************
;
; *SRENUMBER n,m
;
; On Entry:
;   XY is the rest of the command line
;
; ***************************************************************************************
.starSRenumber
    JSR .read8BitNumberIntoA                            ; read first number n

    PHA                                                 ; push n
    JSR .skipLeadingSpaces                              ;

    STX .vduTempStoreDE                                 ; } remember address of remainder of command
    STY .vduTempStoreDF                                 ; }

    PLA                                                 ; pull n
    PHA                                                 ; push n
    JSR .findSpriteA                                    ; get sprite n address
    BEQ .spriteNotFound                                 ; if not found then branch

    ; Skip comma
    LDY #0                                              ;
    LDA (.vduTempStoreDE),Y                             ;
    CMP #','                                            ;
    BNE .missingCommaError                              ;

    ; Move on to next character
    LDX .vduTempStoreDE                                 ;
    LDY .vduTempStoreDF                                 ;
    INX                                                 ;
    BNE +                                               ;
    INY                                                 ;
+

    JSR .read8BitNumberIntoA                            ; read second number m

    PLA                                                 ; pull n
    PHA                                                 ; push n
    CMP .vduTempStoreDE                                 ;
    BEQ .spriteNumbersAreEqualError                     ; if (n == m) then branch

    LDA .vduTempStoreDE                                 ; get m
    PHA                                                 ; push m
    JSR .deleteSpriteInternal                           ;

    PLA                                                 ; get m
    STA .vduTempStoreDE                                 ; store m
    PLA                                                 ; pull n
    JSR .findSpriteA                                    ; get sprite address for sprite n

    LDY #.spriteHeaderOffsetSpriteNumber                ;
    LDA .vduTempStoreDE                                 ; get sprite number m
    STA (.vduTempStoreDC),Y                             ; store sprite number m
    RTS                                                 ;

.spriteNotFound
    JMP .spriteDoesntExistError                         ;

; ***************************************************************************************
.missingCommaError
    JSR .generateError                                  ;
    !byte $87                                           ; error number
    !text "Missing comma",0                             ; error message

; ***************************************************************************************
.spriteNumbersAreEqualError
    JSR .generateError                                  ;
    !byte $88                                           ; error number
    !text "Sprite numbers are equal",0                  ; error message

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 22: Sprite Editor
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Sprite Editor
;
; see editor.png
;
; ***************************************************************************************

; ***************************************************************************************
.drawRectangleAroundSpriteInBlack
    LDY #0                                              ;
    BEQ .drawRectangleAroundSprite                      ; ALWAYS branch

.drawRectangleAroundSpriteInWhite
    LDY #7                                              ;
    ; fall through...

; ***************************************************************************************
;
; Draw rectangle around large sprite in the sprite editor
;
; On Entry:
;   Y = logical colour to draw in
;   .seditCurrentSpriteVisibleWidth:  visible width of current sprite
;   .seditCurrentSpriteVisibleHeight: visible height of current sprite
;
; ***************************************************************************************
.drawRectangleAroundSprite
    LDX #0                                              ;
    JSR .gcolXY                                         ; GCOL 0,Y where Y=0 (black) or 7 (white)

    JSR .seditGetScreenCoordinatesForCurrentSprite      ;

    JSR .printInlineCounted                             ; display following message
    !byte 8                                             ; length of message to print
    !text 25,4                                          ; PLOT 4 (MOVE)
    !word 15,7                                          ; PLOT 4,15,7
    !byte 25,5                                          ; PLOT 5,

    JSR .seditOutputXCoordinate                         ;        X,
    JSR .printInlineCounted                             ; display following message
    !byte 4                                             ; length of message to print
    !word 7                                             ;          7
    !byte 25,5                                          ; PLOT 5,

    JSR .seditOutputXCoordinate                         ;        X,
    JSR .seditOutputYCoordinate                         ;          Y
    JSR .printInlineCounted                             ; display following message
    !byte 4                                             ; length of message to print
    !text 25,5                                          ; }
    !word 15                                            ; } PLOT 5,15,

    JSR .seditOutputYCoordinate                         ;             Y
    JSR .printInlineCounted                             ; display following message
    !byte 6                                             ; length of message to print
    !text 25,5                                          ;
    !word 15,7                                          ; PLOT 5,15,7

    RTS                                                 ;

; ***************************************************************************************
;
; Get screen coordinates for the visible area of the current sprite
;
; Calculates the screen coordinates of the large sprite rectangular area in the editor.
;
; On Entry:
;   .seditCurrentSpriteVisibleWidth:  visible width of current sprite
;   .seditCurrentSpriteVisibleHeight: visible height of current sprite
;
; On Exit:
;   .plotPointXLow/High: X screen coordinate
;   .plotPointYLow/High: Y screen coordinate
;   (Preserves current sprite position)
;
; ***************************************************************************************
.seditGetScreenCoordinatesForCurrentSprite
    LDA .seditCurrentVisibleY                           ; }
    PHA                                                 ; } Remember current position in sprite
    LDA .seditCurrentVisibleX                           ; }
    PHA                                                 ; }

    LDA .seditCurrentSpriteVisibleHeight                ; }
    STA .seditCurrentVisibleY                           ; } currentY = sprite visible height+1
    LDA .seditCurrentSpriteVisibleWidth                 ; }
    STA .seditCurrentVisibleX                           ; } currentX = sprite visible width+1
    INC .seditCurrentVisibleX                           ; }
    INC .seditCurrentVisibleY                           ; }
    JSR .seditGetScreenCoordinates                      ;

    PLA                                                 ; }
    STA .seditCurrentVisibleX                           ; } Recall current position in sprite
    PLA                                                 ; }
    STA .seditCurrentVisibleY                           ; }
    RTS                                                 ;

; ***************************************************************************************
.seditDrawLargeSpriteRow
    ; Set GCOL 0 mode
    LDA #0                                              ;
    STA .vduForegroundGCOLMode                          ;

    ; Column zero
    STA .seditCurrentVisibleX                           ;

    ; Get screen coordinates
    JSR .seditGetScreenCoordinates                      ;

    JSR .calculateCurrentSpriteByte                     ;

    ; Column zero
    LDA #0                                              ;
    STA .seditCurrentVisibleX                           ;
.seditLoopBytesInRow
    LDA .vduColourMaskLeft                              ;
    STA .seditCurrentVisibleByteMask                    ; store current byte mask
    LDY #0                                              ;
    LDA (.seditCurrentSpriteByteLow),Y                  ; load byte from sprite
    STA .vduWorkspaceI                                  ; store current sprite byte

.seditLoopPixelsInByte
    LDA .vduWorkspaceI                                  ;
    AND .vduColourMaskLeft                              ;
    STA .vduForegroundGraphicsColour                    ;

    ; Create byte of solid foreground colour
    LDX .vduPixelsPerByteMinusOne                       ;
-
    LSR .vduForegroundGraphicsColour                    ;
    ORA .vduForegroundGraphicsColour                    ;
    DEX                                                 ;
    BNE -                                               ;

    STA .vduForegroundGraphicsColour                    ;

    ; Plot rectangle for the pixel
    LDX #4                                              ;
    JSR .plotX                                          ; PLOT 4 (MOVE)
    JSR .seditOutputXCoordinate                         ; X
    JSR .seditFinishMoveAndDrawLargePixelRectangle      ; draw rectangle around

    ; Increment X coordinate, based on current mode
    SEC                                                 ;
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditXCoordinateIncrement,X                    ;
    ADC .plotPointXLow                                  ;
    STA .plotPointXLow                                  ;
    BCC +                                               ;
    INC .plotPointXHigh                                 ;
+

    ; Shift to move to next pixel and update byte mask
    ASL .vduWorkspaceI                                  ; shift byte to next pixel
    LSR .seditCurrentVisibleByteMask                    ; move mask to next pixel within byte
    BCC .seditLoopPixelsInByte                          ;

    ; Move to next sprite byte (decrement sprite byte address)
    LDA .seditCurrentSpriteByteLow                      ;
    BNE +                                               ;
    DEC .seditCurrentSpriteByteHigh                     ;
+
    DEC .seditCurrentSpriteByteLow                      ;

    ; Move to next column
    INC .seditCurrentVisibleX                           ;

    ; Check if done all of row
    LDA .seditCurrentSpriteVisibleWidth                 ;
    CMP .seditCurrentVisibleX                           ;
    BCS .seditLoopBytesInRow                            ;

    RTS                                                 ;

; ***************************************************************************************
.seditDrawLargeSpriteColumn
    ; Set GCOL 0 mode
    LDA #0                                              ;
    STA .vduForegroundGCOLMode                          ;

    ; Row zero
    STA .seditCurrentVisibleY                           ;

    ; Get screen coordinates
    JSR .seditGetScreenCoordinates                      ;

    JSR .calculateCurrentSpriteByte                     ;

.seditLoopRows
    JSR .getColourByteFromPixelOfSprite                 ;

    STA .vduForegroundGraphicsColour                    ;
    JSR .seditDrawLargePixelRectangle                   ;

    ; Add increment to Y coordinate
    SEC                                                 ;
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditYCoordinateIncrement,X                    ;
    ADC .plotPointYLow                                  ;
    STA .plotPointYLow                                  ;
    BCC +                                               ;
    INC .plotPointYHigh                                 ;
+

    ; Current sprite byte -= width in bytes
    LDY #0                                              ;
    CLC                                                 ;
    LDA .seditCurrentSpriteByteLow                      ;
    SBC (.currentSpriteDefinitionLow),Y                 ;
    STA .seditCurrentSpriteByteLow                      ;
    BCS +                                               ;
    DEC .seditCurrentSpriteByteHigh                     ;
+

    ; Increment visible Y
    INC .seditCurrentVisibleY                           ;
    LDA .seditCurrentSpriteVisibleHeight                ;
    CMP .seditCurrentVisibleY                           ; compare current visible Y with visible height
    BCS .seditLoopRows                                  ; if (not done yet) the branch (loop back)

    RTS                                                 ;

; ***************************************************************************************
.seditDrawLargeSprite
    ; Remember values VUW on stack
    LDA .seditCurrentVisibleY                           ;
    PHA                                                 ;
    LDA .seditCurrentVisibleX                           ;
    PHA                                                 ;
    LDA .seditCurrentVisibleByteMask                    ;
    PHA                                                 ;

    ; Loop through all visible rows of sprite, drawing each row
    LDA #0                                              ;
    STA .seditCurrentVisibleY                           ;
.loopThroughRowsOfSprite
    JSR .seditDrawLargeSpriteRow                        ;

    INC .seditCurrentVisibleY                           ;
    LDA .seditCurrentSpriteVisibleHeight                ;
    CMP .seditCurrentVisibleY                           ;
    BCS .loopThroughRowsOfSprite                        ;

    ; Restore values VUW from stack
    PLA                                                 ;
    STA .seditCurrentVisibleByteMask                    ;
    PLA                                                 ;
    STA .seditCurrentVisibleX                           ;
    PLA                                                 ;
    STA .seditCurrentVisibleY                           ;
    RTS                                                 ;

; ***************************************************************************************
;
; Unplot the cursor, redraw regular and large sprites, then redraw the cursor
;
; ***************************************************************************************
.seditDrawLargeAndRegularSpriteAndUpdateCursor
    JSR .drawCircleCursor                               ; undraw cursor

.seditDrawLargeAndRegularSpriteAndCursor
    JSR .seditPlotRegularSizeSprite                     ;

.seditDrawLargeSpriteAndCursor
    JSR .seditDrawLargeSprite                           ;
    ; fall through...

; ***************************************************************************************
;
; Draw (or undraw) the circular cursor in the sprite editor
;
; ***************************************************************************************
.drawCircleCursor
    LDX #4                                              ;
    JSR .plotX                                          ; PLOT 4 (MOVE)
    JSR .seditGetScreenCoordinates                      ;

    ; Get X coordinate of centre of circle to draw
    LDX .vduCurrentScreenMODE                           ; }
    LDA .seditXCoordinateIncrement,X                    ; } get size of the square for displaying the current pixel
    LSR                                                 ; } halve it to get the centre point

    ; AY += screen X coordinate offset within the current sprite byte
    CLC                                                 ; }
    ADC .seditScreenXOffsetWithinCurrentByte            ; }
    LDY .plotPointXHigh                                 ;
    BCC +                                               ; increment the high byte if needed
    INY                                                 ;
+

    ; AY += plotPointXLow
    CLC                                                 ;
    ADC .plotPointXLow                                  ;
    BCC +                                               ;
    INY                                                 ;
+

    ; Send X coordinate (low byte) for MOVE
    JSR .OSWRCH                                         ;

    ; Send X coordinate (high byte) for MOVE
    TYA                                                 ;
    JSR .OSWRCH                                         ;

    ; Get Y coordinate of centre of circle to draw
    LDA .seditYCoordinateIncrement,X                    ; } get size of the square for displaying the current pixel
    LSR                                                 ; } halve it to get the centre point
    CLC                                                 ;
    ADC .plotPointYLow                                  ;
    LDY .plotPointYHigh                                 ;
    BCC +                                               ;
    INY                                                 ;
+

    ; Send Y coordinate (low and high) for MOVE
    JSR .OSWRCH                                         ;
    TYA                                                 ;
    JSR .OSWRCH                                         ;

    ; Draw circle
    JSR .printInlineCounted                             ; display following message
    !byte 9                                             ; length of message to print
    !byte 18,3,7                                        ; GCOL 3,7 (EOR, white)
    !text 25,145                                        ; }
    !word 0, 7                                          ; } PLOT 145,0,7 (Circle outline)

    JMP .calculateCurrentSpriteByte                     ;

; ***************************************************************************************
.seditDrawLargePixelRectangle
    LDX #4                                              ;
    JSR .plotX                                          ; PLOT 4,

    LDA .plotPointXLow                                  ; }
    CLC                                                 ; }
    ADC .seditScreenXOffsetWithinCurrentByte            ; } X is the low byte of the X coordinate
    TAX                                                 ; }

    LDA .plotPointXHigh                                 ; }
    ADC #0                                              ; } Y is the high byte of the X coordinate
    TAY                                                 ; }

    TXA                                                 ; }
    JSR .OSWRCH                                         ; }
    TYA                                                 ; } output X coordinate
    JSR .OSWRCH                                         ; }
    ; fall through...

; ***************************************************************************************
.seditFinishMoveAndDrawLargePixelRectangle
    JSR .seditOutputYCoordinate                         ;

    LDX #$61                                            ;
    JSR .plotX                                          ; PLOT $61 (Rectangle, relative)

    LDX .vduCurrentScreenMODE                           ; }
    LDA .seditXCoordinateIncrement,X                    ; }
    JSR .OSWRCH                                         ; } one X increment amount for the width
    LDA #0                                              ; }
    JSR .OSWRCH                                         ; }

    LDA .seditYCoordinateIncrement,X                    ; }
    JSR .OSWRCH                                         ; }
    LDA #0                                              ; } one Y increment amount for the height
    JMP .OSWRCH                                         ; }

; ***************************************************************************************
;
; Calculate address within sprite given (X, Y) pixel coordinates
;
; On Entry:
;   .seditCurrentVisibleX: X pixel within visible area of sprite in editor
;   .seditCurrentVisibleY: Y pixel within visible area of sprite in editor
;   .seditCurrentX: pixel coordinate of the left edge of visible area of sprite in editor
;   .seditCurrentY: pixel coordinate of the bottom edge of visible area of sprite in editor
;
; On Exit:
;   .seditCurrentSpriteByteLow/High: address of current sprite byte
;
; ***************************************************************************************
.calculateCurrentSpriteByte
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    TAX                                                 ;
    INX                                                 ; X = width

    ; Y value
    CLC                                                 ;
    LDA .seditCurrentVisibleY                           ;
    ADC .seditCurrentY                                  ;
    TAY                                                 ; Y is cursor Y position

    ; We calculate the offset from the *end* of the sprite data backwards to the current byte in the sprite

    JSR .multiply8x8                                    ; result = X * Y
                                                        ;        = width * Y
                                                        ;        = offset from end of sprite backwards to current row of sprite

    ; result += X offset within the visible region
    CLC                                                 ;
    LDA .vduTempStoreDE                                 ;
    ADC .seditCurrentVisibleX                           ; add the offset within the visible region
    LDX .vduTempStoreDF                                 ;
    BCC +                                               ;
    INX                                                 ;
+

    ; result += current sprite pixel X within visible area
    CLC                                                 ;
    ADC .seditCurrentX                                  ; left pixel coordinate of large sprite
    STA .vduTempStoreDE                                 ;
    BCC +                                               ;
    INX                                                 ;
+
    STX .vduTempStoreDF                                 ;

    ; [NOTE: instead of the above two additions, calculate .seditCurrentVisibleX + .seditCurrentX then add to DE/DF, i.e.:
    ;   LDA .seditCurrentVisibleX
    ;   CLC
    ;   ADC .seditCurrentX
    ;   ADC .vduTempStoreDE
    ;   STA .vduTempStoreDE
    ;   BCC +
    ;   INC .vduTempStoreDF
    ;   +
    ;   ... to save eight bytes
    ; ]

    ; AX = start address of next sprite
    CLC                                                 ;
    LDY #.spriteHeaderOffsetSizeInBytesLow              ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    ADC .currentSpriteDefinitionLow                     ; add current sprite address (low)
    PHA                                                 ;
    INY                                                 ; Y = .spriteHeaderOffsetSizeInBytesHigh
    LDA (.currentSpriteDefinitionLow),Y                 ;
    ADC .currentSpriteDefinitionHigh                    ; add current sprite address (high)
    TAX                                                 ;
    PLA                                                 ;

    ; Add 5 to sprite address to account for the six byte header of the current sprite,
    ; minus one because we want to start from the last byte of the current sprite data, not
    ; the first byte of the next sprite.
    CLC                                                 ;
    ADC #5                                              ;
    BCC +                                               ;
    INX                                                 ;
+

    ; .seditCurrentSpriteByteLow/High = next sprite address - result
    ; (note that result = vduDE/F = the offset backwards from end of current sprite data to the current sprite byte)
    SEC                                                 ;
    SBC .vduTempStoreDE                                 ;
    STA .seditCurrentSpriteByteLow                      ; store current sprite byte address (low byte)
    TXA                                                 ;
    SBC .vduTempStoreDF                                 ;
    STA .seditCurrentSpriteByteHigh                     ; store current sprite byte address (high byte)
    RTS                                                 ;

; ***************************************************************************************
.seditXCoordinatePowerOf2
    ; MODE  0,   1,   2,   3,   4,   5
    !byte   8,   7,   7, $FF,   8,   8                  ; indexed by screen MODE (0-5)

.seditMaximumVisibleHeight
    ; MODE  0,   1,   2,   3,   4,   5
    !byte $0B, $17, $17, $FF, $17, $17                  ; indexed by screen MODE (0-5)

.seditMaximumVisibleWidth
    ; MODE  0,   1,   2,   3,   4,   5
    !byte $02, $05, $05, $FF, $02, $02                  ; indexed by screen MODE (0-5)

; This is how much we move in Y from one large square in the sprite editor to the next
.seditYCoordinateIncrement
    ; MODE  0,   1,   2,   3,   4,   5
    !byte $3F, $1F, $1F, $FF                            ; indexed by screen MODE (0-5) Overlaps 2 bytes into the next table

; This is how much we move in X (minus one) from one large square in the sprite editor to the next
.seditXCoordinateIncrement
    ; MODE  0,   1,   2,   3,   4,   5
    !byte $1F, $1F, $3F, $FF, $1F, $3F                  ; indexed by screen MODE (0-5)

; This is the initial OS coordinate offset in X for the first large square in any byte
.seditXCoordinateOffsetForRightmostPixelInByte
    ; MODE  0,   1,   2,   3,   4,   5
    !byte $E0, $60, $40, $FF, $E0, $C0                  ; indexed by screen MODE (0-5)

; ***************************************************************************************
;
; Get screen coordinates from sprite coordinates (.seditCurrentX, .seditCurrentY)
;
; On Exit:
;     .plotPointXLow/High = (.seditCurrentX * 256) + 16    for MODE 0,4,5 OR
;                         = (.seditCurrentX * 128) + 16    for MODE 1,2
;
;     .plotPointYLow/High = (.seditCurrentY * 64) + 8      for MODE 0 OR
;                         = (.seditCurrentY * 32) + 8      for MODE 1,2,4,5
;
; ***************************************************************************************
.seditGetScreenCoordinates
    LDA #0                                              ;
    STA .plotPointXHigh                                 ; high bytes start at zero
    STA .plotPointYHigh                                 ;

    ; Loop to multiply by a power of two
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditXCoordinatePowerOf2,X                     ;
    TAX                                                 ; loop counter
    LDA .seditCurrentVisibleX                           ; coordinate low byte
-
    ASL                                                 ; double low byte
    ROL .plotPointXHigh                                 ; double high byte (with carry)
    DEX                                                 ;
    BNE -                                               ; loop back

    ; Add 16
    ADC #16                                             ;
    STA .plotPointXLow                                  ;
    LDA .plotPointXHigh                                 ;
    ADC #0                                              ;
    STA .plotPointXHigh                                 ;

    LDX #5                                              ; }
    LDA .vduCurrentScreenMODE                           ; }
    BNE +                                               ; } if (MODE 0) then X = 6 else X = 5
    LDX #6                                              ; }
+
    ; Loop to multiply Y coordinate (A, .plotPointY) by a power of two
    ; i.e. Y coordinate << X
    ; X is the loop counter
    LDA .seditCurrentVisibleY                           ;
-
    ASL                                                 ; }
    ROL .plotPointYHigh                                 ; } Multiply A (from .seditCurrentVisibleY)
    DEX                                                 ; } and .plotPointYHigh by 32 (non-mode 0)
    BNE -                                               ; } or 64 (mode 0)

    ; Add 8 to Y coordinate
    ADC #8                                              ; } add 8
    STA .plotPointYLow                                  ; } and store in plotPointYLow/High
    LDA .plotPointYHigh                                 ; }
    ADC #0                                              ; }
    STA .plotPointYHigh                                 ; }
    RTS                                                 ;

    ; [NOTE: Could be this for a 3 byte saving
    ;   BCC +
    ;   INC .plotPointYHigh
    ;   +
    ;   RTS
    ; ]

; ***************************************************************************************
.seditMoveToNextSpriteToDelete
    JSR .incTempStoreDADB                               ; move past the COMMA

    LDX .vduTempStoreDA                                 ; } remcall user input
    LDY .vduTempStoreDB                                 ; } address into XY
      ; fall through...

; ***************************************************************************************
;
; *SDELETE
;
; ***************************************************************************************
.starSDelete
    JSR .read8BitNumberIntoA                            ;

    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } push address to rest of string
    PHA                                                 ; }

    LDA .vduTempStoreDE                                 ;
    JSR .deleteSpriteInternal                           ;

    PLA                                                 ; }
    TAY                                                 ; } recall address of rest of string
    PLA                                                 ; }
    TAX                                                 ; }
    JSR .skipLeadingSpaces                              ;

    STX .vduTempStoreDA                                 ;
    STY .vduTempStoreDB                                 ;
    LDY #0                                              ;
    LDA (.vduTempStoreDA),Y                             ;
    CMP #','                                            ;
    BEQ .seditMoveToNextSpriteToDelete                  ; if (comma found) then branch (move to next sprite to delete)
    RTS                                                 ;

; ***************************************************************************************
;
; Delete a sprite
;
; On Entry:
;   A: sprite number
;
; ***************************************************************************************
.deleteSpriteInternal
    JSR .findSpriteA                                    ; get sprite address

    STA .vduTempStoreDA                                 ;
    STY .vduTempStoreDB                                 ;
    CPX #0                                              ; [NOTE: redundant]
    BEQ .return7                                        ; if sprite not found, branch

    JSR .resetCurrentSpriteAddress                      ; reset address

    ; Reduce number of sprites
    SEC                                                 ;
    LDY #.workspaceOffsetNumberOfSprites                ; }
    LDA (.privateWorkspaceLow),Y                        ; } get number of sprites
    SBC #1                                              ; reduce by one
    STA (.privateWorkspaceLow),Y                        ; store number of sprites
    DEX                                                 ;
    BEQ .return7                                        ; if (no sprites left) then return

    JSR .moveToNextSprite                               ; tempStoreDC/DD moves on to next sprite

    ; Copy all remaining sprites down to fill the gap
-
    ; Get size of sprite
    CLC                                                 ;
    LDY #.spriteHeaderOffsetSizeInBytesLow              ; }
    LDA (.vduTempStoreDC),Y                             ; }
    ADC #6                                              ; } 6 is size of sprite header
    STA .vduTempStoreDE                                 ; } tempStoreDE/F = byte size of sprite data
    INY                                                 ; } Y = .spriteHeaderOffsetSizeInBytesHigh
    LDA (.vduTempStoreDC),Y                             ; }
    ADC #0                                              ; }
    STA .vduTempStoreDF                                 ; }

    JSR .blockCopyMemoryIncrementing                    ; copy sprite data down in memory to fill gap

    DEX                                                 ;
    BNE -                                               ;

.return7
    RTS                                                 ;

; ***************************************************************************************
;
; Add sprite
;
; Used in *SGET and *SMERGE
;
; On Entry:
;   .vduTempStoreDC/DD: address of sprite data to add
;
; ***************************************************************************************
.addSprite
    JSR .getPrivateWorkspaceAddress                     ;

    LDA .vduTempStoreDC                                 ; }
    PHA                                                 ; }
    LDA .vduTempStoreDD                                 ; } remember sprite address
    PHA                                                 ; }

    ; Delete existing sprite
    LDY #.spriteHeaderOffsetSpriteNumber                ; }
    LDA (.vduTempStoreDC),Y                             ; } get sprite number
    JSR .deleteSpriteInternal                           ;

    PLA                                                 ; }
    STA .vduTempStoreDD                                 ; }
    PLA                                                 ; } recall sprite address
    STA .vduTempStoreDC                                 ; }

    ; Get size of sprite
    CLC                                                 ; }
    LDY #.spriteHeaderOffsetSizeInBytesLow              ; }
    LDA (.vduTempStoreDC),Y                             ; }
    ADC #6                                              ; }
    STA .vduTempStoreDE                                 ; }
    INY                                                 ; } DE/DF = size in bytes of sprite
    LDA (.vduTempStoreDC),Y                             ; }
    ADC #0                                              ; }
    STA .vduTempStoreDF                                 ; }

    JSR .blockCopyMemoryIncrementing                    ; copy sprite data

    CLC                                                 ;
    LDY #.workspaceOffsetNumberOfSprites                ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    ADC #1                                              ; } increment number of sprites
    STA (.privateWorkspaceLow),Y                        ; }
    RTS                                                 ;

; ***************************************************************************************
;
; Redraw regular sized sprite
;
; Used as part of reduce vertically and reduce horizontally
;
; ***************************************************************************************
.seditClearAndReplotRegularSizeSprite
    JSR .printInlineCounted                             ; display following message
    !byte 12                                            ; length of message to print
    !byte 25,4                                          ; } MOVE 920,200
    !word 920, 200                                      ; }
    !byte 25,$67                                        ; rectangle fill in background colour
    !word 1220,800                                      ; 920,200 -> 1220,800
    ; fall through...

.seditPlotRegularSizeSprite
    JSR .getPrivateWorkspaceAddress                     ;

    LDY #.workspaceOffsetCurrentSpriteAddressLow        ;
    LDA .currentSpriteDefinitionLow                     ;
    STA (.privateWorkspaceLow),Y                        ;
    INY                                                 ;
    LDA .currentSpriteDefinitionHigh                    ;
    STA (.privateWorkspaceLow),Y                        ;

    ; Plot sprite
    JSR .printInlineCounted                             ; display following message
    !byte 19                                            ; length of message to print
    !byte 24                                            ; set graphics window
    !word 936, 200                                      ; left, bottom
    !word 1200, 800                                     ; right, top
    !byte 18,0,7                                        ; white graphics foreground colour
    !byte 25, $ed                                       ; plot sprite
    !word 936, 200                                      ; at x, y
    !byte 26                                            ; clear text and graphics windows

    RTS                                                 ;

; ***************************************************************************************
;
; Sprite data for new sprite
;
; A (1 byte x 1 pixel) MODE 2 sprite with one byte of logical colour zero.
;
; ***************************************************************************************
.newSpriteData
    ; Six byte sprite header
    !byte $00                                           ; width-1
    !byte $00                                           ; height-1
    !byte $01                                           ; } size in bytes
    !byte $00                                           ; }
    !byte $02                                           ; MODE number
    !byte $00                                           ; sprite number

    ; One byte of sprite data for a new sprite
    !byte $00                                           ;

.notEnoughRoomError2
    JMP .notEnoughRoomError                             ; [NOTE: redundant, caller should just JMP .notEnoughRoomError]

; ***************************************************************************************
;
; *SEDIT n[,m]
;
; Edit sprite n, save as sprite m
;
; On Entry:
;   XY: address of the rest of the command line
;
; ***************************************************************************************
.starSEdit
    JSR .read8BitNumberIntoA                            ; read sprite number to edit

    STA .vduWorkspaceB                                  ; 'edit' sprite number (n)
    STA .vduWorkspaceC                                  ; 'save' sprite number (m)
    JSR .skipLeadingSpaces                              ;

    STX .vduTempStoreDA                                 ;
    STY .vduTempStoreDB                                 ;
    LDY #0                                              ;
    LDA (.vduTempStoreDA),Y                             ;
    CMP #','                                            ;
    BNE .skipSecondNumber                               ; if no comma, skip ahead

    JSR .incTempStoreDADB                               ; move past the COMMA

    LDX .vduTempStoreDA                                 ; }
    LDY .vduTempStoreDB                                 ; } read the second number
    JSR .read8BitNumberIntoA                            ; }

    STA .vduWorkspaceC                                  ; second number, the 'save' sprite number (m)
.skipSecondNumber
    LDA .vduWorkspaceC                                  ; 'save' sprite number (m)
    CMP .vduWorkspaceB                                  ; 'edit' sprite number (n)
    BEQ +                                               ;
    JSR .deleteSpriteInternal                           ; delete 'save' sprite, ready to be overwritten
+
    JSR .getPrivateWorkspaceAddress                     ;
    JSR .getFreeSpace                                   ; DC/DD = end of used sprite memory address

    ; .vduTempStoreDA/B = .vduTempStoreDC/D (remember end of used sprite memory address)
    LDA .vduTempStoreDC                                 ;
    STA .vduTempStoreDA                                 ;
    LDA .vduTempStoreDD                                 ;
    STA .vduTempStoreDB                                 ;

    ; Check we can find the sprite
    LDA .vduWorkspaceB                                  ; sprite number to find
    JSR .findSpriteA                                    ; get address of sprite (into .vduTempStoreDC/DD)
    BEQ .couldNotFindSpriteToEdit                       ;

    LDA .vduWorkspaceB                                  ; 'edit' sprite number (n)
    CMP .vduWorkspaceC                                  ; 'save' sprite number (m)
    BNE .editSpriteDifferentFromSaveSprite              ; if (different) then branch

    ; Store sprite *index*
    STX .vduWorkspaceD                                  ;

    SEC                                                 ;
    LDY #.workspaceOffsetNumberOfSprites                ; }
    LDA (.privateWorkspaceLow),Y                        ; } number of sprites -= sprite index
    SBC .vduWorkspaceD                                  ; } i.e. number of sprites starting at the one being edited
    STA (.privateWorkspaceLow),Y                        ; }

    ; .vduTempStoreDE/DF = .vduTempStoreDA/DB - .vduTempStoreDC/DD
    ;                    = end of used sprite memory address - address of current sprite
    ;                    = amount of memory from the end of the current sprite to end of all sprite data
    SEC                                                 ;
    LDA .vduTempStoreDA                                 ;
    SBC .vduTempStoreDC                                 ;
    STA .vduTempStoreDE                                 ;
    LDA .vduTempStoreDB                                 ;
    SBC .vduTempStoreDD                                 ;
    STA .vduTempStoreDF                                 ;

    ; Edit sprite
    JMP .seditInternal                                  ;

.couldNotFindSpriteToEdit
    LDA #<.newSpriteData                                ;
    STA .vduTempStoreDC                                 ;
    LDA #>.newSpriteData                                ;
    STA .vduTempStoreDD                                 ;

.editSpriteDifferentFromSaveSprite
    LDA .vduTempStoreDF                                 ;
    PHA                                                 ;
    LDA .vduTempStoreDE                                 ;
    PHA                                                 ;

    ; Get size of sprite
    CLC                                                 ;
    LDY #.spriteHeaderOffsetSizeInBytesLow              ;
    LDA (.vduTempStoreDC),Y                             ;
    ADC #6                                              ;
    STA .vduTempStoreDE                                 ;
    INY                                                 ;
    LDA (.vduTempStoreDC),Y                             ;
    ADC #0                                              ;
    STA .vduTempStoreDF                                 ;

    ; Compare sizes of sprites
    PLA                                                 ;
    CMP .vduTempStoreDE                                 ;
    PLA                                                 ;
    SBC .vduTempStoreDF                                 ;
    BCS .enoughRoom                                     ;
    JMP .notEnoughRoomError2                            ;

.enoughRoom
    LDA #1                                              ;
    STA .vduWorkspaceD                                  ;
    ; fall through...

; ***************************************************************************************
;
; Main sprite editor routine
;
; Called once the parsing of the *SEDIT command is done and verification passes
;
; On Entry:
;   .vduWorkspaceC: sprite number
;   .vduWorkspaceD: sprite index
;   .vduTempStoreDC/DD: address of current sprite
;   .vduTempStoreDE/DF: length of sprite data
;
; ***************************************************************************************
.seditInternal

    ; We copy the existing sprites to the end of sprite memory, leaving the maximum amount
    ; for the sprite we are about to edit.

    ; Find how far we can copy the sprite data in memory...
    ; .vduTempStoreDA/DB = currentSpriteDefinitionLow/High = end of allocated sprite memory - length of sprite data
    SEC                                                 ;
    LDY #.workspaceOffsetSpriteEndPage                  ;
    LDA #0                                              ;
    SBC .vduTempStoreDE                                 ;
    STA .vduTempStoreDA                                 ;
    STA .currentSpriteDefinitionLow                     ;
    LDA (.privateWorkspaceLow),Y                        ;
    SBC .vduTempStoreDF                                 ;
    STA .vduTempStoreDB                                 ;
    STA .currentSpriteDefinitionHigh                    ;

    ; Copy sprite data to the end of allocated sprite memory, so give the maximum amount
    ; of memory for editing the current sprite.
    JSR .blockCopyMemoryDecrementing                    ; copy .vduTempStoreDE/DF bytes from tempStoreDC/DD to tempStoreDA/DB

    ; Store the sprite number
    LDA .vduWorkspaceC                                  ; sprite number
    LDY #.spriteHeaderOffsetSpriteNumber                ;
    STA (.currentSpriteDefinitionLow),Y                 ; store

    JSR .getPrivateWorkspaceAddress                     ;

    JSR .rememberCurrentSpriteInWorkspace               ;

    ; Store MODE in which the sprite was defined
    LDA .vduCurrentScreenMODE                           ;
    LDY #.spriteHeaderOffsetModeNumber                  ;
    STA (.currentSpriteDefinitionLow),Y                 ;

    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ;
    AND #$FE                                            ; clear bit 0 of options (pen up)
    STA (.privateWorkspaceLow),Y                        ;

    ; Set sprite cursor position to bottom left of sprite
    LDA #0                                              ;
    STA .seditCurrentX                                  ;
    STA .seditCurrentY                                  ;
    STA .seditCurrentVisibleX                           ;
    STA .seditCurrentVisibleY                           ;
    STA .seditScreenXOffsetWithinCurrentByte            ;
    LDA .vduColourMaskLeft                              ;
    STA .seditCurrentVisibleByteMask                    ;

    ; Set white pen
    LDA #7                                              ;
    STA .seditBackgroundColour                          ;

    ; Find the sprite width that is visible on-screen while editing (depends on the current MODE).
    LDX .vduCurrentScreenMODE                           ;
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    CMP .seditMaximumVisibleWidth,X                     ;
    BCC +                                               ;
    LDA .seditMaximumVisibleWidth,X                     ;
+
    STA .seditCurrentSpriteVisibleWidth                 ;

    ; Find the sprite height that is visible on-screen while editing (depends on the current MODE).
    INY                                                 ;
    LDA (.currentSpriteDefinitionLow),Y                 ; sprite height
    CMP .seditMaximumVisibleHeight,X                    ;
    BCC +                                               ;
    LDA .seditMaximumVisibleHeight,X                    ;
+
    STA .seditCurrentSpriteVisibleHeight                ;

    JSR .printInlineCounted                             ; display following message
    !byte 15                                            ; length of message to print
    !byte 4                                             ; VDU 4 (write text at the text cursor)
    !byte 26                                            ; VDU 26 (reset text and graphics windows)
    !byte 17,128                                        ; VDU 17,128 (select black as background colour)
    !byte 12                                            ; VDU 12 (clear screen)
    !byte 23,1,0,0,0,0,0,0,0,0                          ; VDU 23,1,0,0,0,0,0,0,0,0 (turn off cursor)

    LDA #4                                              ; } *FX 4,2
    LDX #2                                              ; } disable cursor editing (edit keys act as soft keys)
    JSR .OSBYTE                                         ; }

    LDA #$E1                                            ; }
    LDX #$90                                            ; } *FX 225,$90,0
    LDY #0                                              ; } expand function keys as $90 upwards
    JSR .OSBYTE                                         ; }

    LDA #$E2                                            ; }
    LDX #$80                                            ; } *FX 226,$80,0
    LDY #0                                              ; } expand SHIFT+function keys as $80 upwards
    JSR .OSBYTE                                         ; }

    LDA #$E3                                            ; }
    LDX #$A0                                            ; } *FX 227,$A0,0
    LDY #0                                              ; } expand CTRL+function keys as $A0 upwards
    JSR .OSBYTE                                         ; }

    JSR .seditPrintModeMessage                          ; print "Mode "
    JSR .drawRectangleAroundSpriteInWhite               ;
    JSR .seditDrawLargeAndRegularSpriteAndCursor        ;

.editingLoop
    JSR .seditPrintModeMessage                          ; update current status

    LDA #$0F                                            ; }
    TAX                                                 ; } Flush keyboard buffer
    JSR .OSBYTE                                         ; }
    JSR .OSRDCH                                         ; wait for key press
    BCS .exitEditing                                    ; carry set on ESCAPE
    CMP #$0D                                            ;
    BNE +                                               ; if (not RETURN key) then branch

    ; Handle RETURN key
    JSR .seditSetSquareColourA                          ;
    JMP .editingLoop                                    ;

+
    ; Check for DELETE key
    CMP #$7F                                            ;
    BNE +                                               ; if (not DELETE key) then branch

    ; Handle DELETE key
    JSR .seditDeleteSquare                              ;
    JMP .editingLoop                                    ;

+
    CMP #'0'                                            ;
    BCC .editingLoop                                    ; if (A < '0') then branch (loop back)

    CMP #'9'+1                                          ;
    BCC .editHandleDigit                                ; if (A <= '9') then branch

    CMP #'A'                                            ;
    BCC .editingLoop                                    ; if (A < 'A') then branch

    CMP #'F'+1                                          ;
    BCC .editHandleHexDigit                             ; if (A <= 'F') then branch

    CMP #'a'                                            ;
    BCC .editingLoop                                    ; if (A < 'a') then branch

    CMP #'f'+1                                          ;
    BCS .editContinueKeyChecks                          ; if (A >= 'f'+1) then branch

    SBC #$1F                                            ; convert a-f to A-F (upper case)
.editHandleHexDigit
    SEC                                                 ;
    SBC #7                                              ; adjust value of hex digit A-F
.editHandleDigit
    SEC                                                 ;
    SBC #'0'                                            ; convert hex digit to value 0-15
    STA .seditBackgroundColour                          ; set background colour
    JMP .editingLoop                                    ;

.editContinueKeyChecks
    CMP #$80                                            ;
    BCC .editingLoop                                    ; if (A < $80) then branch

    CMP #$B0                                            ;
    BCS .editingLoop                                    ; if (A >= $B0) then branch

    ; Handle function key press
    ASL                                                 ;
    TAX                                                 ;
    JSR .seditCallEditingFunction                       ;
    JMP .editingLoop                                    ;

; ***************************************************************************************
;
; Exit the sprite editor
;
; ***************************************************************************************
.exitEditing
    LDY #.spriteHeaderOffsetSpriteNumber                ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    PHA                                                 ; remember workspace[sprite number]

    LDA .currentSpriteDefinitionLow                     ;
    STA .vduTempStoreDC                                 ;
    LDA .currentSpriteDefinitionHigh                    ;
    STA .vduTempStoreDD                                 ;

    JSR .deselectCurrentSprite                          ;

    LDX .vduWorkspaceD                                  ; number of sprites
    JSR .addSpriteLoop                                  ;

    PLA                                                 ; recall sprite number
    JSR .starSChooseInternal                            ;

    LDA #$7C                                            ;
    JSR .OSBYTE                                         ; *FX 124 (Reset ESCAPE flag)

    LDA #$E1                                            ;
    LDX #1                                              ;
    LDY #0                                              ;
    JSR .OSBYTE                                         ; *FX 225,1,0 (Function keys)

    LDA #$E2                                            ;
    LDX #$80                                            ;
    LDY #0                                              ;
    JSR .OSBYTE                                         ; *FX 226,128,0 (SHIFT function keys)

    LDA #$E3                                            ;
    LDX #$90                                            ;
    LDY #0                                              ;
    JSR .OSBYTE                                         ; *FX 227,144,0 (CTRL function keys)

    LDA #4                                              ;
    JSR .OSWRCH                                         ; VDU 4

    LDA #4                                              ;
    LDX #0                                              ;
    LDY #0                                              ;
    JMP .OSBYTE                                         ; *FX 4,0,0 (cursor key editing)

; ***************************************************************************************
;
; Call the specific editing function
;
; On Entry:
;   X is offset within table of function address
;
; ***************************************************************************************
.seditCallEditingFunction
    ; lookup routine address
    LDA .seditRoutineTable,X                            ;
    STA .vduTempStoreDA                                 ;
    LDA .seditRoutineTable + 1,X                        ;
    STA .vduTempStoreDB                                 ;

    ; jump to routine
    JMP (.vduTempStoreDA)                               ;

; ***************************************************************************************
;
; Sprite editor commands (function keys, COPY key, and cursor keys)
;
; ***************************************************************************************
.seditRoutineTable
    !word .return                                       ; 128 = SHIFT + f0
    !word .return                                       ; 129 = SHIFT + f1
    !word .return                                       ; 130 = SHIFT + f2
    !word .seditReduceVertically                        ; 131 = SHIFT + f3
    !word .seditReduceHorizontally                      ; 132 = SHIFT + f4
    !word .seditDeleteRow                               ; 133 = SHIFT + f5
    !word .seditDeleteColumn                            ; 134 = SHIFT + f6
    !word .return                                       ; 135 = SHIFT + f7
    !word .return                                       ; 136 = SHIFT + f8
    !word .return                                       ; 137 = SHIFT + f9
    !word .return                                       ; 138 =
    !word .return                                       ; 139 = SHIFT + COPY
    !word .seditShiftCursorLeft                         ; 140 = SHIFT + cursor LEFT
    !word .seditShiftCursorRight                        ; 141 = SHIFT + cursor RIGHT
    !word .seditShiftCursorDown                         ; 142 = SHIFT + cursor DOWN
    !word .seditShiftCursorUp                           ; 143 = SHIFT + cursor UP

    !word .seditPenUpDown                               ; 144 = f0
    !word .seditFloodRow                                ; 145 = f1
    !word .seditFloodColumn                             ; 146 = f2
    !word .seditExtendVertically                        ; 147 = f3
    !word .seditExtendHorizontally                      ; 148 = f4
    !word .seditInsertRow                               ; 149 = f5
    !word .seditInsertColumn                            ; 150 = f6
    !word .seditMirrorVertically                        ; 151 = f7
    !word .seditMirrorHorizontally                      ; 152 = f8
    !word .return                                       ; 153 = f9
    !word .return                                       ; 154 =
    !word .seditCopy                                    ; 155 = COPY
    !word .seditCursorLeft                              ; 156 = cursor LEFT
    !word .seditCursorRight                             ; 157 = cursor RIGHT
    !word .seditCursorDown                              ; 158 = cursor DOWN
    !word .seditCursorUp                                ; 159 = cursor UP

    !word .return                                       ; 160 = CTRL + f0
    !word .return                                       ; 161 = CTRL + f1
    !word .return                                       ; 162 = CTRL + f2
    !word .return                                       ; 163 = CTRL + f3
    !word .return                                       ; 164 = CTRL + f4
    !word .return                                       ; 165 = CTRL + f5
    !word .return                                       ; 166 = CTRL + f6
    !word .return                                       ; 167 = CTRL + f7
    !word .return                                       ; 168 = CTRL + f8
    !word .return                                       ; 169 = CTRL + f9
    !word .return                                       ; 170 =
    !word .return                                       ; 171 = CTRL + COPY
    !word .seditCtrlCursorLeft                          ; 172 = CTRL + cursor LEFT
    !word .seditCtrlCursorRight                         ; 173 = CTRL + cursor RIGHT
    !word .seditCtrlCursorDown                          ; 174 = CTRL + cursor DOWN
    !word .seditCtrlCursorUp                            ; 175 = CTRL + cursor UP

; ***************************************************************************************
;
; Delete a square shown in the large sprite
;
; ***************************************************************************************
.seditDeleteSquare
    LDA .seditBackgroundColour                          ;
    PHA                                                 ; push old background colour
    LDA #0                                              ; background colour black
    BEQ .seditCopyInternal                              ; ALWAYS branch

; ***************************************************************************************
;
; Copy key: set pixel to white
;
; ***************************************************************************************
.seditCopy
    LDA .seditBackgroundColour                          ;
    PHA                                                 ; push old background colour
    LDA #7                                              ; background colour white

.seditCopyInternal
    STA .seditBackgroundColour                          ;
    JSR .seditSetSquareColourA                          ;
    PLA                                                 ;
    STA .seditBackgroundColour                          ;
.return6
    RTS                                                 ;

; ***************************************************************************************
;
; Check for pen down then set pixel
;
; ***************************************************************************************
.seditSetPixelIfPenDown
    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ;
    LSR                                                 ;
    BCC .return6                                        ; if pen up, return

.seditSetSquareColourA
    JSR .drawCircleCursor                               ; undraw cursor
    JSR .writeSpritePixel                               ;
    JSR .seditDrawLargePixelRectangle                   ;
    JSR .seditPlotRegularSizeSprite                     ;
    JMP .drawCircleCursor                               ; draw cursor

; ***************************************************************************************
;
; Write pixel into sprite
;
; ***************************************************************************************
.writeSpritePixel
    LDX #0                                              ;
    LDY .seditBackgroundColour                          ;
    JSR .gcolXY                                         ; set background colour

    LDA .vduForegroundGraphicsColour                    ; foreground colour
    AND .seditCurrentVisibleByteMask                    ; apply mask for current pixel
    STA .vduTempStoreDA                                 ; store pixel colour

    ; Update pixel in sprite
    LDY #0                                              ;
    LDA (.seditCurrentSpriteByteLow),Y                  ;
    ORA .seditCurrentVisibleByteMask                    ;
    EOR .seditCurrentVisibleByteMask                    ; clear bits from byte mask
    ORA .vduTempStoreDA                                 ; set bits for pixel colour
    STA (.seditCurrentSpriteByteLow),Y                  ;
.return
    RTS                                                 ;

; ***************************************************************************************
;
; Copy visible area rectangle left or right
;
; On Entry:
;   X: 0=move left
;      1=move right
;   Y: X coordinate to move from
;
; ***************************************************************************************
.moveVisibleAreaLeftOrRight
    LDA .seditCurrentVisibleX                           ; }
    PHA                                                 ; }
    LDA .seditCurrentVisibleY                           ; } remember current position
    PHA                                                 ; }
    LDA .seditCurrentVisibleByteMask                    ; }
    PHA                                                 ; }

    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } remember X,Y
    PHA                                                 ; }

    LDY #0                                              ;
    JSR .moveXY                                         ; source rectangle one corner

    PLA                                                 ; }
    TAX                                                 ; } X=original Y value (0=move left or 1=move right)
    LDY .seditCurrentSpriteVisibleHeight                ;
    INY                                                 ; Y = sprite height
    JSR .moveXMinus1YMinus1                             ; source rectangle other corner

    PLA                                                 ; } A=original X value
    PHA                                                 ; }
    EOR #1                                              ;
    TAX                                                 ; X ^= 1
    LDY #0                                              ; destination point (X,Y)
    JSR .seditCopyRectangleAbsolute                     ;

    PLA                                                 ; }
    TAX                                                 ; } X=original X value
    BEQ +                                               ;

    LDX .seditCurrentSpriteVisibleWidth                 ;
+
    STX .seditCurrentVisibleX                           ;
    LDA .seditScreenXOffsetWithinCurrentByte            ;
    PHA                                                 ;
    LDA #0                                              ;
    STA .seditScreenXOffsetWithinCurrentByte            ;
    LDA .vduColourMaskLeft                              ;
    STA .seditCurrentVisibleByteMask                    ;

-
    JSR .seditDrawLargeSpriteColumn                     ;

    SEC                                                 ;
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditXCoordinateIncrement,X                    ;
    ADC .seditScreenXOffsetWithinCurrentByte            ;
    STA .seditScreenXOffsetWithinCurrentByte            ;

    LSR .seditCurrentVisibleByteMask                    ;
    BCC -                                               ;

    PLA                                                 ;
    STA .seditScreenXOffsetWithinCurrentByte            ;
    JMP .restoreUVWAndDrawCursor                        ;

; ***************************************************************************************
;
; Copy visible area rectangle up or down
;
; On Entry:
;   X: 0=move down
;      1=move up
;   Y: Y coordinate to move down from
;
; ***************************************************************************************
.moveVisibleAreaUpOrDown
    LDA .seditCurrentVisibleX                           ; }
    PHA                                                 ; }
    LDA .seditCurrentVisibleY                           ; } remember current position
    PHA                                                 ; }
    LDA .seditCurrentVisibleByteMask                    ; }
    PHA                                                 ; }

    TXA                                                 ; }
    PHA                                                 ; } remember X
    LDX .seditCurrentSpriteVisibleWidth                 ;
    INX                                                 ; X=width
    JSR .moveXMinus1YMinus1                             ; source rectangle (top right)

    PLA                                                 ; }
    PHA                                                 ; } recall X
    TAY                                                 ; Y = original X (0=move down or 1=move up)
    LDX #0                                              ;
    JSR .moveXY                                         ; source rectangle (bottom left)

    PLA                                                 ; }
    PHA                                                 ; } recall X (0=move down or 1=move up)
    EOR #1                                              ;
    TAY                                                 ; Y = X^1 (reversed: 1=move down or 0=move up)
    LDX #0                                              ; destination point (X,Y)
    JSR .seditCopyRectangleAbsolute                     ;

    PLA                                                 ; recall X (0=move down or 1=move up)
    TAY                                                 ;
    BEQ +                                               ; if move down, then cursor Y = 0
    LDY .seditCurrentSpriteVisibleHeight                ;               else cursor Y = visible height
+
    STY .seditCurrentVisibleY                           ;
    JSR .seditDrawLargeSpriteRow                        ; draw last row that was left behind by the move

.restoreUVWAndDrawCursor
    PLA                                                 ; }
    STA .seditCurrentVisibleByteMask                    ; }
    PLA                                                 ; } recall current position
    STA .seditCurrentVisibleY                           ; }
    PLA                                                 ; }
    STA .seditCurrentVisibleX                           ; }
    JMP .drawCircleCursor                               ; draw cursor

; ***************************************************************************************
.moveXMinus1YMinus1
    STX .seditCurrentVisibleX                           ;
    STY .seditCurrentVisibleY                           ;
    LDX #4                                              ;
    JSR .plotX                                          ; MOVE (X-1,Y-1)

    JSR .seditGetScreenCoordinates                      ;

    ; Decrement plotPointX
    LDA .plotPointXLow                                  ;
    BNE +                                               ;
    DEC .plotPointXHigh                                 ;
+
    DEC .plotPointXLow                                  ;

    ; Decrement plotPointY
    LDA .plotPointYLow                                  ;
    BNE +                                               ;
    DEC .plotPointYHigh                                 ;
+
    DEC .plotPointYLow                                  ;

    JMP .outputXYCoordinates                            ;

; ***************************************************************************************
;
; MOVE vdu[X],vdu[Y]
;
; ***************************************************************************************
.moveXY
    STX .seditCurrentVisibleX                           ;
    LDX #4                                              ; MOVE plot type
    ; fall through...

; ***************************************************************************************
;
; PLOT X,vdu[.seditCurrentVisibleX],vdu[Y]
;
; ***************************************************************************************
.plotXY
    STY .seditCurrentVisibleY                           ;
    JSR .plotX                                          ;

    JSR .seditGetScreenCoordinates                      ;

.outputXYCoordinates
    JSR .seditOutputXCoordinate                         ;
    JMP .seditOutputYCoordinate                         ;

; ***************************************************************************************
;
; Copy a rectangle in the large sprite area
;
; On Entry:
;   X,Y: new visible cursor position
;
; ***************************************************************************************
.seditCopyRectangleAbsolute
    STX .seditCurrentVisibleX                           ;

    ; Remember current sprite editor position on the stack (6 bytes)
    LDX #5                                              ; loop counter
-
    LDA .seditCurrentVisibleByteMask,X                  ;
    PHA                                                 ;
    DEX                                                 ;
    BPL -                                               ;

    LDX #$BE                                            ; copy rectangle absolute
    JSR .plotXY                                         ;

    ; Recall current sprite editor position from the stack (6 bytes)
    LDX #0                                              ;
    LDY #5                                              ; loop counter
-
    PLA                                                 ;
    STA .seditCurrentVisibleByteMask,X                  ;
    INX                                                 ;
    DEY                                                 ;
    BPL -                                               ;

    RTS                                                 ;

; ***************************************************************************************
;
; Move sprite cursor left
;
; ***************************************************************************************
.seditCursorLeft
    JSR .seditSetPixelIfPenDown                         ; if pen down, then draw a pixel in the current foreground colour

    LDA .seditCurrentVisibleByteMask                    ; get pixel mask
    ASL                                                 ; shift mask for next pixel
    BCS .needToMoveToNewByteLeft                        ; if (need to move to new byte) then branch

    ; Moving within the current byte
    STA .seditCurrentVisibleByteMask                    ;

    JSR .drawCircleCursor                               ; undraw cursor

    ; Move X coordinate of cursor graphic one square left
    CLC                                                 ;
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditScreenXOffsetWithinCurrentByte            ;
    SBC .seditXCoordinateIncrement,X                    ; subtract .seditXCoordinateIncrement[currentMODE]
    STA .seditScreenXOffsetWithinCurrentByte            ;

    JMP .drawCircleCursor                               ; draw cursor

.needToMoveToNewByteLeft
    LDA .seditCurrentVisibleX                           ;
    BEQ .moveVisibleAreaLeft                            ; if (cursor is on left edge of visible area) then branch

    ; Move cursor within existing visible area
    JSR .drawCircleCursor                               ; undraw cursor

    DEC .seditCurrentVisibleX                           ; move visible cursor left
    LDA .vduColourMaskRight                             ; } store the rightmost mask value
    STA .seditCurrentVisibleByteMask                    ; }

    LDX .vduCurrentScreenMODE                           ;
    LDA .seditXCoordinateOffsetForRightmostPixelInByte,X ; set initial X offset for circle
    STA .seditScreenXOffsetWithinCurrentByte            ;

    JMP .drawCircleCursor                               ; draw cursor

.moveVisibleAreaLeft
    LDA .seditCurrentX                                  ;
    BNE +                                               ; if (not already on left edge of sprite) branch

    ; Already on left edge of sprite, so return
    RTS                                                 ;
+
    JSR .drawCircleCursor                               ; undraw cursor
    DEC .seditCurrentX                                  ;
    LDA .vduColourMaskRight                             ; } store rightmost mask value
    STA .seditCurrentVisibleByteMask                    ; }

    LDX .vduCurrentScreenMODE                           ;
    LDA .seditXCoordinateOffsetForRightmostPixelInByte,X ; set initial X offset for circle
    STA .seditScreenXOffsetWithinCurrentByte            ;

    LDX #0                                              ;
    LDY .seditCurrentSpriteVisibleWidth                 ;
    JMP .moveVisibleAreaLeftOrRight                     ;

; ***************************************************************************************
;
; Move sprite cursor right
;
; ***************************************************************************************
.seditCursorRight
    JSR .seditSetPixelIfPenDown                         ; if pen down, then draw a pixel in the current foreground colour

    LDA .seditCurrentVisibleByteMask                    ; get pixel mask
    LSR                                                 ; shift to next pixel
    BCS .needToMoveToNewByteRight                       ; if (need to move to new byte) then branch

    STA .seditCurrentVisibleByteMask                    ;
    JSR .drawCircleCursor                               ; undraw cursor

    ; Move X coordinate of cursor graphic right
    SEC                                                 ;
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditScreenXOffsetWithinCurrentByte            ;
    ADC .seditXCoordinateIncrement,X                    ;
    STA .seditScreenXOffsetWithinCurrentByte            ;

    JMP .drawCircleCursor                               ; draw cursor

.needToMoveToNewByteRight
    LDA .seditCurrentVisibleX                           ;
    CMP .seditCurrentSpriteVisibleWidth                 ;
    BEQ .moveVisibleAreaRight                           ; if (cursor is on right edge of visible area) then branch

    ; Move cursor within existing visible area
    JSR .drawCircleCursor                               ; undraw cursor

    INC .seditCurrentVisibleX                           ; move visible cursor right
    LDA .vduColourMaskLeft                              ; } store leftmost mask value
    STA .seditCurrentVisibleByteMask                    ; }
    LDA #0                                              ;
    STA .seditScreenXOffsetWithinCurrentByte            ; zero offset of graphics cursor
    JMP .drawCircleCursor                               ; draw cursor

.moveVisibleAreaRight
    CLC                                                 ;
    ADC .seditCurrentX                                  ;
    LDY #0                                              ;
    CMP (.currentSpriteDefinitionLow),Y                 ; compare with sprite width
    BNE .notOnRightEdge                                 ;
    RTS                                                 ;

.notOnRightEdge
    JSR .drawCircleCursor                               ; undraw cursor

    INC .seditCurrentX                                  ;
    LDA .vduColourMaskLeft                              ;
    STA .seditCurrentVisibleByteMask                    ; set mask to leftmost pixel mask
    LDA #0                                              ;
    STA .seditScreenXOffsetWithinCurrentByte            ;
    LDX #1                                              ;
    LDY .seditCurrentSpriteVisibleWidth                 ;
    INY                                                 ;
    JMP .moveVisibleAreaLeftOrRight                     ;

; ***************************************************************************************
;
; Move sprite cursor down
;
; ***************************************************************************************
.seditCursorDown
    JSR .seditSetPixelIfPenDown                         ; if pen down, then draw a pixel in the current foreground colour

    LDA .seditCurrentVisibleY                           ;
    BEQ .cursorIsAtBottomOfVisibleArea                  ; if (cursor is at bottom of visible area) then branch

    JSR .drawCircleCursor                               ; undraw cursor

    DEC .seditCurrentVisibleY                           ; move down
    JMP .drawCircleCursor                               ; draw cursor

.cursorIsAtBottomOfVisibleArea
    LDA .seditCurrentY                                  ;
    BNE .moveVisibleAreaDown                            ; if (visible area is not already at the bottom of the sprite) then branch
    RTS                                                 ;

.moveVisibleAreaDown
    JSR .drawCircleCursor                               ; undraw cursor
    DEC .seditCurrentY                                  ; move visible area down one row

    LDX #0                                              ; move down
    LDY .seditCurrentSpriteVisibleHeight                ;
    JMP .moveVisibleAreaUpOrDown                        ;

; ***************************************************************************************
;
; Move sprite cursor up
;
; ***************************************************************************************
.seditCursorUp
    JSR .seditSetPixelIfPenDown                         ; if pen down, then draw a pixel in the current foreground colour

    LDA .seditCurrentVisibleY                           ;
    CMP .seditCurrentSpriteVisibleHeight                ;
    BEQ .cursorIsAtTopOfVisibleArea                     ; if (cursor is at top of visible area) then branch

    JSR .drawCircleCursor                               ; undraw cursor

    INC .seditCurrentVisibleY                           ; move up
    JMP .drawCircleCursor                               ; draw cursor

.cursorIsAtTopOfVisibleArea
    CLC                                                 ;
    ADC .seditCurrentY                                  ;
    LDY #.spriteHeaderOffsetHeight                      ;
    CMP (.currentSpriteDefinitionLow),Y                 ;
    BNE .moveVisibleAreaUp                              ; if (visible area is not already at the top of the sprite) then branch

    RTS                                                 ;

.moveVisibleAreaUp
    JSR .drawCircleCursor                               ; undraw cursor
    INC .seditCurrentY                                  ; move visible area up one row

    LDX #1                                              ; move up
    LDY .seditCurrentSpriteVisibleHeight                ;
    INY                                                 ;
    JMP .moveVisibleAreaUpOrDown                        ;

; ***************************************************************************************
;
; Move sprite cursor fully left
;
; ***************************************************************************************
.seditCtrlCursorLeft
    JSR .drawCircleCursor                               ;

    LDA #0                                              ;
    STA .seditCurrentX                                  ;
    JSR .seditDrawLargeSprite                           ;
    JMP .seditSetVisibleCursorToLeftEdge                ;

; ***************************************************************************************
;
; Shift sprite cursor left
;
; ***************************************************************************************
.seditShiftCursorLeft
    JSR .drawCircleCursor                               ; undraw cursor

    SEC                                                 ;
    LDA .seditCurrentX                                  ;
    SBC #2                                              ;
    LDX .seditCurrentX                                  ;
    BEQ .alreadyOnLeftEdge                              ; if (X already on left edge) then branch

    BCC .closeToLeftEdge                                ; if (X close to left edge) then branch

    STA .seditCurrentX                                  ; .seditCurrentX -= 2
    JMP .seditDrawLargeSpriteAndCursor                  ;

.closeToLeftEdge
    PHA                                                 ; remember new X
    LDA #0                                              ;
    STA .seditCurrentX                                  ; set .seditCurrentX = 0
    JSR .seditDrawLargeSprite                           ;
    PLA                                                 ; recall new X

.alreadyOnLeftEdge
    CLC                                                 ;
    ADC .seditCurrentVisibleX                           ;
    STA .seditCurrentVisibleX                           ;
    BPL .seditDrawCursor                                ; if (non-negative) then branch (visible cursor X is in range)

.seditSetVisibleCursorToLeftEdge
    LDA #0                                              ;
    STA .seditCurrentVisibleX                           ;
    STA .seditScreenXOffsetWithinCurrentByte            ;
    LDA .vduColourMaskLeft                              ;
.seditStoreByteMaskAndContinue
    STA .seditCurrentVisibleByteMask                    ;
.seditDrawCursor
    JMP .drawCircleCursor                               ; draw cursor

; ***************************************************************************************
;
; Move sprite cursor fully right
;
; ***************************************************************************************
.seditCtrlCursorRight
    JSR .drawCircleCursor                               ;

    SEC                                                 ;
    LDY #0                                              ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    SBC .seditCurrentSpriteVisibleWidth                 ;
    STA .seditCurrentX                                  ;
    JSR .seditDrawLargeSprite                           ;

    JMP .finishCursorRight                              ;

; ***************************************************************************************
;
; Shift sprite cursor right
;
; ***************************************************************************************
.seditShiftCursorRight
    JSR .drawCircleCursor                               ; undraw cursor

    SEC                                                 ;
    LDY #.spriteHeaderOffsetWidth                       ; }
    LDA (.currentSpriteDefinitionLow),Y                 ; }
    SBC .seditCurrentSpriteVisibleWidth                 ; } X = sprite width - visible width
    TAX                                                 ; }
    CLC                                                 ;
    LDA .seditCurrentX                                  ; }
    ADC #2                                              ; } add 2 to current X
    CPX .seditCurrentX                                  ;
    BEQ .alreadyOnRightEdge                             ;

    STX .seditCurrentX                                  ;
    CMP .seditCurrentX                                  ;
    BCS .closeToRightEdge                               ;

    STA .seditCurrentX                                  ;
    JMP .seditDrawLargeSpriteAndCursor                  ;

.closeToRightEdge
    PHA                                                 ; remember new X coordinate
    JSR .seditDrawLargeSprite                           ;
    PLA                                                 ; recall new X coordinate

.alreadyOnRightEdge
    SEC                                                 ;
    SBC .seditCurrentX                                  ;
    CLC                                                 ;
    ADC .seditCurrentVisibleX                           ;
    STA .seditCurrentVisibleX                           ;
    CMP .seditCurrentSpriteVisibleWidth                 ; }
    BEQ .seditDrawCursor                                ; } if (visible X <= sprite width)  then branch (visible cursor X is in range)
    BCC .seditDrawCursor                                ; }

.finishCursorRight
    LDA .seditCurrentSpriteVisibleWidth                 ;
    STA .seditCurrentVisibleX                           ;
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditXCoordinateOffsetForRightmostPixelInByte,X ;
    STA .seditScreenXOffsetWithinCurrentByte            ;
    LDA .vduColourMaskRight                             ;
    BNE .seditStoreByteMaskAndContinue                  ;

; ***************************************************************************************
;
; Move sprite cursor fully down
;
; ***************************************************************************************
.seditCtrlCursorDown
    JSR .drawCircleCursor                               ; undraw cursor
    LDA #0                                              ;
    STA .seditCurrentY                                  ;
    JSR .seditDrawLargeSprite                           ;
    JMP .setVisibleYToZeroAndContinue                   ;

; ***************************************************************************************
;
; Shift sprite cursor down
;
; ***************************************************************************************
.seditShiftCursorDown
    JSR .drawCircleCursor                               ; undraw cursor
    SEC                                                 ; }
    LDA .seditCurrentY                                  ; }
    SBC #8                                              ; } currentY -= 8
    LDX .seditCurrentY                                  ; }
    BEQ .alreadyOnBottomEdge                            ;
    BCC .closeToBottomEdge                              ;
    STA .seditCurrentY                                  ;
    JMP .seditDrawLargeSpriteAndCursor                  ;

.closeToBottomEdge
    PHA                                                 ;
    LDA #0                                              ;
    STA .seditCurrentY                                  ; set to bottom edge
    JSR .seditDrawLargeSprite                           ;
    PLA                                                 ;
.alreadyOnBottomEdge
    CLC                                                 ;
    ADC .seditCurrentVisibleY                           ;
    STA .seditCurrentVisibleY                           ;
    BPL .finishCursorDown                               ;

.setVisibleYToZeroAndContinue
    LDA #0                                              ;
    STA .seditCurrentVisibleY                           ; visible Y = bottom edge
.finishCursorDown
    JMP .drawCircleCursor                               ; draw cursor

; ***************************************************************************************
;
; Move sprite cursor fully up
;
; ***************************************************************************************
.seditCtrlCursorUp
    JSR .drawCircleCursor                               ;
    SEC                                                 ;
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    SBC .seditCurrentSpriteVisibleHeight                ;
    STA .seditCurrentY                                  ;
    JSR .seditDrawLargeSprite                           ;
    JMP .setVisibleYToVisibleHeightAndContinue          ;

; ***************************************************************************************
;
; Shift sprite cursor up
;
; ***************************************************************************************
.seditShiftCursorUp
    JSR .drawCircleCursor                               ; undraw cursor
    SEC                                                 ;
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    SBC .seditCurrentSpriteVisibleHeight                ;
    TAX                                                 ; X=sprite height - visible height
    LDA .seditCurrentY                                  ;
    ADC #7                                              ;
    CPX .seditCurrentY                                  ;
    BEQ .alreadyOnTopEdge                               ;
    STX .seditCurrentY                                  ;
    CMP .seditCurrentY                                  ;
    BCS .closeToTopEdge                                 ;
    STA .seditCurrentY                                  ;
    JMP .seditDrawLargeSpriteAndCursor                  ;

.closeToTopEdge
    PHA                                                 ; remember new Y coordinate
    JSR .seditDrawLargeSprite                           ;
    PLA                                                 ; recall new Y coordinate
.alreadyOnTopEdge
    SEC                                                 ;
    SBC .seditCurrentY                                  ;
    CLC                                                 ;
    ADC .seditCurrentVisibleY                           ;
    STA .seditCurrentVisibleY                           ; set new visible Y
    CMP .seditCurrentSpriteVisibleHeight                ;
    BEQ .finishCursorUp                                 ;
    BCC .finishCursorUp                                 ;

.setVisibleYToVisibleHeightAndContinue
    LDA .seditCurrentSpriteVisibleHeight                ;
    STA .seditCurrentVisibleY                           ;
.finishCursorUp
    JMP .drawCircleCursor                               ;

; ***************************************************************************************
;
; Deselect current sprite
;
; On Exit:
;   Preserves Y
;
; ***************************************************************************************
.deselectCurrentSprite
    TYA                                                 ; }
    PHA                                                 ; } remember Y

    LDY #.workspaceOffsetChosenSpriteIndex              ;
    LDA (.privateWorkspaceLow),Y                        ;
    STA .vduWorkspaceD                                  ; store previously selected sprite index
    LDA #0                                              ; zero means no sprite selected
    STA (.privateWorkspaceLow),Y                        ;
    PLA                                                 ; } recall Y
    TAY                                                 ; }
    RTS                                                 ;

; ***************************************************************************************
;
; Record the current sprite details in the private workspace
;
; ***************************************************************************************
.rememberCurrentSpriteInWorkspace
    ; Remember address in workspace
    LDY #.workspaceOffsetChosenSpriteAddressLow         ; }
    LDA .currentSpriteDefinitionLow                     ; }
    STA (.privateWorkspaceLow),Y                        ; } workspace[chosen sprite address] = .currentSpriteDefinition
    INY                                                 ; }
    LDA .currentSpriteDefinitionHigh                    ; }
    STA (.privateWorkspaceLow),Y                        ; }

    ; Remember chosen sprite index in workspace
    INY                                                 ; Y=#.workspaceOffsetChosenSpriteIndex
    LDA .vduWorkspaceD                                  ;
    STA (.privateWorkspaceLow),Y                        ; workspace[chosen sprite index] = .vduWorkspaceD
    RTS                                                 ;

; ***************************************************************************************
;
; Extend the sprite to insert a new row
;
; ***************************************************************************************
.seditExtendVertically
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite height-1
    CMP #254                                            ;
    BCS .return25                                       ; if (height>=255) then branch (return)

    DEY                                                 ; Y=0
    JSR .seditExtendSpriteInDirectionY                  ;
    BCS .return25                                       ; if (cant extend)

    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    TAX                                                 ;
    INX                                                 ; X=sprite width
    TYA                                                 ; Y=0
.seditNewRowLoop
    STA (.vduTempStoreDA),Y                             ; }
    INY                                                 ; } store zero bytes in the new row
    DEX                                                 ; }
    BNE .seditNewRowLoop                                ; }

    LDX .vduCurrentScreenMODE                           ;
    LDA .seditCurrentSpriteVisibleHeight                ;
    CMP .seditMaximumVisibleHeight,X                    ;
    BCS .seditVisibleHeightIsAsBigAsItCanBe             ;

    JSR .drawRectangleAroundSpriteInBlack               ; remove current border (draw in black)
    INC .seditCurrentSpriteVisibleHeight                ; increment visible height
    JSR .drawRectangleAroundSpriteInWhite               ; draw new border (draw in white)

.seditVisibleHeightIsAsBigAsItCanBe
    CLC                                                 ;
.return25
    RTS                                                 ;

; ***************************************************************************************
;
; Rectangle fill in large sprite area
;
; ***************************************************************************************
.seditRectangleFillToCurrentXY
    JSR .seditGetScreenCoordinatesForCurrentSprite      ;
    LDX #$67                                            ; }
    JSR .plotX                                          ; } PLOT $67,X,Y (rectangle fill)
    JSR .seditOutputXCoordinate                         ; }
    JSR .seditOutputYCoordinate                         ; }
    JMP .drawRectangleAroundSpriteInWhite               ;

; ***************************************************************************************
;
; Extend the sprite to insert a new column
;
; ***************************************************************************************
.seditExtendHorizontally
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite width-1
    CMP #$FE                                            ;
    BCS .return14                                       ; if (width >=255) then branch

    INY                                                 ; Y=#.spriteHeaderOffsetHeight
    JSR .seditExtendSpriteInDirectionY                  ;
    BCS .return14                                       ;

    ; Copy sprite bytes across each row
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    TAX                                                 ;
    INX                                                 ; X=height (loop counter)
    DEY                                                 ; Y = 0
.copyOuterLoop
    TYA                                                 ;
    STA (.vduTempStoreDA),Y                             ;
    JSR .incTempStoreDADB                               ;

    TXA                                                 ;
    PHA                                                 ; push loop counter
    LDA (.currentSpriteDefinitionLow),Y                 ;
    TAX                                                 ;

    ; Copy X bytes from .vduTempStoreDC/D to .vduTempStoreDA/B
.copyLoop
    LDA (.vduTempStoreDC),Y                             ;
    STA (.vduTempStoreDA),Y                             ;
    JSR .incTempStoreDCDD                               ;
    JSR .incTempStoreDADB                               ;
    DEX                                                 ;
    BNE .copyLoop                                       ;

    PLA                                                 ; get loop counter
    TAX                                                 ;

    DEX                                                 ;
    BNE .copyOuterLoop                                  ; loop back until height bytes are copied

    ; Finish up
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditCurrentSpriteVisibleWidth                 ;
    CMP .seditMaximumVisibleWidth,X                     ;
    BCS .seditVisibleWidthIsAsBigAsItCanBe              ;

    JSR .drawRectangleAroundSpriteInBlack               ; remove current border (draw in black)
    INC .seditCurrentSpriteVisibleWidth                 ; increment visible width
    JSR .drawRectangleAroundSpriteInWhite               ; draw new border (draw in white)

.seditVisibleWidthIsAsBigAsItCanBe
    CLC                                                 ;
.return14
    RTS                                                 ;

; ***************************************************************************************
;
; Remove a row from the sprite
;
; On Exit:
;   Carry flag: set if full large and small sprite redraw needed
;
; ***************************************************************************************
.seditReduceVertically
    SEC                                                 ;
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite height - 1
    BEQ .return26                                       ; if (sprite height == 1) then branch

    DEY                                                 ; Y=0 (remove a row)
    JSR .seditReduceInDirectionY                        ;

    JSR .drawCircleCursor                               ; undraw cursor
    JSR .seditClearAndReplotRegularSizeSprite           ;

    SEC                                                 ;
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    SBC .seditCurrentY                                  ;
    CMP .seditCurrentVisibleY                           ;
    BCS .seditDontReduceCurrentVisibleY                 ;

    DEC .seditCurrentVisibleY                           ; reduce visibleY by one
.seditDontReduceCurrentVisibleY
    CMP .seditCurrentSpriteVisibleHeight                ;
    BCS .seditDrawCursorAndPreserveCarry                ;

    LDA .seditCurrentY                                  ;
    BNE .reduceCurrentY                                 ;

    DEC .seditCurrentSpriteVisibleHeight                ;

    ; Clear rectangular area
    JSR .printInlineCounted                             ; display following message
    !byte 6                                             ; length of message to print
    !byte 25,4                                          ;
    !word 0,800                                         ; PLOT 4,0,800
    JSR .seditRectangleFillToCurrentXY                  ;

    SEC                                                 ;
    BCS .seditDrawCursorAndPreserveCarry                ; ALWAYS branch

.reduceCurrentY
    DEC .seditCurrentY                                  ;
    INC .seditCurrentVisibleY                           ;
    JSR .seditDrawLargeSprite                           ;
    CLC                                                 ;
.seditDrawCursorAndPreserveCarry
    PHP                                                 ; remember carry
    JSR .drawCircleCursor                               ; draw cursor
    PLP                                                 ; recall carry
.return26
    RTS                                                 ;

; ***************************************************************************************
;
; Remove a column from the sprite
;
; ***************************************************************************************
.seditReduceHorizontally
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite width-1
    BEQ .return26                                       ; if (sprite width == 1) then branch (return)

    LDA .currentSpriteDefinitionLow                     ; }
    STA .vduTempStoreDC                                 ; } .vduTempStoreDC/DD = the current sprite definition address
    LDA .currentSpriteDefinitionHigh                    ; }
    STA .vduTempStoreDD                                 ; }

    JSR .moveToNextSprite                               ; .vduTempStoreDC/DD = next sprite address minus one
    JSR .decTempStoreDCDD                               ;                    = address of last byte of current sprite

    LDA .vduTempStoreDC                                 ; }
    STA .vduTempStoreDA                                 ; } .vduTempStoreDA/DB = address of last byte of current sprite
    LDA .vduTempStoreDD                                 ; }
    STA .vduTempStoreDB                                 ; }

    ; Copy sprite data to the end of sprite
    ; the source and destination addresses start out the same, but at the end of each row
    ; we reduce the source pointer by one byte, removing a column of bytes from the data
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite height-1
    TAX                                                 ;
    INX                                                 ; X=sprite height (loop counter)
    LDY #0                                              ; [NOTE: Redundant]
.seditReduceLoop
    TXA                                                 ;
    PHA                                                 ; remember sprite height remaining
    LDY #.spriteHeaderOffsetWidth                       ; Y=0
    LDA (.currentSpriteDefinitionLow),Y                 ;
    TAX                                                 ; X = sprite width-1 (inner loop counter)
.seditCopyRowOfSpriteLoop
    LDA (.vduTempStoreDC),Y                             ;
    STA (.vduTempStoreDA),Y                             ;
    JSR .decTempStoreDCDD                               ;
    JSR .decTempStoreDADB                               ;
    DEX                                                 ; decrement loop counter
    BNE .seditCopyRowOfSpriteLoop                       ; if more to do then loop back

    JSR .decTempStoreDCDD                               ; remove one byte from each row

    PLA                                                 ; }
    TAX                                                 ; } recall sprite height remaining and decrement
    DEX                                                 ; }
    BNE .seditReduceLoop                                ; loop back if more to do

    LDY #1                                              ; Y=1 (remove a column)
    JSR .seditReduceInDirectionY                        ; actually remove the column

    JSR .drawCircleCursor                               ; remove cursor

    JSR .seditClearAndReplotRegularSizeSprite           ; redraw small sprite

    SEC                                                 ;
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite width-1
    SBC .seditCurrentX                                  ; take off the current X position
    PHA                                                 ; remember how many columns are to the right of the current X
    CMP .seditCurrentVisibleX                           ;
    BCS .seditSkipDecrementingVisibleX                  ;

    ; Update the visible X and other associated variables
    DEC .seditCurrentVisibleX                           ;
    LDA .vduColourMaskRight                             ;
    STA .seditCurrentVisibleByteMask                    ;
    LDX .vduCurrentScreenMODE                           ;
    LDA .seditXCoordinateOffsetForRightmostPixelInByte,X ;
    STA .seditScreenXOffsetWithinCurrentByte            ;
.seditSkipDecrementingVisibleX
    PLA                                                 ; recall how many columns are to the right of the current X
    CMP .seditCurrentSpriteVisibleWidth                 ;
    BCS .seditFinishUp                                  ;

    LDA .seditCurrentX                                  ;
    BNE .seditSkipDecrementingVisibleWidth              ;

    DEC .seditCurrentSpriteVisibleWidth                 ;

    ; Blank out old column
    JSR .printInlineCounted                             ; display following message
    !byte 6                                             ; length of message to print
    !text 25,4                                          ;
    !word 900,0                                         ; PLOT 4,900,0

    JSR .seditRectangleFillToCurrentXY                  ;
    JMP .seditFinishUp                                  ;

.seditSkipDecrementingVisibleWidth
    DEC .seditCurrentX                                  ;
    INC .seditCurrentVisibleX                           ;
    JSR .seditDrawLargeSprite                           ;

.seditFinishUp
    JMP .drawCircleCursor                               ;

; ***************************************************************************************
;
; Extend a sprite
;
; On Entry:
;   Y: 0 means extend by a column; 1 means extend by a row
;
; ***************************************************************************************
.seditExtendSpriteInDirectionY
    JSR .getPrivateWorkspaceAddress                     ; }
    JSR .deselectCurrentSprite                          ; } NOTE: These calls all preserve Y
    JSR .getFreeSpace                                   ; }

    TYA                                                 ;
    TAX                                                 ; remember Y in X

    CLC                                                 ; }
    LDA .currentSpriteDefinitionLow                     ; }
    SBC (.currentSpriteDefinitionLow),Y                 ; }
    STA .vduTempStoreDA                                 ; } .vduTempStoreDA/DB = current sprite address - sprite width or height
    LDA .currentSpriteDefinitionHigh                    ; }
    SBC #0                                              ; }
    STA .vduTempStoreDB                                 ; }

    LDA .vduTempStoreDA                                 ; }
    CMP .vduTempStoreDC                                 ; } if (end of sprite memory < tempStoreDA/DB) then branch (no room to extend sprite)
    LDA .vduTempStoreDB                                 ; }
    SBC .vduTempStoreDD                                 ; }
    BCC .noRoomToExtendSprite                           ; }

    SEC                                                 ; }
    LDA (.currentSpriteDefinitionLow),Y                 ; } get sprite width or height
    LDY #.spriteHeaderOffsetSizeInBytesLow              ; } add size of sprite
    ADC (.currentSpriteDefinitionLow),Y                 ; } to give our new size
    STA (.currentSpriteDefinitionLow),Y                 ; }
    INY                                                 ; } Y=#.spriteHeaderOffsetSizeInBytesHigh
    LDA #0                                              ; }
    ADC (.currentSpriteDefinitionLow),Y                 ; }
    STA (.currentSpriteDefinitionLow),Y                 ; }

    TXA                                                 ; recall original Y
    EOR #1                                              ; flip to opposite direction: 1 to 0 and 0 to 1
    TAY                                                 ;
    CLC                                                 ; }
    LDA #1                                              ; } also add the length in the opposite direction (ie. the sprite height or width)?
    ADC (.currentSpriteDefinitionLow),Y                 ; }
    STA (.currentSpriteDefinitionLow),Y                 ; }

    ; Shuffle addresses around:
    ;
    ;   tempStoreDC/DD = current sprite address
    ;   current sprite address = tempStoreDA/DB
    LDY #1                                              ;
.seditShuffleAddressesLoop
    LDA .currentSpriteDefinitionLow,Y                   ;
    STA .vduTempStoreDC,Y                               ;
    LDA .vduTempStoreDA,Y                               ;
    STA .currentSpriteDefinitionLow,Y                   ;
    DEY                                                 ;
    BPL .seditShuffleAddressesLoop                      ;

    ; Copy six bytes of memory from .vduTempStoreDC/DD to .vduTempStoreDA/DB
    ; i.e. this copies the sprite header
    LDA #6                                              ;
    STA .vduTempStoreDE                                 ;
    LDA #0                                              ;
    STA .vduTempStoreDF                                 ;
    JSR .blockCopyMemoryIncrementing                    ; copy from .vduTempStoreDC/DD to .vduTempStoreDA/DB

    JSR .rememberCurrentSpriteInWorkspace               ;

    CLC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.noRoomToExtendSprite
    JSR .rememberCurrentSpriteInWorkspace               ;

    JSR .printInlineCounted                             ; display following message
    !byte 9                                             ; length of message to print
    !text $07,"No room",$0D                             ;

    LDA #$0F                                            ;
    TAX                                                 ;
    JSR .OSBYTE                                         ; *FX 15,15 (Flush keyboard)

    LDA #$81                                            ;
    LDX #$96                                            ;
    LDY #0                                              ;
    JSR .OSBYTE                                         ; read key for 150ms

    JSR .printInlineCounted                             ; display following message
    !byte 7                                             ; length of message to print
    !text "       "                                     ;

    SEC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Reduce a sprite
;
; ***************************************************************************************
.seditReduceInDirectionY
    JSR .deselectCurrentSprite                          ;

    TYA                                                 ;
    TAX                                                 ;
    CLC                                                 ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    STA .vduTempStoreDA                                 ;
    LDY #2                                              ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    SBC .vduTempStoreDA                                 ;
    STA (.currentSpriteDefinitionLow),Y                 ;
    INY                                                 ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    SBC #0                                              ;
    STA (.currentSpriteDefinitionLow),Y                 ;
    SEC                                                 ;
    LDA .currentSpriteDefinitionLow                     ;
    STA .vduTempStoreDC                                 ;
    ADC .vduTempStoreDA                                 ;
    STA .vduTempStoreDA                                 ;
    STA .currentSpriteDefinitionLow                     ;
    LDA .currentSpriteDefinitionHigh                    ;
    STA .vduTempStoreDD                                 ;
    ADC #0                                              ;
    STA .vduTempStoreDB                                 ;
    STA .currentSpriteDefinitionHigh                    ;
    LDA #6                                              ;
    STA .vduTempStoreDE                                 ;
    LDA #0                                              ;
    STA .vduTempStoreDF                                 ;
    JSR .blockCopyMemoryDecrementing                    ;

    TXA                                                 ;
    EOR #1                                              ;
    TAY                                                 ; Y=X^1
    SEC                                                 ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    SBC #1                                              ; decrement
    STA (.currentSpriteDefinitionLow),Y                 ;
    JMP .rememberCurrentSpriteInWorkspace               ;

; ***************************************************************************************
;
; Toggle pen up / down
;
; ***************************************************************************************
.seditPenUpDown
    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ;
    EOR #1                                              ; flip bit 0 of options
    STA (.privateWorkspaceLow),Y                        ;
    RTS                                                 ;

; ***************************************************************************************
;
; Flood one column of sprite
;
; ***************************************************************************************
.seditFloodColumn
    JSR .drawCircleCursor                               ; undraw current cursor

    LDA .seditCurrentVisibleY                           ;
    PHA                                                 ; remember current visible Y

    CLC                                                 ;
    LDA .seditCurrentY                                  ; get sprite pixel Y for bottom left of visible area of sprite
    ADC .seditCurrentVisibleY                           ; add sprite pixel Y offset within the visible area
    STA .seditCurrentVisibleY                           ; store current Y sprite pixel

    PHA                                                 ; remember it
    LDA .seditCurrentSpriteByteLow                      ; }
    PHA                                                 ; } remember address of current sprite data
    LDA .seditCurrentSpriteByteHigh                     ; }
    PHA                                                 ; }
    JSR .getColourByteFromPixelOfSprite                 ;

    JSR .writeSpritePixel                               ;

.floodColumnUpLoop
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA .seditCurrentVisibleY                           ;
    CMP (.currentSpriteDefinitionLow),Y                 ; check if we have reached the height of the sprite
    LDY #.spriteHeaderOffsetWidth                       ;
    BCS .floodColumnDown                                ;

    INC .seditCurrentVisibleY                           ;

    ; Subtract width from sprite data address
    CLC                                                 ;
    LDA .seditCurrentSpriteByteLow                      ;
    SBC (.currentSpriteDefinitionLow),Y                 ;
    STA .seditCurrentSpriteByteLow                      ;
    BCS +                                               ;
    DEC .seditCurrentSpriteByteHigh                     ;
+

    JSR .writeSpritePixelIfItsBackgroundColour          ;
    BCC .floodColumnUpLoop                              ;

.floodColumnDown
    PLA                                                 ; }
    STA .seditCurrentSpriteByteHigh                     ; } recall original sprite address
    PLA                                                 ; } and Y sprite pixel
    STA .seditCurrentSpriteByteLow                      ; }
    PLA                                                 ; }
    STA .seditCurrentVisibleY                           ; }

.floodColumnDownLoop
    LDY #0                                              ;
    LDA .seditCurrentVisibleY                           ;
    BEQ .floodColumnFinishUp                            ;

    DEC .seditCurrentVisibleY                           ;

    ; Add width to sprite data address
    SEC                                                 ;
    LDA .seditCurrentSpriteByteLow                      ;
    ADC (.currentSpriteDefinitionLow),Y                 ;
    STA .seditCurrentSpriteByteLow                      ;
    BCC +                                               ;
    INC .seditCurrentSpriteByteHigh                     ;
+

    JSR .writeSpritePixelIfItsBackgroundColour          ;
    BCC .floodColumnDownLoop                            ;

.floodColumnFinishUp
    JSR .seditPlotRegularSizeSprite                     ; plot the regular size sprite
    JSR .seditDrawLargeSpriteColumn                     ; draw new large sprite column

    PLA                                                 ;
    STA .seditCurrentVisibleY                           ;
    JMP .drawCircleCursor                               ; draw current cursor

; ***************************************************************************************
;
; Flood one row of sprite
;
; ***************************************************************************************
.seditFloodRow
    JSR .drawCircleCursor                               ; undraw current cursor

    ; Remember current visible X and byte mask (twice)
    LDA .seditCurrentVisibleX                           ;
    PHA                                                 ;
    LDA .seditCurrentVisibleByteMask                    ;
    PHA                                                 ;
    PHA                                                 ;

    CLC                                                 ;
    LDA .seditCurrentX                                  ; get sprite pixel X for bottom left of visible area of sprite
    ADC .seditCurrentVisibleX                           ; add sprite pixel X offset within the visible area
    STA .seditCurrentVisibleX                           ; store current X sprite pixel

    PHA                                                 ; remember it
    LDA .seditCurrentSpriteByteLow                      ; }
    PHA                                                 ; } remember address of current sprite data
    LDA .seditCurrentSpriteByteHigh                     ; }
    PHA                                                 ; }
    JSR .getColourByteFromPixelOfSprite                 ;

    JSR .writeSpritePixel                               ;

.floodRowRightLoop
    LSR .seditCurrentVisibleByteMask                    ;
    BCC .writePixel1                                    ;

    ; Start next byte going
    LDA .vduColourMaskLeft                              ;
    STA .seditCurrentVisibleByteMask                    ;
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA .seditCurrentVisibleX                           ;
    CMP (.currentSpriteDefinitionLow),Y                 ; if (reached right edge of sprite) then branch
    BCS .floodRowLeft                                   ;

    INC .seditCurrentVisibleX                           ;

    ; Decrement sprite byte (sprite bytes are stored right to left)
    LDA .seditCurrentSpriteByteLow                      ;
    BNE +                                               ;
    DEC .seditCurrentSpriteByteHigh                     ;
+
    DEC .seditCurrentSpriteByteLow                      ;

.writePixel1
    JSR .writeSpritePixelIfItsBackgroundColour          ;
    BCC .floodRowRightLoop                              ;

.floodRowLeft
    PLA                                                 ; }
    STA .seditCurrentSpriteByteHigh                     ; }
    PLA                                                 ; }
    STA .seditCurrentSpriteByteLow                      ; } restore original values after filling right
    PLA                                                 ; }
    STA .seditCurrentVisibleX                           ; }
    PLA                                                 ; }
    STA .seditCurrentVisibleByteMask                    ; }
.floodRowLeftLoop
    ASL .seditCurrentVisibleByteMask                    ;
    BCC .writePixel2                                    ;

    LDA .vduColourMaskRight                             ;
    STA .seditCurrentVisibleByteMask                    ;
    LDY #0                                              ;
    LDA .seditCurrentVisibleX                           ;
    BEQ .floodRowFinishUp                               ; if (at left edge of sprite) then branch

    ; Move left one pixel
    DEC .seditCurrentVisibleX                           ;

    ; Add one to sprite byte address (sprites are stored right to left)
    INC .seditCurrentSpriteByteLow                      ;
    BNE .writePixel2                                    ;
    INC .seditCurrentSpriteByteHigh                     ;

.writePixel2
    JSR .writeSpritePixelIfItsBackgroundColour          ;
    BCC .floodRowLeftLoop                               ;

.floodRowFinishUp
    JSR .seditPlotRegularSizeSprite                     ; plot the regular size sprite
    JSR .seditDrawLargeSpriteRow                        ; draw new large sprite row

    PLA                                                 ; }
    STA .seditCurrentVisibleByteMask                    ; } restore byte mask and X position
    PLA                                                 ; }
    STA .seditCurrentVisibleX                           ; }
    JMP .drawCircleCursor                               ; draw current cursor

; ***************************************************************************************
;
; Get the current pixel colour from a sprite returned as a solid colour byte
;
; ***************************************************************************************
.getColourByteFromPixelOfSprite
    LDY #0                                              ;
    LDA (.seditCurrentSpriteByteLow),Y                  ; sprite byte
    AND .seditCurrentVisibleByteMask                    ; mask off what isn't the current pixel
    STA .vduWorkspaceA                                  ;

    ; Shift pixel value up to the top bits
    LDA .seditCurrentVisibleByteMask                    ;
    BMI +                                               ;

.updateMaskLoop
    ASL .vduWorkspaceA                                  ;
    ASL                                                 ; shift mask value up too
    BPL .updateMaskLoop                                 ;

    ; Shift pixel down the byte, making each pixel the same colour, so we end up with
    ; a byte of solid colour based on the pixel from the sprite
+
    LDX .vduPixelsPerByteMinusOne                       ;
    LDA .vduWorkspaceA                                  ;
.updateSpriteByteLoop
    LSR                                                 ;
    ORA .vduWorkspaceA                                  ;
    DEX                                                 ;
    BNE .updateSpriteByteLoop                           ;

    STA .vduWorkspaceA                                  ;
    RTS                                                 ;

; ***************************************************************************************
.writeSpritePixelIfItsBackgroundColour
    LDY #0                                              ;
    LDA (.seditCurrentSpriteByteLow),Y                  ; read sprite byte
    EOR .vduWorkspaceA                                  ; EOR with background colour
    AND .seditCurrentVisibleByteMask                    ; apply mask
    SEC                                                 ;
    BNE .return19                                       ; if (not background colour) then branch (return)

    ; Sprite pixel is background colour, write new pixel there
    JSR .writeSpritePixel                               ;

    CLC                                                 ;
.return19
    RTS                                                 ;

; ***************************************************************************************
;
; Insert row
;
; ***************************************************************************************
.seditInsertRow
    JSR .seditExtendVertically                          ;
    BCS .return27                                       ; if (no room to extend) then branch (return)

    CLC                                                 ; }
    LDA .currentSpriteDefinitionLow                     ; }
    ADC #5                                              ; }
    STA .vduTempStoreDC                                 ; } tempStoreDC/DD = current sprite address + 5
    LDA .currentSpriteDefinitionHigh                    ; }
    ADC #0                                              ; }
    STA .vduTempStoreDD                                 ; }

    LDY #.spriteHeaderOffsetHeight                      ; }
    SEC                                                 ; }
    LDA (.currentSpriteDefinitionLow),Y                 ; }
    SBC .seditCurrentY                                  ; } X = (sprite height - current position)
    SEC                                                 ; } i.e. the number of rows above the current row
    SBC .seditCurrentVisibleY                           ; }
    DEY                                                 ; } Y = 0
    TAX                                                 ; }
.seditInsertRowLoop
    LDA .vduTempStoreDC                                 ;
    STA .vduTempStoreDA                                 ;
    SEC                                                 ;
    LDA (.currentSpriteDefinitionLow),Y                 ; sprite width-1
    TAY                                                 ;
    INY                                                 ; Y=sprite width (loop counter)
    ADC .vduTempStoreDC                                 ; }
    STA .vduTempStoreDC                                 ; } .vduTempStoreDC/DD = source
    LDA .vduTempStoreDD                                 ; } .vduTempStoreDA/DB = destination
    STA .vduTempStoreDB                                 ; }
    BCC .seditCopyRowLoop                               ; }
    INC .vduTempStoreDD                                 ; }
.seditCopyRowLoop
    LDA (.vduTempStoreDC),Y                             ;
    STA (.vduTempStoreDA),Y                             ;
    DEY                                                 ;
    BNE .seditCopyRowLoop                               ;

    DEX                                                 ;
    BNE .seditInsertRowLoop                             ;

    ; Store zeroes in the newly inserted row
    ; Y=0 here
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite width-1
    TAY                                                 ;
    INY                                                 ; Y=sprite width
.seditClearNewRowLoop
    LDA #0                                              ;
    STA (.vduTempStoreDC),Y                             ;
    DEY                                                 ;
    BNE .seditClearNewRowLoop                           ;

    JMP .seditDrawLargeAndRegularSpriteAndUpdateCursor  ;

.return27
    RTS                                                 ;

; ***************************************************************************************
;
; Delete row
;
; ***************************************************************************************
.seditDeleteRow
    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite height-1
    BEQ .return28                                       ; if (sprite height == 1) then branch (return)

    SEC                                                 ; }
    SBC .seditCurrentY                                  ; }
    SEC                                                 ; } Y = sprite height - current position
    SBC .seditCurrentVisibleY                           ; }
    BEQ .deleteRowAndUpdate                             ; if (removing the top row) then branch

    ; Need to copy data
    TAX                                                 ; X = number of rows to move (loop counter)
    DEY                                                 ; Y = #.spriteHeaderOffsetWidth
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite width-1
    TAY                                                 ;
    INY                                                 ; Y=sprite width
    JSR .multiply8x8                                    ; .vduTempStoreDE/DF = (number of rows to move) * (sprite width)

    ; tempStoreDC/DD = current sprite definition + number of bytes to move
    CLC                                                 ;
    LDA .currentSpriteDefinitionLow                     ;
    ADC .vduTempStoreDE                                 ;
    STA .vduTempStoreDC                                 ;
    LDA .currentSpriteDefinitionHigh                    ;
    ADC .vduTempStoreDF                                 ;
    STA .vduTempStoreDD                                 ;
    LDA .vduTempStoreDC                                 ;
    ADC #5                                              ;
    STA .vduTempStoreDC                                 ;
    BCC +                                               ;
    INC .vduTempStoreDD                                 ;
+

    ; Copy bytes from tempStoreDC/DD to tempStroeDA/DB
    LDY #.spriteHeaderOffsetWidth                       ;
.copySpriteDataForDeleteRow
    CLC                                                 ; }
    LDA .vduTempStoreDC                                 ; }
    STA .vduTempStoreDA                                 ; } .vduTempStoreDA/DB=.vduTempStoreDC/DD
    SBC (.currentSpriteDefinitionLow),Y                 ; } .vduTempStoreDC/DD=-width
    STA .vduTempStoreDC                                 ; }
    LDA .vduTempStoreDD                                 ; }
    STA .vduTempStoreDB                                 ; }
    SBC #0                                              ; }
    STA .vduTempStoreDD                                 ; }

    LDA (.currentSpriteDefinitionLow),Y                 ;
    TAY                                                 ;
    INY                                                 ; Y = sprite width (loop counter)
-
    LDA (.vduTempStoreDC),Y                             ; copy sprite data for row
    STA (.vduTempStoreDA),Y                             ;
    DEY                                                 ;
    BNE -                                               ;
    DEX                                                 ;
    BNE .copySpriteDataForDeleteRow                     ;

.deleteRowAndUpdate
    JSR .seditReduceVertically                          ;
    BCC .return28                                       ;
    JMP .seditDrawLargeAndRegularSpriteAndUpdateCursor  ;

.return28
    RTS                                                 ;

; ***************************************************************************************
;
; Print the following message
;
; First byte of following data is a count of the characters
;
; X and Y are preserved
;
; ***************************************************************************************
.printInlineCounted
    PLA                                                 ; }
    STA .vduTempStoreDA                                 ; }
    PLA                                                 ; } get address of following data from stack
    STA .vduTempStoreDB                                 ; } (minus one)

    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } Remember current XY
    PHA                                                 ; }
    JSR .incTempStoreDADB                               ; increment pointer to point at data itself

    LDY #0                                              ;
    LDA (.vduTempStoreDA),Y                             ;
    TAX                                                 ; count of number of bytes
    JSR .incTempStoreDADB                               ;

.printCharacterLoop
    LDA .vduTempStoreDA                                 ; }
    PHA                                                 ; }
    LDA .vduTempStoreDB                                 ; } remember tempStoreDA/DB
    PHA                                                 ; }

    LDA (.vduTempStoreDA),Y                             ; load character
    JSR .OSWRCH                                         ; print character

    PLA                                                 ; }
    STA .vduTempStoreDB                                 ; }
    PLA                                                 ; } restore tempStoreDA/DB
    STA .vduTempStoreDA                                 ; }
    JSR .incTempStoreDADB                               ; move to next character

    DEX                                                 ; decrement counter
    BNE .printCharacterLoop                             ; if (not finished) then branch

    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } Restore XY
    TAX                                                 ; }
    JMP (.vduTempStoreDA)                               ; return to following instruction

; ***************************************************************************************
;
; Insert column
;
; ***************************************************************************************
.seditInsertColumn
    JSR .createMaskByteForPixelsToTheRight              ;
    STA .vduTempStoreDC                                 ;

    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    TAX                                                 ;
    INX                                                 ; X=sprite height
    CLC                                                 ;
    LDA .currentSpriteDefinitionLow                     ; }
    ADC #5                                              ; }
    STA .vduTempStoreDA                                 ; } tempStoreDA/DB = sprite address + 5
    LDA .currentSpriteDefinitionHigh                    ; }
    ADC #0                                              ; }
    STA .vduTempStoreDB                                 ; }

    SEC                                                 ; }
    LDY #.spriteHeaderOffsetWidth                       ; }
    LDA (.currentSpriteDefinitionLow),Y                 ; }
    SBC .seditCurrentX                                  ; } .vduTempStoreDF = width - current position
    SEC                                                 ; }                 = number of bytes to the right of the current position
    SBC .seditCurrentVisibleX                           ; }
    STA .vduTempStoreDF                                 ; }
    INC .vduTempStoreDF                                 ; }
.insertColumnLoop
    TXA                                                 ; } remember X (the sprite height remaining, the loop counter) on the stack
    PHA                                                 ; }

    LDY .vduTempStoreDF                                 ;
    LDA (.vduTempStoreDA),Y                             ; get sprite byte
    PHA                                                 ; remember it on the stack
    ORA .vduTempStoreDC                                 ; OR with mask of pixels to the right
    EOR .vduTempStoreDC                                 ; EOR to get the pixels to the left only
    STA .vduTempStoreDE                                 ; store result

    LDA (.vduTempStoreDA),Y                             ; get sprite byte again
    AND .vduTempStoreDC                                 ;
    ORA .vduColourMaskRight                             ;
    EOR .vduColourMaskRight                             ;
    LSR                                                 ; shift byte right to move the pixels
    ORA .vduTempStoreDE                                 ; add contribution from previous byte
    STA (.vduTempStoreDA),Y                             ; store back in sprite byte
    PLA                                                 ; recall sprite byte
    AND .vduColourMaskRight                             ;

    ; Shift A left by pixels per byte-1
    LDX .vduPixelsPerByteMinusOne                       ;
-
    ASL                                                 ;
    DEX                                                 ;
    BNE -                                               ;

    STA .vduTempStoreDE                                 ;
    DEY                                                 ;
    BEQ .seditInsertColumnGotoNextRow                   ; if (end of row) then branch

.insertColumnLoop2
    LDA (.vduTempStoreDA),Y                             ; read sprite byte
    PHA                                                 ;
    ORA .vduColourMaskRight                             ;
    EOR .vduColourMaskRight                             ;
    LSR                                                 ;
    ORA .vduTempStoreDE                                 ;
    STA (.vduTempStoreDA),Y                             ; store back in sprite byte
    PLA                                                 ; recall original sprite byte
    AND .vduColourMaskRight                             ;

    ; Shift A left by pixels per byte-1
    LDX .vduPixelsPerByteMinusOne                       ;
-
    ASL                                                 ;
    DEX                                                 ;
    BNE -                                               ;

    STA .vduTempStoreDE                                 ; store pixel from the previous byte
    DEY                                                 ;
    BNE .insertColumnLoop2                              ;

.seditInsertColumnGotoNextRow
    LDY #.spriteHeaderOffsetWidth                       ; }
    SEC                                                 ; }
    LDA .vduTempStoreDA                                 ; } add sprite width to tempStoreDA/DB
    ADC (.currentSpriteDefinitionLow),Y                 ; }
    STA .vduTempStoreDA                                 ; }
    LDA .vduTempStoreDB                                 ; }
    ADC #0                                              ; }
    STA .vduTempStoreDB                                 ; }

    PLA                                                 ; } Recall loop counter X
    TAX                                                 ; }
    DEX                                                 ;
    BNE .insertColumnLoop                               ;

    JMP .seditDrawLargeAndRegularSpriteAndUpdateCursor  ;

; ***************************************************************************************
;
; Delete column
;
; ***************************************************************************************
.seditDeleteColumn
    JSR .createMaskByteForPixelsToTheRight              ;
    STA .vduTempStoreDC                                 ;

    LDY #1                                              ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite height-1
    TAX                                                 ;
    INX                                                 ; X=sprite height

    ; tempStoreDA/DB = sprite address + 6
    CLC                                                 ;
    LDA .currentSpriteDefinitionLow                     ;
    ADC #6                                              ;
    STA .vduTempStoreDA                                 ;
    LDA .currentSpriteDefinitionHigh                    ;
    ADC #0                                              ;
    STA .vduTempStoreDB                                 ;

    SEC                                                 ;
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.currentSpriteDefinitionLow),Y                 ; get sprite width-1
    SBC .seditCurrentX                                  ; subtract current position
    SEC                                                 ;
    SBC .seditCurrentVisibleX                           ;
    STA .vduTempStoreDF                                 ; .vduTempStoreDF = sprite width - current position
                                                        ; i.e. number of columns to move

.deleteColumnLoop
    TXA                                                 ; }
    PHA                                                 ; } store loop counter (number of columns remaining to move)
    LDA #0                                              ;
    STA .vduTempStoreDE                                 ; .vduTempStoreDE holds the pixel from previous byte
    LDY .vduTempStoreDF                                 ;
    BEQ .finishUpMovingRow                              ;

    LDY #0                                              ;
.moveRowLoop
    LDA (.vduTempStoreDA),Y                             ; get sprite byte
    PHA                                                 ; remember sprite byte
    ORA .vduColourMaskLeft                              ;
    EOR .vduColourMaskLeft                              ;
    ASL                                                 ; shift byte
    ORA .vduTempStoreDE                                 ;
    STA (.vduTempStoreDA),Y                             ; store sprite byte
    PLA                                                 ; recall original sprite byte
    AND .vduColourMaskLeft                              ;

    ; Shift A right by pixels per byte-1
    LDX .vduPixelsPerByteMinusOne                       ;
-
    LSR                                                 ;
    DEX                                                 ;
    BNE -                                               ;

    STA .vduTempStoreDE                                 ; store pixel from the previous byte
    INY                                                 ;
    CPY .vduTempStoreDF                                 ;
    BNE .moveRowLoop                                    ;

.finishUpMovingRow
    ; Move last byte of row
    LDA (.vduTempStoreDA),Y                             ;
    ORA .vduTempStoreDC                                 ;
    EOR .vduTempStoreDC                                 ;
    ORA .vduTempStoreDE                                 ;
    STA .vduTempStoreDE                                 ;
    LDA (.vduTempStoreDA),Y                             ;
    AND .vduTempStoreDC                                 ;
    ORA .seditCurrentVisibleByteMask                    ;
    EOR .seditCurrentVisibleByteMask                    ;
    ASL                                                 ;
    ORA .vduTempStoreDE                                 ;
    STA (.vduTempStoreDA),Y                             ;

    ; Add width to current address
    LDY #.spriteHeaderOffsetWidth                       ; }
    SEC                                                 ; }
    LDA .vduTempStoreDA                                 ; }
    ADC (.currentSpriteDefinitionLow),Y                 ; }
    STA .vduTempStoreDA                                 ; } .vduTempStoreDA/DB += width
    LDA .vduTempStoreDB                                 ; }
    ADC #0                                              ; }
    STA .vduTempStoreDB                                 ; }

    PLA                                                 ; }  Recall loop counter (number of columns remaining to move)
    TAX                                                 ; }
    DEX                                                 ; decrement loop counter
    BNE .deleteColumnLoop                               ; loop back if not yet done

    JMP .seditDrawLargeAndRegularSpriteAndUpdateCursor  ;

; ***************************************************************************************
.createMaskByteForPixelsToTheRight
    LDA .seditCurrentVisibleByteMask                    ;
    STA .vduTempStoreDC                                 ; store current pixel mask
-
    ORA .vduTempStoreDC                                 ; } OR in the new value
    STA .vduTempStoreDC                                 ; }
    LSR                                                 ; shift right
    BCC -                                               ; loop until a set pixel is found

    LDA .vduTempStoreDC                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Reverse the pixels in the byte
;
; Used when mirroring vertically
;
; ***************************************************************************************
.reversePixelsInByteA
    LDY #0                                              ;
    STY .vduTempStoreDE                                 ;

    LDY .vduPixelsPerByteMinusOne                       ; loop counter
-
    ASL .vduTempStoreDE                                 ;
    PHA                                                 ; remember A
    AND .vduColourMaskRight                             ;
    ORA .vduTempStoreDE                                 ;
    STA .vduTempStoreDE                                 ;
    PLA                                                 ; recall A
    LSR                                                 ; shift A right
    DEY                                                 ;
    BPL -                                               ; loop back until done

    LDA .vduTempStoreDE                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Mirror sprite vertically
;
; ***************************************************************************************
.seditMirrorVertically
    CLC                                                 ;
    LDA .currentSpriteDefinitionLow                     ;
    ADC #5                                              ;
    STA .vduTempStoreDA                                 ;
    LDA .currentSpriteDefinitionHigh                    ;
    ADC #0                                              ;
    STA .vduTempStoreDB                                 ;

    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    CLC                                                 ;
    ADC #1                                              ;
    TAX                                                 ;
.mirrorVerticallyLoop
    CLC                                                 ; }
    LDY #.spriteHeaderOffsetWidth                       ; }
    LDA (.currentSpriteDefinitionLow),Y                 ; } A = sprite width - 1
    ADC #2                                              ; } A = sprite width + 1
    STA .vduTempStoreDD                                 ; }
    LSR                                                 ; }
    STA .vduTempStoreDC                                 ; }
    INC .vduTempStoreDD                                 ; } .vduTempStoreDC = (sprite width + 1)/2]
                                                        ;                   = byte left of centre point
                                                        ;                   = destination offset
    LSR .vduTempStoreDD                                 ; } .vduTempStoreDD = (sprite width + 2)/2
                                                        ;                   = byte right of centre point
                                                        ;                   = source offset

.mirrorRowLoop
    ; Swap two bytes, reversing the pixels in each byte also
    LDY .vduTempStoreDC                                 ;
    LDA (.vduTempStoreDA),Y                             ;
    JSR .reversePixelsInByteA                           ;
    PHA                                                 ; remember byte

    LDY .vduTempStoreDD                                 ;
    LDA (.vduTempStoreDA),Y                             ; read source byte
    JSR .reversePixelsInByteA                           ; reverse it

    LDY .vduTempStoreDC                                 ;
    STA (.vduTempStoreDA),Y                             ; store in destination

    PLA                                                 ; recall byte
    LDY .vduTempStoreDD                                 ;
    STA (.vduTempStoreDA),Y                             ; store in source

    INC .vduTempStoreDD                                 ;
    DEC .vduTempStoreDC                                 ;
    BNE .mirrorRowLoop                                  ;

    ; Add width to the current address
    SEC                                                 ; carry set, add one more than usual
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA .vduTempStoreDA                                 ;
    ADC (.currentSpriteDefinitionLow),Y                 ; add sprite width-1
    STA .vduTempStoreDA                                 ;
    BCC +                                               ;
    INC .vduTempStoreDB                                 ;
+

    DEX                                                 ; decrement loop counter
    BNE .mirrorVerticallyLoop                           ; loop back until done

    JMP .seditDrawLargeAndRegularSpriteAndUpdateCursor  ;

; ***************************************************************************************
;
; Mirror sprite horizontally
;
; ***************************************************************************************
.seditMirrorHorizontally
    CLC                                                 ; }
    LDA .currentSpriteDefinitionLow                     ; }
    STA .vduTempStoreDC                                 ; }
    ADC #5                                              ; } .vduTempStoreDC/DD = sprite definition address
    STA .vduTempStoreDA                                 ; } .vduTempStoreDA/DB = sprite definition address + 5
    LDA .currentSpriteDefinitionHigh                    ; }
    STA .vduTempStoreDD                                 ; }
    ADC #0                                              ; }
    STA .vduTempStoreDB                                 ; }

    JSR .moveToNextSprite                               ; move address to start of next sprite
    JSR .decTempStoreDCDD                               ; move address back one to be the last byte of the current sprite

    ; .vduTempStoreDC/DD -= sprite width
    CLC                                                 ; carry clear, subtract one more than normal
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA .vduTempStoreDC                                 ;
    SBC (.currentSpriteDefinitionLow),Y                 ;
    STA .vduTempStoreDC                                 ;
    BCS +                                               ;
    DEC .vduTempStoreDD                                 ;
+

    LDY #.spriteHeaderOffsetHeight                      ;
    LDA (.currentSpriteDefinitionLow),Y                 ; A = sprite height-1
    BEQ .skipMirrorVertically                           ; if (sprite has height 1) then branch

    CLC                                                 ;
    ADC #1                                              ;
    LSR                                                 ;
    TAX                                                 ; X = sprite height / 2 (loop counter)
.mirrorHorizontalMainLoop
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    TAY                                                 ;
    INY                                                 ; Y = sprite width (loop counter)

    ; Swap row in top half of sprite with row in bottom half of sprite
.mirrorRowHorizontalLoop
    LDA (.vduTempStoreDA),Y                             ;
    PHA                                                 ; remember byte from top half
    LDA (.vduTempStoreDC),Y                             ;
    STA (.vduTempStoreDA),Y                             ; byte in top half = byte in bottom half
    PLA                                                 ; recall original byte from top half
    STA (.vduTempStoreDC),Y                             ; store in bottom half
    DEY                                                 ; decrement loop counter
    BNE .mirrorRowHorizontalLoop                        ; loop back until done

    ; Add sprite width to top half of sprite address
    SEC                                                 ;
    LDY #.spriteHeaderOffsetWidth                       ;
    LDA .vduTempStoreDA                                 ;
    ADC (.currentSpriteDefinitionLow),Y                 ;
    STA .vduTempStoreDA                                 ;
    BCC +                                               ;
    INC .vduTempStoreDB                                 ;
+

    ; Subtract sprite width from bottom half address
    CLC                                                 ;
    LDA .vduTempStoreDC                                 ;
    SBC (.currentSpriteDefinitionLow),Y                 ;
    STA .vduTempStoreDC                                 ;
    BCS +                                               ;
    DEC .vduTempStoreDD                                 ;
+
    DEX                                                 ; loop counter
    BNE .mirrorHorizontalMainLoop                       ;

.skipMirrorVertically
    JMP .seditDrawLargeAndRegularSpriteAndUpdateCursor  ;

; ***************************************************************************************
.incTempStoreDADB
    INC .vduTempStoreDA                                 ;
    BNE .return2                                        ;
    INC .vduTempStoreDB                                 ;
.return2
    RTS                                                 ;

; ***************************************************************************************
.incTempStoreDCDD
    INC .vduTempStoreDC                                 ;
    BNE .return2                                        ;
    INC .vduTempStoreDD                                 ;
    RTS                                                 ;

; ***************************************************************************************
.decTempStoreDADB
    LDA .vduTempStoreDA                                 ;
    BNE +                                               ;
    DEC .vduTempStoreDB                                 ;
+
    DEC .vduTempStoreDA                                 ;
    RTS                                                 ;

; ***************************************************************************************
.decTempStoreDCDD
    LDA .vduTempStoreDC                                 ;
    BNE +                                               ;
    DEC .vduTempStoreDD                                 ;
+
    DEC .vduTempStoreDC                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Find the address of the given sprite
;
; On Entry:
;   A = sprite number to find
;
; On Exit:
;   (A,Y): vduTempStoreDC/DD = start of sprite
;   X: Sprite index (in the range 1 to number of sprites), or 0 for not found
;   Z Set and X = 0 if we ran out of sprites
;
; ***************************************************************************************
.findSpriteA
    PHA                                                 ; remember sprite number

    ; address = start of sprite page + 3
    LDY #.workspaceOffsetSpriteStartPage                ;
    LDA (.privateWorkspaceLow),Y                        ;
    STA .vduTempStoreDD                                 ; .vduTempStoreDD = sprite start page
    LDA #3                                              ;
    STA .vduTempStoreDC                                 ; .vduTempStoreDC = 3

    LDY #.workspaceOffsetNumberOfSprites                ;
    LDA (.privateWorkspaceLow),Y                        ;
    TAX                                                 ; X = number of sprites = loop counter
    BEQ +                                               ;

-
    LDY #5                                              ;
    PLA                                                 ;
    PHA                                                 ; recall and remember sprite number
    CMP (.vduTempStoreDC),Y                             ; have we reached the sprite we want?
    BEQ +                                               ; if (yes) then branch
    JSR .moveToNextSprite                               ; move .vduTempStoreDC/D to next sprite
    DEX                                                 ;
    BNE -                                               ; if (X != 0) then branch (loop back)

+
    PLA                                                 ; recall and discard the sprite number now
    LDA .vduTempStoreDC                                 ; }
    LDY .vduTempStoreDD                                 ; } get address in AY
    CPX #0                                              ; did we reach the end of the sprite list?
    RTS                                                 ;

; ***************************************************************************************
;
; Move address to the start of the next sprite
;
; On Entry:
;       .vduTempStoreDC/DD points to a sprite
; On Exit:
;       .vduTempStoreDC/DD points to the next sprite
;       Preserves X
;
; ***************************************************************************************
.moveToNextSprite
    CLC                                                 ; }
    LDY #2                                              ; }
    LDA (.vduTempStoreDC),Y                             ; }
    ADC .vduTempStoreDC                                 ; }
    PHA                                                 ; }
    INY                                                 ; }
    LDA (.vduTempStoreDC),Y                             ; }
    ADC .vduTempStoreDD                                 ; }
    STA .vduTempStoreDD                                 ; } .vduTempStoreDC/DD += size of sprite + 6
    PLA                                                 ; }
    ADC #6                                              ; } six is the size of the sprite header data
    STA .vduTempStoreDC                                 ; }
    BCC +                                               ; }
    INC .vduTempStoreDD                                 ; }
+
    RTS                                                 ;

; ***************************************************************************************
;
; Get the amount of free space remaining in the sprite data
;
; On Exit:
;   .vduTempStoreDE/DF holds the free space in bytes
;   .vduTempStoreDC/DD holds the end of used sprite memory address
;   Preserves A,X,Y
;
; ***************************************************************************************
.getFreeSpace
    PHA                                                 ; }
    TXA                                                 ; }
    PHA                                                 ; } store A,X,Y
    TYA                                                 ; }
    PHA                                                 ; }

    LDY #.workspaceOffsetSpriteStartPage                ; }
    LDA (.privateWorkspaceLow),Y                        ; }
    STA .vduTempStoreDD                                 ; } .vduTempStoreDC/DD = sprite page start + 3
    LDA #3                                              ; }                    = initial space used
    STA .vduTempStoreDC                                 ; }

    LDY #.workspaceOffsetNumberOfSprites                ;
    LDA (.privateWorkspaceLow),Y                        ; get number of sprites
    BEQ +                                               ; if (no sprites) then branch
    TAX                                                 ; X = number of sprites = loop counter

-
    JSR .moveToNextSprite                               ;
    DEX                                                 ;
    BNE -                                               ; if (not done yet) then branch back

+
    SEC                                                 ;
    LDY #.workspaceOffsetSpriteEndPage                  ;
    LDA #0                                              ;
    SBC .vduTempStoreDC                                 ;
    STA .vduTempStoreDE                                 ;
    LDA (.privateWorkspaceLow),Y                        ; free space = total space - space used
    SBC .vduTempStoreDD                                 ;
    STA .vduTempStoreDF                                 ;

    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } recall A,X,Y
    TAX                                                 ; }
    PLA                                                 ; }
    RTS                                                 ;

; ***************************************************************************************
;
; Skips past any spaces on the command line
;
; On Entry:
;   (X,Y): address of the current position in the command line
;
; On Exit:
;   (X,Y): address of the rest of the command line
;
; ***************************************************************************************
.skipLeadingSpaces
    STX .privateWorkspaceLow                            ; }
    STY .privateWorkspaceHigh                           ; } store pointer to remainder of user input string
    LDY #0                                              ;
.skipSpaces
    LDA (.privateWorkspaceLow),Y                        ;
    CMP #' '                                            ;
    BNE .nonSpace                                       ;
    INC .privateWorkspaceLow                            ;
    BNE .skipSpaces                                     ;
    INC .privateWorkspaceHigh                           ;
    JMP .skipSpaces                                     ;

.nonSpace
    LDX .privateWorkspaceLow                            ; }
    LDY .privateWorkspaceHigh                           ; } set XY to the remainder of the user input string
    JMP .getPrivateWorkspaceAddress                     ; get proper workspace address

; ***************************************************************************************
;
; Read 8 bit number from user input string into A
;
; On Exit:
;       XY = address of remainder of user input string
;       A = .vduTempStoreDE = 8 bit value read
;
; ***************************************************************************************
.read8BitNumberIntoA
    JSR .skipLeadingSpaces                              ;

    STX .privateWorkspaceLow                            ; } workspace address is set to current
    STY .privateWorkspaceHigh                           ; } position in user input string
    LDY #0                                              ;
    STY .vduTempStoreDE                                 ; result = 0
    LDA (.privateWorkspaceLow),Y                        ; get next character
    SEC                                                 ;
    SBC #'0'                                            ; convert ASCII digit to value 0-9
    CMP #10                                             ;
    BCS .badNumberError                                 ; if (10 or more) then branch (bad number)

-
    ; Multiply the existing result by 10
    TAX                                                 ; X = digit
    ASL .vduTempStoreDE                                 ; } .vduTempStoreDE *= 2
    BCS .badNumberError                                 ; }
    LDA .vduTempStoreDE                                 ; }
    ASL                                                 ; }
    BCS .badNumberError                                 ; }
    ASL                                                 ; } A = .vduTempStoreDE * 4
    BCS .badNumberError                                 ; }
    ADC .vduTempStoreDE                                 ; } A += .vduTempStoreDE
    STA .vduTempStoreDE                                 ; } .vduTempStoreDE = A = .vduTempStoreDE * 10
    BCS .badNumberError                                 ; }

    ; Add the digit in X to the result
    TXA                                                 ; }
    ADC .vduTempStoreDE                                 ; } .vduTempStoreDE += digit
    STA .vduTempStoreDE                                 ; }

    ; Branch if overflow occurs
    BCS .badNumberError                                 ;

    ; Move to next digit
    INC .privateWorkspaceLow                            ;
    BNE +                                               ;
    INC .privateWorkspaceHigh                           ;
+
    ; Read the next digit
    LDA (.privateWorkspaceLow),Y                        ;
    SEC                                                 ;
    SBC #'0'                                            ;
    CMP #10                                             ;
    BCC -                                               ; branch back if there is another digit

    ; Get result in A, and XY is the address of the rest of the command
    LDA .vduTempStoreDE                                 ;
    LDX .privateWorkspaceLow                            ;
    LDY .privateWorkspaceHigh                           ;
    JMP .getPrivateWorkspaceAddress                     ;

; ***************************************************************************************
.badNumberError
    JSR .generateError                                  ;
    !byte $89                                           ; error number
    !text "Bad number",0                                ; error message

; ***************************************************************************************
;
; PLOT X,
;
; On Entry:
;   X: plot number
;
; ***************************************************************************************
.plotX
    LDA #$19                                            ; }
    JSR .OSWRCH                                         ; }
    TXA                                                 ; } VDU 25,X, = PLOT X,
    JMP .OSWRCH                                         ; }

; ***************************************************************************************
;
; VDU plotPointX;
;
; ***************************************************************************************
.seditOutputXCoordinate
    LDA .plotPointXLow                                  ;
    JSR .OSWRCH                                         ;
    LDA .plotPointXHigh                                 ;
    JMP .OSWRCH                                         ;

; ***************************************************************************************
;
; VDU plotPointY;
;
; ***************************************************************************************
.seditOutputYCoordinate
    LDA .plotPointYLow                                  ;
    JSR .OSWRCH                                         ;
    LDA .plotPointYHigh                                 ;
    JMP .OSWRCH                                         ;

; ***************************************************************************************
;
; GCOL X,Y
;
; On Entry:
;   X: GCOL mode
;   Y: GCOL logical colour
;
; ***************************************************************************************
.gcolXY
    LDA #$12                                            ; }
    JSR .OSWRCH                                         ; }
    TXA                                                 ; }
    JSR .OSWRCH                                         ; } VDU 18,X,Y = GCOL X,Y
    TYA                                                 ; }
    JMP .OSWRCH                                         ; }

; ***************************************************************************************
;
; 8 bit unsigned multiply, 16 bit result
;
; On Entry:
;   X = multiplicand
;   Y = multiplier
; On Exit:
;   vduTempStoreDE/DF: product (16 bit)
;
; ***************************************************************************************
.multiply8x8
    LDA #0                                              ;
    STA .vduTempStoreDF                                 ; clear high byte of product
    TYA                                                 ;
    LSR                                                 ; shift multiplier and first bit into carry
    STA .vduTempStoreDE                                 ; store multiplier as low byte of product
    LDY #8                                              ; loop counter
.multiply8x8Loop
    BCC +                                               ; skip if bit clear

    CLC                                                 ; add multiplicand (=X) to high byte of product
    TXA                                                 ;
    ADC .vduTempStoreDF                                 ;
    STA .vduTempStoreDF                                 ;
+
    ROR .vduTempStoreDF                                 ; shift product
    ROR .vduTempStoreDE                                 ;
    DEY                                                 ;
    BNE .multiply8x8Loop                                ; loop 8 times

    RTS                                                 ;

; ***************************************************************************************
;
; Print sprite details (in editor)
;
; ***************************************************************************************
.seditPrintModeMessage
    JSR .printInlineCounted                             ;
    !byte 6                                             ; length of message to print
    !text .charHomeCursor, "Mode "                      ;
    LDA .vduCurrentScreenMODE                           ; }
    JSR .printNumberA                                   ; } Print current screen MOE

    JSR .printInlineCounted                             ;
    !byte 9                                             ; length of message to print
    !text .charCR,.charLF,"Sprite "                     ;
    LDY #5                                              ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    JSR .printNumberA                                   ;

    JSR .printInlineCounted                             ;
    !byte 4                                             ; length of message to print
    !text .charMoveCursor,11,1,"["                      ; PRINT;TAB(11,1);"[";
    CLC                                                 ;
    LDY #0                                              ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    ADC #1                                              ;
    JSR .printNumberA                                   ;

    LDA #','                                            ;
    JSR .OSWRCH                                         ;

    CLC                                                 ;
    LDY #1                                              ;
    LDA (.currentSpriteDefinitionLow),Y                 ;
    ADC #1                                              ;
    JSR .printNumberA                                   ;

    JSR .printInlineCounted                             ;
    !byte 5                                             ; length of message to print
    !text "] ",.charMoveCursor,0,2                      ; PRINT;"]";TAB(0,2);

    LDY #.workspaceOffsetOptions                        ;
    LDA (.privateWorkspaceLow),Y                        ;
    LSR                                                 ;
    BCC +                                               ; if (bit 0 of options clear) then branch

    LDA #'D'                                            ; pen is DOWN
    BNE ++                                              ;

+
    LDA #'U'                                            ; pen is UP
++
    JSR .OSWRCH                                         ;

    JSR .printInlineCounted                             ;
    !byte 2                                             ; length of message to print
    !text " ",.charDefineTextColour                     ;

    CLC                                                 ;
    LDA .seditBackgroundColour                          ;
    ADC #$80                                            ;
    JSR .OSWRCH                                         ; set text background colour

    JSR .printInlineCounted                             ;
    !byte 7                                             ; length of message to print
    !text ' '                                           ; space
    !text .charDefineTextColour,$80                     ; change background colour to black
    !text .charMoveCursor,11,2,"("                      ; PRINT;TAB(11,2);"(";

    CLC                                                 ;
    LDA .seditCurrentVisibleX                           ;
    ADC .seditCurrentX                                  ;
    JSR .printNumberA                                   ; print cursor X position

    LDA #','                                            ;
    JSR .OSWRCH                                         ; PRINT;",";

    CLC                                                 ;
    LDA .seditCurrentVisibleY                           ;
    ADC .seditCurrentY                                  ;
    JSR .printNumberA                                   ; print cursor Y position

    JSR .printInlineCounted                             ;
    !byte 6                                             ; length of message to print
    !text ")  ",.charMoveCursor,0,4                     ; PRINT;TAB(0,4);
    RTS                                                 ;

; ***************************************************************************************
;
; Print the 8 bit number in A
;
; ***************************************************************************************
.printNumberA
    LDX #0                                              ;
    ; fall through...

; ***************************************************************************************
;
; Print the 16 bit number in XA
;
; ***************************************************************************************
.printNumberXA
    LDY #0                                              ;
    STY .tempNumberPrintedFlag                          ; 'have we printed a digit yet?' flag
    STA .tempNumberToPrintLow                           ; number (low)
    STX .tempNumberToPrintHigh                          ; number (high)
    ORA .tempNumberToPrintHigh                          ;
    BEQ .printDigitY                                    ; if (number is zero) then branch

    LDX #0                                              ; pointer to table of powers of ten
                                                        ; X is twice the number of digits handled so far
.digitLoop
    LDY #0                                              ; counter for current digit
.subtractionLoop
    INY                                                 ;
    LDA .tempNumberToPrintLow                           ; }
    SEC                                                 ; }
    SBC .powersOfTenTable,X                             ; }
    STA .tempNumberToPrintLow                           ; } A8/A9 -= power of ten for current digit
    LDA .tempNumberToPrintHigh                          ; }
    SBC .powersOfTenTable + 1,X                         ; }
    STA .tempNumberToPrintHigh                          ; }
    BCC .doneSubtraction                                ; }
    JMP .subtractionLoop                                ;

.printDigitY
    TYA                                                 ; }
    CLC                                                 ; } convert to ASCII digit
    ADC #$30                                            ; }
    JMP .OSWRCH                                         ; print digit

.doneSubtraction
    LDA .tempNumberToPrintLow                           ; }
    CLC                                                 ; }
    ADC .powersOfTenTable,X                             ; }
    STA .tempNumberToPrintLow                           ; } add power of ten for current digit
    LDA .tempNumberToPrintHigh                          ; }
    ADC .powersOfTenTable + 1,X                         ; }
    STA .tempNumberToPrintHigh                          ; }
    DEY                                                 ;
    BNE +                                               ; if (digit is not zero) then branch

    LDA .tempNumberPrintedFlag                          ;
    BEQ .moveToNextDigit                                ; if (we have not printed a digit yet) then branch

+
    LDA #$FF                                            ;
    STA .tempNumberPrintedFlag                          ; mark flag to say that a digit is printed
    JSR .printDigitY                                    ; print the digit

.moveToNextDigit
    INX                                                 ;
    INX                                                 ;
    TXA                                                 ;
    CMP #10                                             ;
    BEQ +                                               ;
    JMP .digitLoop                                      ;
+
    RTS                                                 ;

; ***************************************************************************************
.powersOfTenTable
    !word 10000                                         ;
    !word 1000                                          ;
    !word 100                                           ;
    !word 10                                            ;
    !word 1                                             ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 23: Ellipse
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Ellipse, outline and filled
;
; See ellipse.png
;
; ***************************************************************************************

; ***************************************************************************************
.plotEllipseOutline
    JSR .ellipseInitialisation                          ;
    JMP .startEllipseOutline                            ;

.ellipseOutlineLoop
    JSR .updateEllipseIncrementally                     ; move to next pixel around ellipse
.startEllipseOutline
    ; sort coordinates to find the rightmost one
    LDX #.ellipsePointCLow - .vduVariablesStart         ;
    LDY #.ellipsePointALow - .vduVariablesStart         ;
    JSR .sortCoordinatesXYByColumn                      ; Y is the rightmost point of .ellipsePointC and .ellipsePointA

    LDX #.ellipseLeftPointLow - .vduVariablesStart            ; [NOTE: Redundant, as we load X again below]

    ; plot row of pixels from left point .ellipseLeftPoint to rightmost point vdu[Y,Y+1]
    LDA .ellipseLeftPointHigh                           ;
    STA .ellipseCurrentOffsetXHigh                      ;
    LDX .ellipseLeftPointLow                            ;

.ellipseOutlineContinueRowLoop
    STX .ellipseCurrentOffsetXLow                       ;
    JSR .outlineEllipsePlotOnePointAndReflection        ;

    ; Increment (X,.ellipseCurrentOffsetXHigh)
    INX                                                 ;
    BNE +                                               ;
    INC .ellipseCurrentOffsetXHigh                      ;
+

    ; If (X,.ellipseCurrentOffsetXHigh) has NOT reached the rightmost point of the row, then branch back
    TXA                                                 ; }
    CMP .vduVariablesStart,Y                            ; }
    LDA .ellipseCurrentOffsetXHigh                      ; } compare (X,ellipseCurrentOffsetXHigh) with rightmost point on row
    SBC .vduVariablesStart+1,Y                          ; }
    BMI .ellipseOutlineContinueRowLoop                  ;

    ; move back one pixel left
    LDY .ellipseCurrentOffsetXHigh                      ;
    TXA                                                 ; }
    BNE +                                               ; }
    DEY                                                 ; } XY--
+                                                       ; }
    DEX                                                 ; }

    ; store rightmost pixel on row
    STX .ellipsePointCLow                               ;
    STY .ellipsePointCHigh                              ;

    ; Compare XY against .ellipseRightPoint
    TXA                                                 ; }
    CMP .ellipseRightPointLow                           ; }
    TYA                                                 ; } if (XY >= .ellipseRightPoint) then branch forward
    SBC .ellipseRightPointHigh                          ; }
    BPL .ellipseOutlineCheckIfDone                      ; }

    ; Sort three values left to right
    LDX #.ellipsePointDLow - .vduVariablesStart         ;
    LDY #.ellipsePointBLow - .vduVariablesStart         ;
    JSR .sortCoordinatesXYByColumn                      ;

    LDY #.ellipsePointCLow - .vduVariablesStart         ;
    JSR .sortCoordinatesXYByColumn                      ; Y is the rightmost point of
                                                        ; .ellipsePointB, .ellipsePointD, and .ellipsePointC

    ; plot row of pixels from rightmost point .ellipseRightPoint to leftmost point vdu[Y,Y+1]
    ; (X,.ellipseCurrentOffsetXHigh) = .ellipseRightPoint
    LDA .ellipseRightPointHigh                          ;
    STA .ellipseCurrentOffsetXHigh                      ;
    LDA .ellipseRightPointLow                           ;
    TAX                                                 ;

.ellipseOutlineContinueRowLoop2
    STX .ellipseCurrentOffsetXLow                       ;
    JSR .outlineEllipsePlotOnePointAndReflection        ;

    ; Decrement (X,.ellipseCurrentOffsetXHigh)
    TXA                                                 ;
    BNE +                                               ;
    DEC .ellipseCurrentOffsetXHigh                      ;
+                                                       ;
    DEX                                                 ;

    ; If (X,.ellipseCurrentOffsetXHigh) has NOT reached the rightmost point of the row, then branch back
    CLC                                                 ;
    TXA                                                 ;
    SBC .vduVariablesStart,Y                            ;
    LDA .ellipseCurrentOffsetXHigh                      ;
    SBC .vduVariablesStart+1,Y                          ;
    BPL .ellipseOutlineContinueRowLoop2                 ;

.ellipseOutlineCheckIfDone
    LDA .ellipseHalfHeightCounterHigh                   ;
    BPL .ellipseOutlineLoop                             ; if (not finished) then branch back
    JMP .finishEllipseLastRow                           ;

; ***************************************************************************************
;
; Plot a filled ellipse
;
; ***************************************************************************************
.plotEllipseFilled
    JSR .ellipseInitialisation                          ;
    JMP .startFilledEllipse                             ;

.filledEllipseLoop
    JSR .updateEllipseIncrementally                     ; move to next row

.startFilledEllipse
    LDX #.ellipseRightPointLow - .vduVariablesStart     ;
    LDY #.ellipseLeftPointLow - .vduVariablesStart      ;
    JSR .fillEllipseOneRowAndReflection                 ;

    LDA .ellipseHalfHeightCounterHigh                   ;
    BPL .filledEllipseLoop                              ;

.finishEllipseLastRow
    ; Increment height counter
    INC .ellipseCountHeightLow                          ;
    BNE +                                               ;
    INC .ellipseCountHeightHigh                         ;
+

    ; Plot final row
    LDX #.ellipsePointBLow - .vduVariablesStart         ;
    LDY #.ellipsePointALow - .vduVariablesStart         ;
    JSR .fillEllipseOneRowAndReflection                 ;

    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Handles the special case of a zero height ellipse
;
; Draws a single row
;
; ***************************************************************************************
.zeroHeightEllipse
    PLA                                                 ; take values off call stack to
    PLA                                                 ; end the ellipse routine early

    ; Plot one row
    LDA #0                                              ;
    STA .ellipseCountHeightLow                          ;
    STA .ellipseCountHeightHigh                         ;
    LDX #.ellipse256AspectRatioMid - .vduVariablesStart ;
    LDY #.ellipsePointELow - .vduVariablesStart            ; where to put results
    JSR .negateVDUVariableXIntoY                        ; .ellipsePointE = -.ellipse256AspectRatioMid/High

    LDX #.ellipse256AspectRatioMid - .vduVariablesStart ;
    LDY #.vduWorkspaceCC - .vduVariablesStart           ; where to put results
    JSR .copyTwoBytesWithinVDUVariables                 ; .vduWorkspaceCC/DD = .ellipse256AspectRatioMid/High

    LDX #.vduWorkspaceCC - .vduVariablesStart           ; use results
    LDY #.ellipsePointELow - .vduVariablesStart         ; use results
    JSR .fillEllipseOneRowAndReflection                 ; plot one row

    ; Finish up
    JMP .setGraphicsCursorPositionAndFinishPLOT         ;

; ***************************************************************************************
;
; Ellipse initialisation
;
; Initialise variables for the ellipse routine.
; If the height of the ellipse is zero, we call a separate routine to draw the single
; row required, then manipulate the stack to early out of the ellipse routine altogether.
;
; .ellipseHalfHeight        = abs(top of ellipse Y - centreY)
; .ellipse256Shear          = 256*abs(top of ellipse X - centreX) / half height
; .ellipse256AspectRatio    = 256*abs(point on X axis - centreX) / half height
; .ellipseHalfHeightSquared = (half height) ^ 2
; .ellipseAccumulatedShear  = 0
; .ellipseCountOddNumbers   = 1
; .ellipseCountSquares      = 0
; JSR .updateEllipse
; JSR .updateEllipse
; .ellipseCountHeight       = 0
; .ellipsePointD            = -.ellipsePointA
; .ellipsePointC            = -.ellipsePointB
;
; if (.ellipseRightPoint < .ellipsePointA) {
;     .ellipseRightPoint = .ellipsePointA
;     .ellipseLeftPoint  = .ellipsePointD
; } else if (.ellipseLeftPoint > .ellipsePointB) {
;     .ellipseLeftPoint  = .ellipsePointB
;     .ellipseRightPoint = .ellipsePointC
; }
;
; ***************************************************************************************
.ellipseInitialisation
    ; Calculate 256 * abs(width of ellipse on centre row)
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart      ; X point on ellipse on centre row
    LDX #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; centre of ellipse X
    LDA #.ellipse256AspectRatioMid - .vduVariablesStart         ; where to put results
    JSR .absDifference16                                        ;
    LDA #0                                                      ;
    STA .ellipse256AspectRatioLow                               ;

    ; Calculate half-height (distance from centre Y to top Y)
    LDY #.vdu25ParameterYLow - .vduVariablesStart               ; top Y
    LDX #.vduOldGraphicsCursorPixelsYLow - .vduVariablesStart   ; centre Y
    LDA #.ellipseHalfHeightCounterLow - .vduVariablesStart      ; where to put results
    JSR .absDifference16                                        ;
    ; (carry set if height was negative)

    ; Check for special case of a zero height ellipse
    LDA .ellipseHalfHeightCounterLow                    ;
    ORA .ellipseHalfHeightCounterHigh                   ;
    BEQ .zeroHeightEllipse                              ; if height == 0, branch

    ; Remember sign (about to do signed divides)
    LDA #0                                              ;
    ROL                                                 ;
    STA .ellipseSignFlag                                ; 1 if sign of height was negative, 0 otherwise

    ; shear = 256 * abs(topX - centreX)
    LDY #.vdu25ParameterXLow - .vduVariablesStart               ; top of ellipse X
    LDX #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; centre X
    LDA #.ellipse256ShearMid - .vduVariablesStart       ; where to put results
    JSR .absDifference16                                ; .ellipse256ShearMid/High = abs(top of ellipse X - centreX)
    ; (carry set if height was negative)
    LDA #0                                              ;
    STA .ellipse256ShearLow                             ;

    ; Work out if signs differ
    ROL                                                 ;
    EOR .ellipseSignFlag                                ;
    STA .ellipseSignFlag                                ; store 1 if signs are different, 0 otherwise

    ; .ellipse256AspectRatioLow /= half-height
    LDX #.ellipse256AspectRatioLow - .vduVariablesStart     ;
    LDY #.ellipseHalfHeightCounterLow - .vduVariablesStart  ; divide by half-height
    JSR .divide24by16bits                                   ;

    LDX #.ellipse256ShearLow - .vduVariablesStart           ;
    LDY #.ellipseHalfHeightCounterLow - .vduVariablesStart  ; divide by half-height to get shear
    JSR .divide24by16bits                                   ;

    ; Check if signs were different
    LDA .ellipseSignFlag                                ;
    BEQ .signsNotDifferent                              ;

    ; Signs are different, negate shear
    SEC                                                 ;
    LDY #$FD                                            ;
.negateLoop
    LDA #0                                              ;
    SBC .ellipse256ShearLow - $FD,Y                     ;
    STA .ellipse256ShearLow - $FD,Y                     ; negate shear
    INY                                                 ;
    BNE .negateLoop                                     ;

.signsNotDifferent
    ; .gxrTemp4567 = .ellipseHalfHeightCounter ^ 2
    LDA .ellipseHalfHeightCounterLow                    ;
    STA .gxrTemp1                                       ;
    LDA .ellipseHalfHeightCounterHigh                   ;
    STA .gxrTemp2                                       ;
    JSR .square12_into4567                              ;

    ; This loop copies the result: .ellipseHalfHeightSquared = .gxrTemp4567
    LDY #3                                              ;
-
    LDA .gxrTemp4,Y                                     ;
    STA .ellipseHalfHeightSquaredLow,Y                  ;
    DEY                                                 ;
    BPL -                                               ;

    ; Reset 11 variables from .ellipseAccumulatedShearLow to circleN
    LDY #$0A                                            ;
    LDA #0                                              ;
-
    STA .ellipseAccumulatedShearLow,Y                   ;
    DEY                                                 ;
    BPL -                                               ;

    INC .ellipseCountOddNumbersLow                      ; .ellipseCountOddNumbers = 1

    JSR .updateEllipse                                  ;
    JSR .updateEllipse                                  ;

    ; .ellipseCountHeight = 0
    LDA #0                                              ;
    STA .ellipseCountHeightLow                          ;
    STA .ellipseCountHeightHigh                         ;

    ; .ellipsePointD = -.ellipsePointA
    LDX #.ellipsePointALow - .vduVariablesStart         ;
    LDY #.ellipsePointDLow - .vduVariablesStart         ;
    JSR .negateVDUVariableXIntoY                        ;

    ; .ellipsePointC = -.ellipsePointB
    LDX #.ellipsePointBLow - .vduVariablesStart         ;
    LDY #.ellipsePointCLow - .vduVariablesStart         ;
    JSR .negateVDUVariableXIntoY                        ;

    ; Which is leftmost: .ellipseRightPoint or .ellipsePointA
    LDY #.ellipseRightPointLow - .vduVariablesStart     ;
    LDX #.ellipsePointALow - .vduVariablesStart         ;
    JSR .sortCoordinatesXYByColumn                      ;

    CPY #.ellipseRightPointLow - .vduVariablesStart     ;
    BEQ .sortOtherValues                                ; if (.ellipseRightPoint >= .ellipsePointA) then branch

    ; .ellipsePointA is rightmost
    ; .ellipseRightPoint = .ellipsePointA
    LDX #.ellipsePointALow - .vduVariablesStart         ;
    LDY #.ellipseRightPointLow - .vduVariablesStart     ;
    JSR .copyTwoBytesWithinVDUVariables                 ;

    ; ellipseLeftPoint = .ellipsePointD
    LDX #.ellipsePointDLow - .vduVariablesStart         ;
    LDY #.ellipseLeftPointLow - .vduVariablesStart      ;
    JMP .copyTwoBytesWithinVDUVariables                 ;


.sortOtherValues
    ; Which is leftmost: ellipseLeftPoint or .ellipsePointB
    LDX #.ellipseLeftPointLow - .vduVariablesStart      ;
    LDY #.ellipsePointBLow - .vduVariablesStart         ;
    JSR .sortCoordinatesXYByColumn                      ;

    CPX #.ellipseLeftPointLow - .vduVariablesStart      ;
    BEQ .return31                                       ; if (.ellipseLeftPoint <= .ellipsePointB) then branch (return)

    ; .ellipsePointB is leftmost
    ; .ellipseLeftPoint = .ellipsePointB
    LDX #.ellipsePointBLow - .vduVariablesStart         ;
    LDY #.ellipseLeftPointLow - .vduVariablesStart      ;
    JSR .copyTwoBytesWithinVDUVariables                 ;

    ; .ellipseRightPoint = .ellipsePointC
    LDX #.ellipsePointCLow - .vduVariablesStart         ;
    LDY #.ellipseRightPointLow - .vduVariablesStart     ;
    JMP .copyTwoBytesWithinVDUVariables                 ;

.return31
    RTS                                                 ;

; ***************************************************************************************
.updateEllipseIncrementally
    JSR .updateEllipse                                  ;

    ; Work out which is leftmost: .ellipseRightPoint or .ellipsePointA
    LDY #.ellipseRightPointLow - .vduVariablesStart     ;
    LDX #.ellipsePointALow - .vduVariablesStart         ;
    JSR .sortCoordinatesXYByColumn                      ;

    CPY #.ellipseRightPointLow - .vduVariablesStart     ;
    BEQ .checkOtherVariables                            ; if (.ellipsePointA is more left than .ellipseRightPoint) then branch

    ; .ellipseRightPoint = .ellipsePointA (the leftmost point)
    LDA .ellipsePointALow                               ;
    STA .ellipseRightPointLow                           ;
    LDA .ellipsePointAHigh                              ;
    STA .ellipseRightPointHigh                          ;
    RTS                                                 ;

.checkOtherVariables
    ; Work out which is leftmost: .ellipseLeftPoint or .ellipsePointBLow
    LDX #.ellipseLeftPointLow - .vduVariablesStart      ;
    LDY #.ellipsePointBLow - .vduVariablesStart         ;
    JSR .sortCoordinatesXYByColumn                      ;
    CPX #.ellipseLeftPointLow - .vduVariablesStart      ;
    BEQ .return30                                       ; if (.ellipseLeftPoint is more left than .ellipsePointB) then branch

    ; .ellipseLeftPoint = .ellipsePointB (the leftmost point)
    LDA .ellipsePointBLow                               ;
    STA .ellipseLeftPointLow                            ;
    LDA .ellipsePointBHigh                              ;
    STA .ellipseLeftPointHigh                           ;
.return30
    RTS                                                 ;

; ***************************************************************************************
;
; Update the current position to the next pixel around the ellipse
;
; .ellipsePointC             = .ellipseLeftPoint
; .ellipsePointD             = .ellipseRightPoint
; .ellipseLeftPoint          = .ellipsePointA
; .ellipseRightPoint         = .ellipsePointB
; .sqrtNumber012345          = 65536*(.ellipseHalfHeightSquared - .ellipseCountSquares)
; .product0123               = .ellipse256AspectRatioLow * SQRT(.sqrtNumber012345)
; .ellipsePointB             = (.ellipseAccumulatedShear + .product123) / 65536   (rounded to nearest)
; .ellipsePointA             = (.ellipseAccumulatedShear - .product123) / 65536   (rounded to nearest)
; .ellipseCountSquares      += .ellipseCountOddNumbers
; .ellipseCountOddNumbers   += 2
; .ellipseAccumulatedShear  += .ellipse256Shear
; .ellipseCountHeight       += 1
; .ellipseHalfHeightCounter -= 1
;
; ***************************************************************************************
.updateEllipse
    ; .ellipsePointC     = .ellipseLeftPoint
    ; .ellipsePointD     = .ellipseRightPoint
    LDX #.ellipseLeftPointLow - .vduVariablesStart      ;
    LDY #.ellipsePointCLow - .vduVariablesStart         ; where to put result
    JSR .copyFourBytesWithinVDUVariables                ;

    ; .ellipseLeftPoint  = .ellipsePointA
    ; .ellipseRightPoint = .ellipsePointB
    LDX #.ellipsePointALow - .vduVariablesStart         ;
    LDY #.ellipseLeftPointLow - .vduVariablesStart      ; where to put result
    JSR .copyFourBytesWithinVDUVariables                ;

    ; .sqrtNumber012345  = 65536*(.ellipseHalfHeightSquared - .ellipseCountSquares)
    SEC                                                 ;
    LDA .ellipseHalfHeightSquaredLow                    ;
    SBC .ellipseCountSquaresLow                         ;
    STA .sqrtNumber2                                    ;
    LDA .ellipseHalfHeightSquaredMid1                   ;
    SBC .ellipseCountSquaresMid1                        ;
    STA .sqrtNumber3                                    ;
    LDA .ellipseHalfHeightSquaredMid2                   ;
    SBC .ellipseCountSquaresMid2                        ;
    STA .sqrtNumber4                                    ;
    LDA .ellipseHalfHeightSquaredHigh                   ;
    SBC .ellipseCountSquaresHigh                        ;
    STA .sqrtNumber5                                    ;
    LDA #0                                              ; }
    STA .sqrtNumber1                                    ; } two lowest bytes are zero
    STA .sqrtNumber0                                    ; }

    JSR .sqrt48                                         ; .sqrtResult012 = SQRT(.sqrtNumber012345)

    LDA .ellipse256AspectRatioLow                       ;
    STA .multiplier0                                    ;
    LDA .ellipse256AspectRatioMid                       ;
    STA .multiplier1                                    ;
    LDA .ellipse256AspectRatioHigh                      ;
    STA .multiplier2                                    ;
    JSR .multiply24x24                                  ; .product0123 = .ellipse256AspectRatio * .sqrtResult012

    ; .ellipsePointB = (.ellipseAccumulatedShear + .product123) / 65536   (round to nearest)
    CLC                                                 ;
    LDA .ellipseAccumulatedShearLow                     ;
    ADC .product1                                       ;
    PHP                                                 ;
    LDA .ellipseAccumulatedShearMid                     ;
    ADC .product2                                       ;
    STA .ellipsePointBLow                               ;
    LDA .ellipseAccumulatedShearHigh                    ;
    ADC .product3                                       ;
    STA .ellipsePointBHigh                              ;

    ; Round up if fraction has top bit set
    PLP                                                 ;
    BPL +                                               ;
    ; Increment .ellipsePointB
    INC .ellipsePointBLow                               ;
    BNE +                                               ;
    INC .ellipsePointBHigh                              ;
+

    ; .ellipsePointA = (.ellipseAccumulatedShear - .product123) / 65536   (rounding to nearest integer)
    SEC                                                 ;
    LDA .ellipseAccumulatedShearLow                     ;
    SBC .product1                                       ;
    PHP                                                 ;
    LDA .ellipseAccumulatedShearMid                     ;
    SBC .product2                                       ;
    STA .ellipsePointALow                               ;
    LDA .ellipseAccumulatedShearHigh                    ;
    SBC .product3                                       ;
    STA .ellipsePointAHigh                              ;

    ; Round up if fraction has top bit set
    PLP                                                 ;
    BPL +                                               ;
    ; Increment .ellipsePointA
    INC .ellipsePointALow                               ;
    BNE +                                               ;
    INC .ellipsePointAHigh                              ;
+

    ; .ellipseCountSquares += .ellipseCountOddNumbers
    CLC                                                 ;
    LDA .ellipseCountOddNumbersLow                      ;
    ADC .ellipseCountSquaresLow                         ;
    STA .ellipseCountSquaresLow                         ;
    LDA .ellipseCountOddNumbersMid1                     ;
    ADC .ellipseCountSquaresMid1                        ;
    STA .ellipseCountSquaresMid1                        ;
    LDA .ellipseCountOddNumbersMid2                     ;
    ADC .ellipseCountSquaresMid2                        ;
    STA .ellipseCountSquaresMid2                        ;
    LDA .ellipseCountOddNumbersHigh                     ;
    ADC .ellipseCountSquaresHigh                        ;
    STA .ellipseCountSquaresHigh                        ;

    ; ..ellipseCountOddNumbers += 2
    CLC                                                 ;
    LDA #2                                              ;
    ADC .ellipseCountOddNumbersLow                      ;
    STA .ellipseCountOddNumbersLow                      ;
    BCC +                                               ;
    INC .ellipseCountOddNumbersMid1                     ;
    BNE +                                               ;
    INC .ellipseCountOddNumbersMid2                     ;
    BNE +                                               ;
    INC .ellipseCountOddNumbersHigh                     ;
+

    ; .ellipseAccumulatedShear += .ellipse256Shear
    CLC                                                 ;
    LDA .ellipseAccumulatedShearLow                     ;
    ADC .ellipse256ShearLow                             ;
    STA .ellipseAccumulatedShearLow                     ;
    LDA .ellipseAccumulatedShearMid                     ;
    ADC .ellipse256ShearMid                             ;
    STA .ellipseAccumulatedShearMid                     ;
    LDA .ellipseAccumulatedShearHigh                    ;
    ADC .ellipse256ShearHigh                            ;
    STA .ellipseAccumulatedShearHigh                    ;

    ; Increment current height
    INC .ellipseCountHeightLow                          ;
    BNE +                                               ;
    INC .ellipseCountHeightHigh                         ;
+

    ; Decrement .ellipseHalfHeight
    LDA .ellipseHalfHeightCounterLow                    ;
    BNE +                                               ;
    DEC .ellipseHalfHeightCounterHigh                   ;
+                                                       ;
    DEC .ellipseHalfHeightCounterLow                    ;

    RTS                                                 ;

; ***************************************************************************************
;
; Draws one point of an outline ellipse, and also its reflection
;
; Point is reflected through the centre point.
;
; On Entry:
;   .ellipseCountHeight: the vertical distance from the centre of the ellipse
;   X,Y preserved
;
; ***************************************************************************************
.outlineEllipsePlotOnePointAndReflection
    STY .ellipseTempY                                   ; remember Y = VDU variable
    STX .ellipseTempX                                   ;          X = VDU variable

    ; .plotPointX = centre of ellipseX + .ellipseCurrentOffsetX
    CLC                                                 ;
    LDA .vduOldGraphicsCursorPixelsXLow                 ; centre of ellipse X
    ADC .ellipseCurrentOffsetXLow                       ;
    STA .plotPointXLow                                  ;
    LDA .vduOldGraphicsCursorPixelsXHigh                ; centre of ellipse X
    ADC .ellipseCurrentOffsetXHigh                      ;
    STA .plotPointXHigh                                 ;

    ; .plotPointY = centre of ellipseY + vertical distance from centre of ellipse
    CLC                                                 ;
    LDA .vduOldGraphicsCursorPixelsYLow                 ;
    ADC .ellipseCountHeightLow                          ;
    STA .plotPointYLow                                  ;
    LDA .vduOldGraphicsCursorPixelsYHigh                ;
    ADC .ellipseCountHeightHigh                         ;
    STA .plotPointYHigh                                 ;

    LDX #.vduWorkspaceCC - .vduVariablesStart           ;
    JSR .plotPointXInternal                             ;

    ; Same as above, but reflected
    LDA .ellipseCountHeightLow                          ; if drawing on the centre row,
    ORA .ellipseCountHeightHigh                         ; don't reflect.
    BEQ .return13                                       ;

    ; .plotPointX = centre of ellipseX - .ellipseCurrentOffsetX
    SEC                                                 ;
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    SBC .ellipseCurrentOffsetXLow                       ;
    STA .plotPointXLow                                  ;
    LDA .vduOldGraphicsCursorPixelsXHigh                ;
    SBC .ellipseCurrentOffsetXHigh                      ;
    STA .plotPointXHigh                                 ;

    ; .plotPointY = centre of ellipseX - vertical distance from centre of ellipse
    SEC                                                 ;
    LDA .vduOldGraphicsCursorPixelsYLow                 ;
    SBC .ellipseCountHeightLow                          ;
    STA .plotPointYLow                                  ;
    LDA .vduOldGraphicsCursorPixelsYHigh                ;
    SBC .ellipseCountHeightHigh                         ;
    STA .plotPointYHigh                                 ;

    LDX #.vduWorkspaceCC - .vduVariablesStart           ;
    JSR .plotPointXInternal                             ;

.return13
    LDY .ellipseTempY                                   ;
    LDX .ellipseTempX                                   ;
    RTS                                                 ;

; ***************************************************************************************
;
; Fills one row of a filled ellipse, and also its reflection
;
; On Entry:
;   X: the VDU variable for the left edge
;   Y: the VDU variable for the right edge
;   .ellipseCountHeight: the current vertical distance from the centre of the ellipse
;
; ***************************************************************************************
.fillEllipseOneRowAndReflection
    ; Fills one row of a filled ellipse given the extreme left and right points.
    ; also reflects about the centre of the ellipse to do the opposite row.
    STY .ellipseTempY                                   ; remember Y = right edge variable
    STX .ellipseTempX                                   ;          X = left edge variable

    ; .ellipsePointE = centre of ellipseX + vdu[Y]
    CLC                                                 ;
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    ADC .vduVariablesStart,Y                            ;
    STA .ellipsePointELow                               ;
    LDA .vduOldGraphicsCursorPixelsXHigh                ;
    ADC .vduVariablesStart+1,Y                          ;
    STA .ellipsePointEHigh                              ;

    ; .plotPointX = centre of ellipseX + vdu[X]
    CLC                                                 ;
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    ADC .vduVariablesStart,X                            ;
    STA .plotPointXLow                                  ;
    LDA .vduOldGraphicsCursorPixelsXHigh                ;
    ADC .vduVariablesStart+1,X                          ;
    STA .plotPointXHigh                                 ;

    ; .plotPointY = centre of ellipseY + vertical distance from centre of ellipse
    ; .ellipseCurrentOffsetX = .plotPointY
    CLC                                                 ;
    LDA .vduOldGraphicsCursorPixelsYLow                 ;
    ADC .ellipseCountHeightLow                          ;
    STA .plotPointYLow                                  ;
    STA .ellipseCurrentOffsetXLow                       ;
    LDA .vduOldGraphicsCursorPixelsYHigh                ;
    ADC .ellipseCountHeightHigh                         ;
    STA .plotPointYHigh                                 ;
    STA .ellipseCurrentOffsetXHigh                      ;

    ; Fill row
    LDX #.plotPointXLow - .vduVariablesStart            ;
    LDY #.ellipsePointELow - .vduVariablesStart         ;
    JSR .setMasksAndFillRow                             ;

    LDA .ellipseCountHeightLow                          ; if we are drawing a line through the centre of the ellipse,
    ORA .ellipseCountHeightHigh                         ; don't draw it twice.
    BEQ .return12                                       ;



    ; Same as above, but reflected
    LDX .ellipseTempX                                   ; X, Y recall the same VDU variables
    LDY .ellipseTempY                                   ; as given at the start of the routine...

    ; .ellipsePointE = centre of ellipseX - vdu[X]
    SEC                                                 ;
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    SBC .vduVariablesStart,X                            ; ...but access is swapped from above
    STA .ellipsePointELow                               ; (,X instead of ,Y and vice versa)
    LDA .vduOldGraphicsCursorPixelsXHigh                ; and subtract not add
    SBC .vduVariablesStart+1,X                          ;
    STA .ellipsePointEHigh                              ;

    ; .plotPointX = centre of ellipseX - vdu[Y]
    SEC                                                 ;
    LDA .vduOldGraphicsCursorPixelsXLow                 ;
    SBC .vduVariablesStart,Y                            ;
    STA .plotPointXLow                                  ;
    LDA .vduOldGraphicsCursorPixelsXHigh                ;
    SBC .vduVariablesStart+1,Y                          ;
    STA .plotPointXHigh                                 ;

    ; .plotPointY = centre of ellipseY - vertical distance from centre of ellipse
    ; .ellipseCurrentOffset = .plotPointY
    SEC                                                 ;
    LDA .vduOldGraphicsCursorPixelsYLow                 ;
    SBC .ellipseCountHeightLow                          ; [NOTE: subtract, not add circleOP this time]
    STA .plotPointYLow                                  ;
    STA .ellipseCurrentOffsetXLow                       ;
    LDA .vduOldGraphicsCursorPixelsYHigh                ;
    SBC .ellipseCountHeightHigh                         ;
    STA .plotPointYHigh                                 ;
    STA .ellipseCurrentOffsetXHigh                      ;

    ; Fill row
    LDX #.plotPointXLow - .vduVariablesStart            ;
    LDY #.ellipsePointELow - .vduVariablesStart         ;
    JSR .setMasksAndFillRow                             ;

.return12
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 24: Maths routines
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Unsigned divide (24 bit / 16 bit)
;
; 24 bit dividend over 16 bit divisor, result is 24 bit quotient
;
; On Entry:
;   X: VDU variable for 24 bit dividend
;   Y: VDU variable for 16 bit divisor
; On Exit:
;   24 bit quotient result has overwritten the dividend (at VDU variable X)
;   carry: if set means a divide by zero error
;
; ***************************************************************************************
.divide24by16bits
    ; Copy variables into zero page workspace
    STX .vduTempStoreDE                                 ; remember VDU variable for dividend

    ; Copy 24 bit dividend into zero page
    LDA .vduVariablesStart,X                            ; read dividend
    STA .dividend0                                      ; store in zp
    LDA .vduVariablesStart+1,X                          ; read dividend
    STA .dividend1                                      ; store in zp
    LDA .vduVariablesStart+2,X                          ; read dividend
    STA .dividend2                                      ; store in zp

    ; Copy 16 bit divisor into zero page
    LDA .vduVariablesStart,Y                            ; read divisor
    STA .divisor1                                       ; store in zp
    LDA .vduVariablesStart+1,Y                          ; read divisor
    STA .divisor2                                       ; store in zp

    ; Keep doubling divisor until the top bit is set
    LDX #8                                              ; X is 8 + number of times divisor is doubled
    LDY #16                                             ; loop counter, loop up to 16 times
    LDA .divisor2                                       ;
    BMI .divideMain                                     ; branch if done already
-
    INX                                                 ;
    ASL .divisor1                                       ; } scale up 16 bit divisor
    ROL .divisor2                                       ; }
    BMI .divideMain                                     ; branch if done
    DEY                                                 ;
    BNE -                                               ;

    ; If we get this far, it must be a zero divisor - so error out!
    SEC                                                 ; carry set = divide by zero error
    JMP .divideCopyBackQuotientResult                   ;

.divideMain
    ; At this point, X is the loop counter.
    ; i.e. We loop for X = 8 + number of times the divisor has been scaled up
    LDA #0                                              ;
    STA .divisor0                                       ;
    STA .quotient0                                      ; zero quotient (result)
    STA .quotient1                                      ;
    STA .quotient2                                      ;
.divideLoop
    ; temp = dividend - divisor
    SEC                                                 ;
    LDA .dividend0                                      ; dividend
    SBC .divisor0                                       ; subtract divisor
    STA .divideTemp0                                    ; store temp
    LDA .dividend1                                      ; dividend
    SBC .divisor1                                       ; subtract divisor
    STA .divideTemp1                                    ; store temp
    LDA .dividend2                                      ; dividend
    SBC .divisor2                                       ; subtract divisor
    STA .divideTemp2                                    ; store temp
    BCC .divideSkip                                     ;

    ; dividend = temp
    LDY #2                                              ; loop counter, loop 3 times to set 3 byte dividend
-
    LDA .divideTemp0,Y                                  ; temp
    STA .dividend0,Y                                    ;
    DEY                                                 ;
    BPL -                                               ;

.divideSkip
    ROL .quotient0                                      ; shift quotient
    ROL .quotient1                                      ;
    ROL .quotient2                                      ;

    LSR .divisor2                                       ; shift divisor
    ROR .divisor1                                       ;
    ROR .divisor0                                       ;
    DEX                                                 ;
    BPL .divideLoop                                     ;

    CLC                                                 ; carry clear = valid result
.divideCopyBackQuotientResult
    ; Write quotient back into dividend VDU variables
    LDX .vduTempStoreDE                                 ; recall VDU variable for dividend
    LDA .quotient0                                      ; and write quotient into it
    STA .vduVariablesStart,X                            ;
    LDA .quotient1                                      ;
    STA .vduVariablesStart+1,X                          ;
    LDA .quotient2                                      ;
    STA .vduVariablesStart+2,X                          ;
    RTS                                                 ;

; ***************************************************************************************
;
; Absolute difference (16 bit)
;
; Get the absolute value of the difference between VDU variables Y and X, and store it in
; VDU variable A.
;
; vdu[A] = abs(vdu[Y] - vdu[X])
;
; On Entry:
;   X,Y: VDU variables
; On Exit:
;   vdu[A]
;   carry is set if vdu[Y] < vdu[X]
;
; ***************************************************************************************
.absDifference16
    STA .vduTempStoreDF                                 ; remember VDU variable for the result
    SEC                                                 ;
    LDA .vduVariablesStart,Y                            ;
    SBC .vduVariablesStart,X                            ;
    STA .vduTempStoreDE                                 ; .vduTempStoreDE = vdu[Y]-vdu[X] (low)
    LDA .vduVariablesStart+1,Y                          ;
    SBC .vduVariablesStart+1,X                          ;

    LDX .vduTempStoreDF                                 ; recall VDU variable for the result
    STA .vduVariablesStart+1,X                          ; store high byte of result
    ROL                                                 ; carry = top bit (negative flag)
    LDA .vduTempStoreDE                                 ;
    STA .vduVariablesStart,X                            ; store low byte of result
    BCC .return11                                       ; if not negative then branch (return)

    ; Negate result
    LDA #0                                              ;
    SBC .vduVariablesStart,X                            ;
    STA .vduVariablesStart,X                            ;
    LDA #0                                              ;
    SBC .vduVariablesStart+1,X                          ;
    STA .vduVariablesStart+1,X                          ;
    SEC                                                 ;
.return11
    RTS                                                 ;

; ***************************************************************************************
;
; Negation (16 bit)
;
; the 16 bit value in VDU variable X and place the result in VDU variable Y
;
; On Entry:
;   X,Y are the offsets into the VDU variables to negate
;
; ***************************************************************************************
.negateVDUVariableXIntoY
    SEC                                                 ;
    LDA #0                                              ;
    SBC .vduVariablesStart,X                            ;
    STA .vduVariablesStart,Y                            ;
    LDA #0                                              ;
    SBC .vduVariablesStart+1,X                          ;
    STA .vduVariablesStart+1,Y                          ;
    RTS                                                 ;

; ***************************************************************************************
;
; 16 bit multiply
;
; 16 bit x 16 bit unsigned multiply, 32 bit result. This is implemented by calling a 24x24
; bit multiply with the top bytes zero. [NOTE: This is far from efficient in performance!]
;
; On Entry:
;   .multiplicand01: 16 bit number
;   .multiplier01:   16 bit number
; On Exit:
;   product:      48 bit result (top two bytes zero), shares memory with multiplier
;
; ***************************************************************************************
.multiply16x16
    LDA #0                                              ;
    STA .multiplier2                                    ;
    STA .multiplicand2                                  ;
    ; fall through...

; ***************************************************************************************
;
; 24 bit multiply
;
; 24 bit x 24 bit unsigned multiply, 48 bit result
;
; On Entry:
;   .multiplicand012: 24 bit number
;   .multiplier012:   24 bit number
; On Exit:
;   product:      48 bit result, shares memory with multiplier
;
; ***************************************************************************************
.multiply24x24
    LSR .multiplier2                                    ; }
    ROR .multiplier1                                    ; } rotate 24 bit multiplier right
    ROR .multiplier0                                    ; }
    ; Carry contains the lowest bit of the multiplier rotated out

    LDA #0                                              ; }
    STA .product5                                       ; } zero the top half of the result
    STA .product4                                       ; }
    STA .product3                                       ; }

    LDY #23                                             ; loop counter: loops 24 times
.multiplyLoop
    BCC .skipAdd                                        ; carry contains the lowest bit from the multiplier.
                                                        ; branch if not set
    CLC                                                 ;
    LDA .multiplicand0                                  ;
    ADC .product3                                       ;
    STA .product3                                       ;
    LDA .multiplicand1                                  ;
    ADC .product4                                       ; product345 += multiplicand
    STA .product4                                       ;
    LDA .multiplicand2                                  ;
    ADC .product5                                       ;
    STA .product5                                       ;
.skipAdd
    ; Shift the 48 bit result right
    CLC                                                 ; [BUG: this CLC instruction should be removed to make
                                                        ;       top bit set numbers produce the correct result]
    LDX #5                                              ; loop counter: loops 6 times
-
    ROR .product0,X                                     ;
    DEX                                                 ;
    BPL -                                               ;
    ; Carry contains the lowest bit of the multiplier rotated out (remember that the multiplier shares memory with product)

    DEY                                                 ;
    BPL .multiplyLoop                                   ;
    RTS                                                 ;

; ***************************************************************************************
;
; 32 bit square root
;
; Find square root of a 32 bit unsigned integer. [NOTE: This just falls through into the 48 bit
; square root function with the high bytes zero. This is not a good strategy for the best
; performance.]
;
; On Entry:
;   .sqrtNumber0123: number to sqrt (32 bits)
; On Exit:
;   .sqrtResult01: root (16 bits)
;   (.sqrtRemainder0123:  32 bit remainder is unused)
;
; ***************************************************************************************
.sqrt32
    LDA #0                                              ;
    STA .sqrtNumber4                                    ;
    STA .sqrtNumber5                                    ;
    ; fall through...

; ***************************************************************************************
;
; 48 bit square root
;
; Find square root of a 48 bit unsigned integer.
;
; On Entry:
;   sqrtNumber012345: number to sqrt (48 bits)
; On Exit:
;   sqrtResult012: root (24 bits)
;   (.sqrtRemainder0123:  32 bit remainder is unused)
;
; ***************************************************************************************
.sqrt48
    LDA #0                                              ;
    STA .sqrtResult0                                    ;
    STA .sqrtResult1                                    ;
    STA .sqrtResult2                                    ;
    STA .sqrtRemainder0                                 ;
    STA .sqrtRemainder1                                 ;
    STA .sqrtRemainder2                                 ;
    STA .sqrtRemainder3                                 ;

    LDX #24                                             ; loop counter
.sqrt_loop
    ; Shift number into remainder
    ASL .sqrtNumber0                                    ;
    ROL .sqrtNumber1                                    ;
    ROL .sqrtNumber2                                    ;
    ROL .sqrtNumber3                                    ;
    ROL .sqrtNumber4                                    ;
    ROL .sqrtNumber5                                    ;
    ROL .sqrtRemainder0                                 ;
    ROL .sqrtRemainder1                                 ;
    ROL .sqrtRemainder2                                 ;
    ROL .sqrtRemainder3                                 ;

    ; Shift number into remainder
    ASL .sqrtNumber0                                    ;
    ROL .sqrtNumber1                                    ;
    ROL .sqrtNumber2                                    ;
    ROL .sqrtNumber3                                    ;
    ROL .sqrtNumber4                                    ;
    ROL .sqrtNumber5                                    ;
    ROL .sqrtRemainder0                                 ;
    ROL .sqrtRemainder1                                 ;
    ROL .sqrtRemainder2                                 ;
    ROL .sqrtRemainder3                                 ;

    ; temp = root*2
    LDA .sqrtResult0                                    ;
    ASL                                                 ;
    STA .sqrtTemp0                                      ;
    LDA .sqrtResult1                                    ;
    ROL                                                 ;
    STA .sqrtTemp1                                      ;
    LDA .sqrtResult2                                    ;
    ROL                                                 ;
    STA .sqrtTemp2                                      ;
    LDA #0                                              ;
    ROL                                                 ;
    STA .sqrtTemp3                                      ;

    ; temp = temp*2 +1
    SEC                                                 ;
    ROL .sqrtTemp0                                      ;
    ROL .sqrtTemp1                                      ;
    ROL .sqrtTemp2                                      ;
    ROL .sqrtTemp3                                      ;

    ; Which is bigger, temp or remainder?
    SEC                                                 ; temp = remainder - temp
    LDA .sqrtRemainder0                                 ;
    SBC .sqrtTemp0                                      ;
    STA .sqrtTemp0                                      ;
    LDA .sqrtRemainder1                                 ;
    SBC .sqrtTemp1                                      ;
    STA .sqrtTemp1                                      ;
    LDA .sqrtRemainder2                                 ;
    SBC .sqrtTemp2                                      ;
    STA .sqrtTemp2                                      ;
    LDA .sqrtRemainder3                                 ;
    SBC .sqrtTemp3                                      ;
    STA .sqrtTemp3                                      ;

    ; If temp > remainder then branch
    BCC .sqrt_next                                      ; if (carry clear) then branch (forward)

    ; remainder = temp
    STA .sqrtRemainder3                                 ;
    LDA .sqrtTemp2                                      ;
    STA .sqrtRemainder2                                 ;
    LDA .sqrtTemp1                                      ;
    STA .sqrtRemainder1                                 ;
    LDA .sqrtTemp0                                      ;
    STA .sqrtRemainder0                                 ;

.sqrt_next
    ; root = root * 2 + carry
    ROL .sqrtResult0                                    ; shift result left and add carry
    ROL .sqrtResult1                                    ;
    ROL .sqrtResult2                                    ;
    DEX                                                 ;
    BEQ +                                               ; if (done 24 times) then branch

    JMP .sqrt_loop                                      ; loop back

+
    RTS                                                 ;

!if MACHINE = ELECTRON {
    ; Make it relatively obvious this isn't an original 1980s Acorn version for the Electron.
    !text "Steve 2020"
}

.unused
    ; skip to $bfdb, filling with zeros
    !align $ffff, $bfdb, 0

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 25: Credits
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; The credits
;
; Paul Fellows headed up the languages group at Acornsoft who developed this ROM.
;
; The ROM routines were mostly written by Richard Manby, with additional code from the rest of the
; languages group: Tony 'Sam' Thompson, Stuart 'Tutu' Swales, and Tim Dobson who came from the games
; division where he wrote Monsters, Maze and Magic Mushrooms. Who is 'Sharron' in the credits?
; Unclear. Is the ampersand an indication that Sharron was Paul's other half at the time?
;
; This same team (with additional members) went on to produce the 'Arthur' operating system for the
; Archimedes, with Paul Fellows heading up the group (and doing some coding):
;     Tony Thompson: Core OS (bootup, memory management etc).
;     Richard Manby: Graphics, Arthur Desktop (and later the 'Draw' program)
;        Tim Dobson: Text, Sound, Keyboard, Serial Port.
;     Stuart Swales: Filing system (Fileswitch), the heap manager?
;
; At this point just before Arthur became RISC-OS, Paul Fellows left Acorn.
;
; ***************************************************************************************
.credits
    ; Credits
    !text " Richard,"                                   ; Richard Manby
    !text "Sam,"                                        ; Tony 'Sam' Thompson
    !text "Tutu,"                                       ; Stuart 'Tutu' Swales
    !text "Tim,"                                        ; Tim Dobson
    !text "Paul &"                                      ; Paul Fellows
    !text " Sharron "                                   ; ?
